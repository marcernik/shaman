Performance Optimization - Table References
Nampower functions that return tables use reusable table references to reduce memory allocations and improve performance. This means the same table object is reused across multiple function calls, with its contents updated each time.

Functions Using Reusable Table References
The following functions use reusable table references:

GetCastInfo() - Returns cast information table
GetEquippedItems([unitToken]) - Returns equipped items table
GetBagItems([bagIndex]) - Returns bag items table
GetBagItem(bagIndex, slot) - Returns item info table
GetEquippedItem(unitToken, slot) - Returns item info table
GetSpellIdCooldown(spellId) - Returns cooldown detail table
GetItemIdCooldown(itemId) - Returns cooldown detail table
GetItemStats(itemId, [copy]) - Returns item stats table
GetUnitData(unitToken, [copy]) - Returns unit data table
GetSpellRec(spellId, [copy]) - Returns spell record table
GetItemStatsField(itemId, fieldName, [copy]) - Returns individual item field value
GetUnitField(unitToken, fieldName, [copy]) - Returns individual unit field value
GetSpellRecField(spellId, fieldName, [copy]) - Returns individual spell field value
GetTrinkets([copy]) - Returns trinket list table
Important: When using these functions without the copy parameter, immediately copy or extract any values you need to store for later use. Do not store references to the returned tables themselves. Alternatively, pass 1 as the copy parameter to get an independent table that is safe to store.

Note: Functions like GetItemStats, GetUnitData, and GetSpellRec also use reusable references for their nested array fields (e.g., bonusStat, auras, EffectImplicitTargetA). Each nested array field name has its own dedicated reference that is reused across calls.

-- ✓ SAFE - Extract values immediately
local castInfo = GetCastInfo()
if castInfo then
    local spellId = castInfo.spellId
    local castEnd = castInfo.castEndS
    -- Use spellId and castEnd later
end

-- ✓ SAFE - Extract nested array values immediately
local itemStats = GetItemStats(19019)
if itemStats then
    local bonusStats = {}
    for i = 1, #itemStats.bonusStat do
        bonusStats[i] = itemStats.bonusStat[i]
    end
    -- Now bonusStats is a safe independent copy
end

-- ✗ UNSAFE - Storing table references from the same function
local cast1 = GetCastInfo()  -- Gets table reference
-- ... later ...
local cast2 = GetCastInfo()  -- Gets SAME table reference with new data
-- cast1 and cast2 both point to the same table with cast2's data!

-- ✗ UNSAFE - Storing nested array references
local item1 = GetItemStats(19019)
local item1BonusStats = item1.bonusStat  -- Stores reference to nested array
local item2 = GetItemStats(22589)
-- item1BonusStats was overwritten! The "bonusStat" nested array reference is reused

-- ✓ SAFE - Using copy parameter for nested arrays
local item1 = GetItemStats(19019, 1)  -- Pass 1 to get independent copy
local item1BonusStats = item1.bonusStat  -- Safe to store, it's an independent copy
local item2 = GetItemStats(22589, 1)  -- Another independent copy
-- Both item1BonusStats and item2.bonusStat are independent tables
Important for array field functions: Each field name gets its own dedicated table reference, but the table is still reused across calls with the same field name. Always extract values immediately - never store the table reference itself. Alternatively, pass 1 as the copy parameter to get an independent table copy:

-- ✓ SAFE - Extract array values immediately
local bonusStats = {}
local tempTable = GetItemStatsField(itemId, "bonusStat")
for i = 1, #tempTable do
    bonusStats[i] = tempTable[i]
end
-- Now bonusStats is a safe independent copy

-- ✓ EASIER - Use copy parameter to get independent table
local bonusStats = GetItemStatsField(itemId, "bonusStat", 1)
-- Safe to store, no manual copying needed!

-- ✗ UNSAFE - Storing table references (even with different field names)
local bonusStats = GetItemStatsField(itemId, "bonusStat")
local bonusAmounts = GetItemStatsField(itemId, "bonusAmount")
-- Later...
local newBonusStats = GetItemStatsField(otherItemId, "bonusStat")
-- bonusStats was overwritten! The "bonusStat" reference is reused across calls

-- ✗ ALSO UNSAFE - Same field name, multiple calls
local item1Stats = GetItemStatsField(19019, "bonusStat")
local item2Stats = GetItemStatsField(22589, "bonusStat")
-- item1Stats was immediately overwritten by the second call!
Custom Lua Functions
Spell/Item/Unit information
GetItemStats(itemId, [copy])
Returns a Lua table reference containing all fields for the item's ItemStats record (including localized displayName and description). Returns nil if the item cannot be found or loaded.

Optional parameter: Pass 1 for copy to get an independent table copy instead of a reusable reference.

Full field name lists are in DBC_FIELDS.md.

GetItemStatsField(itemId, fieldName, [copy])
Fast lookup for a single field on an item. Returns the requested field value; returns nil if the item is not found; raises a Lua error if the field name is invalid.

Optional parameter: Pass 1 for copy to get an independent table copy (for array fields only).

Full field name lists are in DBC_FIELDS.md.

Examples:

-- Get item name
local name = GetItemStatsField(19019, "displayName")
print(name) -- "Thunderfury, Blessed Blade of the Windseeker"

-- Get item level
local ilvl = GetItemStatsField(22589, "itemLevel")
print("Atiesh item level: " .. ilvl) -- 90

-- Get item quality (0=Poor, 1=Common, 2=Uncommon, 3=Rare, 4=Epic, 5=Legendary)
local quality = GetItemStatsField(19019, "quality")
print("Quality: " .. quality) -- 5 (Legendary)

-- Get item delay (weapon speed in milliseconds)
local delay = GetItemStatsField(19019, "delay")
print("Weapon speed: " .. (delay / 1000) .. " seconds") -- 1.9 seconds
FindPlayerItemSlot(itemId or itemName)
Searches the player's inventory for an item by ID or name and returns its location.

Parameters:

itemId (number): The item ID to search for, OR
itemName (string): The item name to search for (case-insensitive)
Returns:

1st param (number or nil): Bag index where the item was found
nil = Equipped item (check 2nd param for equipment slot 0-18)
0 = Inventory pack
1-4 = Regular bags
-1 = Bank item slots
5-10 = Bank bags
-2 = Keyring
2nd param (number): Slot number within the bag (or equipment slot if 1st param is nil)
For equipped items: 0-18 (equipment slots are 0-indexed)
For bag 0, -1, -2: Returns relative slot position (1-indexed, 0-based within bag + 1)
Bag 0: slots 1-16 (corresponding to absolute slots 23-38)
Bag -1: slots 1-24 (corresponding to absolute bank slots 39-62)
Bag -2: slots 1-16 (corresponding to absolute keyring slots 81-96)
For regular bags (1-4) and bank bags (5-10): Returns 1-indexed slot within the bag
Returns nil,nil if the item is not found
Examples:

-- Find Thunderfury in player inventory
local bag, slot = FindPlayerItemSlot(19019)
if bag then
    print("Found in bag " .. bag .. " slot " .. slot)
    if bag == -1 or (bag >= 5 and bag <= 9) then
        print("Item is in bank")
    end
elseif bag == nil and slot then
    print("Item is equipped in slot " .. slot)
else
    print("Item not found")
end

-- Find item by name (uses cache for performance after first lookup)
local bag, slot = FindPlayerItemSlot("Hearthstone")
if slot then
    if bag == nil then
        print("Hearthstone is equipped in slot " .. slot)
    elseif bag == 0 then
        print("Hearthstone is in inventory pack slot " .. slot .. " (1-16)")
    elseif bag == -1 then
        print("Hearthstone is in bank slot " .. slot .. " (1-24)")
    elseif bag == -2 then
        print("Hearthstone is in keyring slot " .. slot .. " (1-16)")
    else
        print("Hearthstone is in bag " .. bag .. " slot " .. slot)
    end
end
UseItemIdOrName(itemIdOrName, [target])
Uses the first matching item found in the player's inventory (including equipped items) by item ID or name.

Parameters:

itemIdOrName (number|string): Item ID or item name (case-insensitive)
target (optional, string|number): Unit token (e.g. "target", "player") or GUID
If omitted, uses LockedTargetGuid if set; otherwise falls back to the active player GUID.
Returns:

1 if the item was found and CGItem_C::Use(...) returned non-zero
0 if the item was not found or use failed
Examples:

-- Use Hearthstone
UseItemIdOrName("Hearthstone")

-- Use a healing potion on yourself (if the item requires a target)
UseItemIdOrName(13446, "player")
GetEquippedItems(unitToken)
Returns a table reference containing all equipped items for the specified unit.

Parameters:

unitToken (string): Can be a standard unit token ("player", "target", "pet", etc.) or a GUID string
Returns:

A Lua table reference with equipment slot indices as keys (0-18) and item info tables as values
Returns nil if the unit cannot be found or inspected
For the player, item info includes:

itemId: The item's ID
stackCount: Number of items in the stack
duration: Item duration in milliseconds
spellCharges: Table of spell charges (indices 1-5)
flags: Item flags
permanentEnchantId: Permanent enchantment ID
tempEnchantId: Temporary enchantment ID
tempEnchantmentTimeLeftMs: Time remaining on temp enchant in milliseconds
tempEnchantmentCharges: Charges remaining on temp enchant
durability: Current durability
maxDurability: Maximum durability
For other inspected units (limited data):

itemId: The item's ID
permanentEnchantId: Permanent enchantment ID
tempEnchantId: Temporary enchantment ID
Examples:

-- Get all equipped items for your target
local items = GetEquippedItems("target")
if items then
    for slot, itemInfo in pairs(items) do
        print("Slot " .. slot .. ": Item ID " .. itemInfo.itemId)
        if itemInfo.permanentEnchantId and itemInfo.permanentEnchantId > 0 then
            print("  Permanent enchant: " .. itemInfo.permanentEnchantId)
        end
    end
end

-- Check player's weapon durability
local items = GetEquippedItems("player")
if items and items[15] then -- slot 15 is main hand
    local weapon = items[15]
    print("Weapon durability: " .. weapon.durability .. "/" .. weapon.maxDurability)
end
GetEquippedItem(unitToken, slot)
Returns item info for a specific equipment slot on the specified unit.

Parameters:

unitToken (string): Can be a standard unit token ("player", "target", "pet", etc.) or a GUID string
slot (number): Equipment slot number (0-18)
1 = Head, 2 = Neck, 3 = Shoulder, 4 = Shirt, 5 = Chest
6 = Waist, 7 = Legs, 8 = Feet, 9 = Wrist, 10 = Hands
11 = Finger 1, 12 = Finger 2, 13 = Trinket 1, 14 = Trinket 2
15 = Back, 16 = Main Hand, 17 = Off Hand, 18 = Ranged, 19 = Tabard
Returns:

A Lua table reference containing the item info (same fields as GetEquippedItems)
Returns nil if the slot is empty, unit cannot be found, or unit cannot be inspected
Examples:

-- Check target's main hand weapon
local weapon = GetEquippedItem("target", 16)
if weapon then
    print("Target has weapon: " .. weapon.itemId)
else
    print("Target has no main hand weapon")
end

-- Check your own helmet
local helm = GetEquippedItem("player", 1)
if helm and helm.durability then
    local durabilityPercent = (helm.durability / helm.maxDurability) * 100
    print("Helmet durability: " .. string.format("%.1f%%", durabilityPercent))
end
GetBagItems([bagIndex])
If no bagIndex is specified, the function returns a nested table reference containing all items in all bags (including bank if open). With specified index, it only returns the contents of that bag

Returns:

A Lua table reference with bag indices as keys and bag contents as values
Each bag contains 1-indexed slot numbers as keys and item info tables as values
Bag indices:
0 = Inventory pack (16 slots)
1-4 = Regular bags
-1 = Bank item slots (24 slots, only if bank is open)
5-10 = Bank bags (only if bank is open)
-2 = Keyring
Item info table fields (same as GetEquippedItems for player):

itemId, stackCount, duration, spellCharges, flags
permanentEnchantId, tempEnchantId, tempEnchantmentTimeLeftMs, tempEnchantmentCharges
durability, maxDurability
Examples:

-- Get all items in all bags
local allItems = GetBagItems()
for bagIndex, bagContents in pairs(allItems) do
    print("Bag " .. bagIndex .. ":")
    for slot, itemInfo in pairs(bagContents) do
        print("  Slot " .. slot .. ": " .. itemInfo.itemId .. " (x" .. itemInfo.stackCount .. ")")
    end
end

-- Get all items in backbag
local bagContents = GetBagItems(0)
for slot, itemInfo in pairs(bagContents) do
    print("  Slot " .. slot .. ": " .. itemInfo.itemId .. " (x" .. itemInfo.stackCount .. ")")
end

-- Count total number of a specific item
local function CountItem(itemId)
    local total = 0
    local allItems = GetBagItems()
    for bagIndex, bagContents in pairs(allItems) do
        for slot, itemInfo in pairs(bagContents) do
            if itemInfo.itemId == itemId then
                total = total + itemInfo.stackCount
            end
        end
    end
    return total
end

local soulShardCount = CountItem(6265)
print("Soul Shards: " .. soulShardCount)
GetBagItem(bagIndex, slot)
Returns item info for a specific slot in a specific bag.

Parameters:

bagIndex (number): The bag to check
0 = Inventory pack
1-4 = Regular bags
-1 = Bank item slots or buyback slots
5-10 = Bank bags (requires bank to be open)
-2 = Keyring
slot (number): 1-indexed slot number within the bag
Returns:

A Lua table reference containing the item info (same fields as GetBagItems)
Returns nil if the slot is empty or invalid
Examples:

-- Get item in first slot of first bag
local item = GetBagItem(1, 1)
if item then
    print("Item ID: " .. item.itemId)
    print("Stack count: " .. item.stackCount)
else
    print("Slot is empty")
end

-- Check durability of an item in inventory pack
local item = GetBagItem(0, 1)
if item and item.durability then
    print("Durability: " .. item.durability .. "/" .. item.maxDurability)
end

-- Check if a specific bank slot has an item (bank must be open)
local bankItem = GetBagItem(-1, 1)
if bankItem then
    print("Bank slot 1 contains: " .. bankItem.itemId)
end
GetSpellRec(spellId, [copy])
Returns a Lua table reference containing all fields for the spell's SpellRec record (including localized name and rank). Returns nil if the spell cannot be found.

Optional parameter: Pass 1 for copy to get an independent table copy instead of a reusable reference.

Full field name lists are in DBC_FIELDS.md.

GetSpellRecField(spellId, fieldName, [copy])
Fast lookup for a single field on a spell. Returns the requested field value; returns nil if the spell is not found; raises a Lua error if the field name is invalid.

Optional parameter: Pass 1 for copy to get an independent table copy (for array fields only).

Full field name lists are in DBC_FIELDS.md.

Examples:

-- Get spell name
local name = GetSpellRecField(116, "name")
print(name) -- "Frostbolt"

-- Get spell rank
local rank = GetSpellRecField(116, "rank")
print(rank) -- "Rank 1"

-- Get spell cast time in milliseconds
local castTime = GetSpellRecField(133, "castTime")
print("Fireball cast time: " .. (castTime / 1000) .. " seconds") -- 3.5 seconds

-- Get spell range (max range in yards * 10, so divide by 10)
local maxRange = GetSpellRecField(116, "rangeMax")
print("Frostbolt max range: " .. (maxRange / 10) .. " yards") -- 30 yards

-- Get spell mana cost
local manaCost = GetSpellRecField(116, "manaCost")
print("Mana cost: " .. manaCost)

-- Get spell school (0=Physical, 1=Holy, 2=Fire, 3=Nature, 4=Frost, 5=Shadow, 6=Arcane)
local school = GetSpellRecField(116, "school")
print("School: " .. school) -- 4 (Frost)

-- Get spell icon ID
local spellIconID = GetSpellRecField(116, "spellIconID")
print("Icon ID: " .. spellIconID)
GetSpellModifiers(spellId, modifierType)
Returns the current spell modifiers applied to a spell for the player. This includes buffs, talents, and other effects that modify spell behavior.

Parameters:

spellId (number): The spell ID to check
modifierType (number): The type of modifier to check (see list below)
Returns:

1st param (number): Flat modification value (e.g., +50 damage)
2nd param (number): Percent modification value (e.g., 10 for +10%)
3rd param (number): Return value from the function (whether there was any percent or flat modifier)
Modifier Types:

0 = DAMAGE
1 = DURATION
2 = THREAT
3 = ATTACK_POWER
4 = CHARGES
5 = RANGE
6 = RADIUS
7 = CRITICAL_CHANCE
8 = ALL_EFFECTS
9 = NOT_LOSE_CASTING_TIME
10 = CASTING_TIME
11 = COOLDOWN
12 = SPEED
14 = COST
15 = CRIT_DAMAGE_BONUS
16 = RESIST_MISS_CHANCE
17 = JUMP_TARGETS
18 = CHANCE_OF_SUCCESS
19 = ACTIVATION_TIME
20 = EFFECT_PAST_FIRST
21 = CASTING_TIME_OLD
22 = DOT
23 = HASTE
24 = SPELL_BONUS_DAMAGE
27 = MULTIPLE_VALUE
28 = RESIST_DISPEL_CHANCE
Example:

-- Check damage modifiers on Frostbolt (spell ID 116)
local flatMod, percentMod, ret = GetSpellModifiers(116, 0)
print("Flat damage bonus: " .. flatMod)
print("Percent damage bonus: " .. percentMod .. "%")
GetUnitData(unitToken, [copy])
Returns a Lua table reference containing all unit fields for the specified unit. This provides access to low-level unit data like health, mana, stats, auras, resistances, and more.

Parameters:

unitToken (string): Can be a standard unit token ("player", "target", "pet", "mouseover", etc.) or a GUID string (e.g., "0xF5300000000000A5")
copy (number, optional): Pass 1 to get an independent table copy instead of a reusable reference
Returns:

A Lua table reference containing all unit fields, or nil if the unit cannot be found
Full field name lists are in UNIT_FIELDS.md.

Example:

-- Get all unit data for your current target
local data = GetUnitData("target")
if data then
    print("Target health: " .. data.health .. "/" .. data.maxHealth)
    print("Target level: " .. data.level)
    print("Target display ID: " .. data.displayId)
end

-- Using a GUID
local data = GetUnitData("0xF5300000000000A5")
GetUnitField(unitToken, fieldName, [copy])
Fast lookup for a single field on a unit. More efficient than GetUnitData when you only need one specific field.

Parameters:

unitToken (string): Can be a standard unit token ("player", "target", "pet", "mouseover", etc.) or a GUID string
fieldName (string): The name of the field to retrieve
copy (number, optional): Pass 1 to get an independent table copy (for array fields only)
Returns:

The requested field value; returns nil if the unit is not found; raises a Lua error if the field name is invalid
For array fields (like "aura", "resistances"), returns a Lua table with numeric indices
Full field name lists are in UNIT_FIELDS.md.

Examples:

-- Get target's current health
local health = GetUnitField("target", "health")
print("Target health: " .. health)

-- Get player's current mana (power1)
local mana = GetUnitField("player", "power1")
print("Player mana: " .. mana)

-- Get all auras on target (returns a table)
local auras = GetUnitField("target", "aura")
for i, auraId in ipairs(auras) do
    print("Aura " .. i .. ": " .. auraId)
end

-- Get all resistances (returns a table)
local resistances = GetUnitField("player", "resistances")
-- resistances[1] = armor, [2] = holy, [3] = fire, [4] = nature, [5] = frost, [6] = shadow, [7] = arcane
QueueSpellByName(spellName)
Will force queue a spell regardless of the appropriate queue window. If no spell is currently being cast it will be cast immediately. For example can make a macro with

/run QueueSpellByName("Frostbolt");QueueSpellByName("Frostbolt")
to cast 2 frostbolts in a row. Currently, can only queue 1 GCD spell at a time and 5 non gcd spells. This means you can't do 3 frostbolts in a row with one macro.

CastSpellByNameNoQueue(spellName)
Will force a spell cast to never queue even if your settings would normally queue. Can be used to fix addons that don't work with queued spells.

QueueScript(script, [priority])
Queues any arbitrary script using the same logic as a regular spell using NP_SpellQueueWindowMs as the window. If no spell is being cast and you are not on the gcd the script will be run immediately.

Priority is optional and defaults to 1.
Priority 1 means the script will run before any other queued spells. Priority 2 means the script will run after any queued non gcd spells but before any queued normal spells. Priority 3 means the script will run after any type of queued spells.

Convert slash commands from other addons like /equip to their function form SlashCmdList.EQUIP to use them inside QueueScript.

For example, you can equip a libram before casting a queued heal using

/run QueueScript('SlashCmdList.EQUIP("Libram of +heal")')
IsSpellInRange(spellName, [target]) or IsSpellInRange(spellId, [target])
Takes a spell name or spell id and an optional target. Target can the usual UNIT tokens like "player", "target", "mouseover", etc or a unit guid.

If using spell name it must be a spell you have in your spellbook. If using spell id it can be any spell id.

Returns 1 if the spell is in range, 0 if not in range, and -1 if the spell is not valid for this check (must be TARGET_UNIT_PET, TARGET_UNIT_TARGET_ENEMY, TARGET_UNIT_TARGET_ALLY, TARGET_UNIT_TARGET_ANY). This is because this uses the same underlying function as IsActionInRange which returns 1 for spells that are not single target which can be misleading.

Examples:

/run local result=IsSpellInRange("Frostbolt"); if result == 1 then print("In range") else if result == 0 then print("Out of range") else print("Not single target") end
IsSpellUsable(spellName) or IsSpellUsable(spellId)
Takes a spell name or spell id.

Usable does not equal castable. This is most often used to check if a reactive spell is usable.

If using spell name it must be a spell you have in your spellbook. If using spell id it can be any spell id.

Returns:

1st param: 1 if the spell is usable, 0 if not usable. 2nd param: Always 0 if spell is not usable for a different reason other than mana. 1 if out of mana, 0 if not out of mana.

Examples:

/run local result=IsSpellUsable("Frostbolt"); if result == 1 then print("Frostbolt usable") else print("Frostbolt not usable") end
GetCurrentCastingInfo()
Returns:

1st param: Casting spell id or 0 2nd param: Visual spell id or 0. This won't always get cleared after a spell finishes. 3rd param: Auto repeating spell id or 0. 4th param: 1 if casting spell with a cast time, 0 if not. 5th param: 1 if channeling, 0 if not. 6th param: 1 if on swing spell is pending, 0 if not. 7th param: 1 if auto attacking, 0 if not.

For normal spells these will be the same. For some spells like auto-repeating and channeling spells only the visual spell id will be set.

Examples:

/run local castId,visId,autoId,casting,channeling,onswing,autoattack=GetCurrentCastingInfo();print(castId);print(visId);print(autoId);print(casting);print(channeling);print(onswing);print(autoattack);
GetCastInfo()
Returns detailed information about the currently active cast or channel. Returns nil if there is no active cast or channel. GetCurrentCastingInfo was made very early on and doesn't provide enough information for many use cases, but still has some uses and is available for backwards compatibility.

Returns: A Lua table reference with the following fields, or nil if no cast is active:

castId (number): Unique identifier for this cast
spellId (number): The spell ID being cast
guid (number): Target GUID (0 if no explicit target)
castType (number): Type of cast - 0=NORMAL, 3=CHANNEL, 4=TARGETING
castStartS (number): When the cast started in WoW time (seconds with decimals, e.g., 1234567.890)
castEndS (number): When the cast will end in WoW time (seconds with decimals)
castRemainingMs (number): Milliseconds remaining until cast ends
castDurationMs (number): Total cast duration in milliseconds
gcdEndS (number): When the GCD will end in WoW time (seconds with decimals)
gcdRemainingMs (number): Milliseconds remaining until GCD expires
Notes:

Time fields ending in S (castStartS, castEndS, gcdEndS) are absolute timestamps in seconds with decimal precision to match GetTime() in Lua
Duration and remaining fields ending in Ms (castRemainingMs, castDurationMs, gcdRemainingMs) are in milliseconds for precision
Returns nil if there is no active cast (castSpellId is 0) and no active channel (channelSpellId is 0)
Examples:

-- Check current cast information
local info = GetCastInfo()
if info then
    print("Casting spell: " .. info.spellId)
    print("Cast ends at: " .. info.castEndS)
    print("Time remaining: " .. info.castRemainingMs .. "ms")
    print("GCD ends at: " .. info.gcdEndS)
    print("GCD remaining: " .. info.gcdRemainingMs .. "ms")
else
    print("No active cast")
end

-- Check if you can cast another spell (GCD check)
local info = GetCastInfo()
if not info or info.gcdRemainingMs == 0 then
    print("Ready to cast!")
else
    print("On GCD for " .. info.gcdRemainingMs .. "ms more")
end

-- Monitor cast progress
local info = GetCastInfo()
if info and info.castDurationMs > 0 then
    local progress = ((info.castDurationMs - info.castRemainingMs) / info.castDurationMs) * 100
    print("Cast progress: " .. string.format("%.1f%%", progress))
end
GetSpellIdCooldown(spellId)
Returns detailed cooldown information for a spell from the spell history. This provides precise timing data for individual spell cooldowns, category cooldowns, and GCD.

Parameters:

spellId (number): The spell ID to check
Returns: A Lua table reference with the following fields:

isOnCooldown (number): 1 if any cooldown is active, 0 otherwise
cooldownRemainingMs (number): Maximum remaining time across all cooldown types in milliseconds
itemId (number): Item ID tied to the cooldown (0 if none)
itemHasActiveSpell (number): 1 if the item has an on-use spell, 0 otherwise
itemActiveSpellId (number): Spell ID of the active item spell (0 if none)
Individual Spell Cooldown:

individualStartS (number): When the individual spell cooldown started (seconds, WoW time)
individualDurationMs (number): Total duration of the individual spell cooldown in milliseconds
individualRemainingMs (number): Milliseconds remaining on the individual spell cooldown
isOnIndividualCooldown (number): 1 if the spell-specific cooldown is active, 0 otherwise
Category Cooldown:

categoryId (number): The cooldown category ID (0 if no category cooldown)
categoryStartS (number): When the category cooldown started (seconds, WoW time)
categoryDurationMs (number): Total duration of the category cooldown in milliseconds
categoryRemainingMs (number): Milliseconds remaining on the category cooldown
isOnCategoryCooldown (number): 1 if the category cooldown is active, 0 otherwise
GCD (Global Cooldown):

gcdCategoryId (number): The GCD category ID (typically 133 for most spells)
gcdCategoryStartS (number): When the GCD started (seconds, WoW time)
gcdCategoryDurationMs (number): Total GCD duration in milliseconds (typically 1500ms)
gcdCategoryRemainingMs (number): Milliseconds remaining on the GCD
isOnGcdCategoryCooldown (number): 1 if the GCD is active, 0 otherwise
Notes:

Time fields ending in S are absolute timestamps in seconds to match GetTime() in Lua
Fields ending in Ms are in milliseconds for precision
The spell must have been cast at least once for accurate data to be available
cooldownRemainingMs is the maximum of all three cooldown types
Example:

-- Check if Frostbolt is ready to cast
local cd = GetSpellIdCooldown(116) -- Frostbolt
if cd.isOnCooldown == 0 then
    print("Frostbolt is ready!")
else
    print("Frostbolt on cooldown for " .. cd.cooldownRemainingMs .. "ms")
    if cd.isOnGcdCategoryCooldown == 1 then
        print("  GCD: " .. cd.gcdCategoryRemainingMs .. "ms remaining")
    end
    if cd.isOnIndividualCooldown == 1 then
        print("  Spell CD: " .. cd.individualRemainingMs .. "ms remaining")
    end
    if cd.isOnCategoryCooldown == 1 then
        print("  Category CD: " .. cd.categoryRemainingMs .. "ms remaining")
    end
end
GetItemIdCooldown(itemId)
Returns detailed cooldown information for an item from the spell history. Works similarly to GetSpellIdCooldown but for items.

Parameters:

itemId (number): The item ID to check
Returns: A Lua table reference with the same structure as GetSpellIdCooldown (see above).

Notes:

Returns the longest cooldown among all spells associated with the item
If the item has multiple on-use effects, returns information for the one with the longest remaining cooldown
Item cooldowns are tracked through their associated spell entries in the spell history
Example:

-- Check if a trinket is ready
local cd = GetItemIdCooldown(12345) -- Replace with your trinket ID
if cd.isOnCooldown == 0 then
    print("Trinket is ready to use!")
else
    print("Trinket on cooldown for " .. cd.cooldownRemainingMs .. "ms")
end
GetTrinkets([copy])
Returns a table of trinkets from equipped trinket slots and carried bags.

Parameters:

[copy] (number|boolean, optional): Pass 1 (or any truthy value) to force creation of a fresh Lua table. By default the function reuses an internal table and entry tables for performance.
Returns: A Lua table where each entry contains:

itemId (number)
trinketName (string, "Unknown" if no name available)
texture (string): Texture name for the item icon
bagIndex (number|nil): nil when equipped; 0 for backpack; 1-4 for equipped bags
slotIndex (number): Lua 1-based slot within the container (or 1/2 for equipped trinket slots)
Notes:

Scans only equipped trinket slots and bags 0-4 (backpack + equipped bags). Does not scan bank or keyring.
Reuses cached Lua tables unless copyTable is truthy; prefer copies if you will mutate the returned tables.
GetTrinketCooldown(slot|itemIdOrName)
Returns cooldown information for the equipped trinket(s) in slots 13 or 14. Accepts slot shortcuts or item identifiers.

Parameters:

slot|itemIdOrName (number|string):
1 or 13 => first trinket slot
2 or 14 => second trinket slot
Any other number => treat as item ID to match against trinket slots
String => item name (case-insensitive) to match against trinket slots
Returns:

If no matching trinket is equipped in slots 13/14: returns -1
Otherwise: a cooldown detail table with the same structure as GetSpellIdCooldown / GetItemIdCooldown
Example:

-- Get cooldown for first trinket slot
local cd = GetTrinketCooldown(1)
if cd ~= -1 and cd.isOnCooldown == 0 then
    print("Trinket ready")
end

-- Check by name
local cd = GetTrinketCooldown("Royal Seal of Eldre'Thalas")
if cd ~= -1 then
    print("Remaining: " .. cd.cooldownRemainingMs .. "ms")
end
UseTrinket(slot|itemIdOrName, [target])
Uses a trinket from the equipped trinket slots (13 and 14 only).

Parameters:

slot|itemIdOrName (number|string):
1 or 13 => use first trinket slot
2 or 14 => use second trinket slot
Any other number => treat as item ID to find in trinket slots
String => item name (case-insensitive) to find in trinket slots
target (optional, string|number): Unit token or GUID. If omitted, uses LockedTargetGuid if set; otherwise falls back to active player GUID.
Returns:

1 if the trinket was found and CGItem_C::Use(...) returned non-zero
0 if the trinket was found but use returned zero
-1 if no matching trinket was found in slots 13/14
Examples:

-- Use first trinket slot
UseTrinket(1)
-- Use second trinket slot on current target
UseTrinket(2, "target")
-- Use by item id if present in either trinket slot
UseTrinket(18406)
-- Use by name
UseTrinket("Royal Seal of Eldre'Thalas")
GetSpellIdForName(spellName)
Returns:

1st param: the max rank spell id for a spell name if it exists in your spellbook. Returns 0 if the spell is not in your spellbook.

Examples:

/run local spellId=GetSpellIdForName("Frostbolt");print(spellId)
/run local spellId=GetSpellIdForName("Frostbolt(Rank 1)");print(spellId)
GetSpellNameAndRankForId(id)
Returns:

1st param: the spell name for a spell id 2nd param: the spell rank for a spell id as a string such as "Rank 1"

Examples:

/run local spellName,spellRank=GetSpellNameAndRankForId(116);print(spellName);print(spellRank)
prints "Frostbolt" and "Rank 1"
GetSpellSlotTypeIdForName(spellName)
Returns:

1st param: the 1 indexed (lua calls expect this) spell slot number for a spell name if it exists in your spellbook. Returns 0 if the spell is not in your spellbook. 2nd param: the book type of the spell, either "spell", "pet" or "unknown". 3rd param: the spell id of the spell. Returns 0 if the spell is not in your spellbook.

Examples:

/run local slot, bookType, spellId=GetSpellSlotTypeIdForName("Frostbolt");print(slot);print(bookType);print(spellId)
GetNampowerVersion()
Returns the current version of Nampower split into major, minor and patch numbers.

So if version was v2.8.6 it would return 2, 8, 6 as integers.

Examples:

/run local major, minor, patch=GetNampowerVersion();print(major);print(minor);print(patch)
The previous version of this GetSpellSlotAndTypeForName was removed as it was returning a 0 indexed slot number which was confusing to use in lua.

GetItemLevel(itemId)
Returns the item level of an item. Returns an error if the item id is invalid.

Examples:

/run local itemLevel=GetItemLevel(22589);print(itemLevel)
should print 90 for atiesh
ChannelStopCastingNextTick()
Will stop channeling early on the next tick if you have queue channeling spells enabled and try to cast a spell before the next tick (didn't know how to cancel channels without casting another spell). Uses your ChannelLatencyReductionPercentage to determine when to stop the channel.

Utility Functions
DisenchantAll(itemIdOrName, [includeSoulbound]) or DisenchantAll(quality, [includeSoulbound])
Automatically disenchants items in your inventory. Can disenchant a specific item by ID/name, or all weapons and armor of a specified quality.

⚠️ WARNING ⚠️ THIS FUNCTION WILL AUTOMATICALLY DISENCHANT ITEMS WITHOUT CONFIRMATION!

Use at your own risk - there is no undo for disenchanting
Only disenchants items from player inventory bags (backpack and bags 1-4)
Equipped items, bank items, and keyring are PROTECTED - will not be touched
Quest items are ALWAYS protected regardless of settings
Soulbound items are protected by default (can be overridden with optional parameter)
Make sure you have the Disenchant spell and the items are disenchantable before using
Always double-check your bags before running this command
Parameters:

Mode 1: Disenchant by Item ID or Name

itemIdOrName (number|string): Item ID (number) or item name (string)
Disenchants all copies of the specified item found in your bags
Works on any disenchantable item type (weapons, armor, etc.)
includeSoulbound (number, optional): Pass any non-zero value (e.g., 1) to include soulbound items (defaults to 0)
Mode 2: Disenchant by Quality (weapons and armor only)

quality (string): Can be a single quality or combination (pipe-separated):
"greens" - Disenchants all uncommon (green) quality weapons and armor
"blues" - Disenchants all rare (blue) quality weapons and armor
"purples" - Disenchants all epic (purple) quality weapons and armor
"greens|blues" - Disenchants both greens and blues
"blues|purples" - Disenchants both blues and purples
"greens|blues|purples" - Disenchants greens, blues, and purples
Only affects weapons (class 2) and armor (class 4)
includeSoulbound (number, optional): Pass any non-zero value (e.g., 1) to include soulbound items (defaults to 0)
Returns:

1 if the first disenchant succeeded
0 if no matching items were found or the disenchant failed
Behavior:

Searches player inventory bags (backpack and bags 1-4) only - equipped items, bank, and keyring are protected
Finds the first matching item in your inventory
Displays a chat message showing which item is being disenchanted
Casts Disenchant spell on that item
Automatically continues disenchanting matching items every 5 seconds
Stops when no more matching items are found or an error occurs
Displays completion or error messages in chat
Examples:

-- Disenchant all green weapons and armor in your bags (excluding soulbound)
DisenchantAll("greens")

-- Disenchant all blue weapons and armor including soulbound items
DisenchantAll("blues", 1)

-- Disenchant all purple (epic) weapons and armor
DisenchantAll("purples")

-- Disenchant both greens and blues
DisenchantAll("greens|blues")

-- Disenchant blues and purples including soulbound items
DisenchantAll("blues|purples", 1)

-- Disenchant all greens, blues, and purples
DisenchantAll("greens|blues|purples")

-- Disenchant a specific item by ID (excluding soulbound)
DisenchantAll(12345)

-- Disenchant a specific item by name including soulbound items
DisenchantAll("Glowing Brightwood Staff", 1)
Important Notes:

The function runs continuously until all matching items are disenchanted
Only searches inventory bags (backpack and bags 1-4) - equipped items, bank, and keyring are protected
When using quality mode ("greens"/"blues"/"purples" or combinations), only weapons and armor are affected
When using item ID/name mode, any disenchantable item can be targeted
Make sure you have enough bag space for the disenchanting materials
The function will stop if you run out of matching items or if the disenchant spell fails
Displays chat messages: "Disenchanting [Item Link] move during cast to cancel.", "No more items to disenchant.", and "Disenchant interrupted or failed."
REVIEW YOUR BAGS CAREFULLY BEFORE USE - disenchanting cannot be undone!

Unit Fields Reference
This document lists all available unit fields that can be accessed via GetUnitData() and GetUnitField() functions.

Overview
Unit fields provide low-level access to game data for any unit (player, target, pet, NPCs, etc.). These fields are part of the WoW 1.12 client's internal data structures.

Usage
-- Get all fields at once
local data = GetUnitData("target")
if data then
    print("Health: " .. data.health)
end

-- Get a single field (more efficient)
local health = GetUnitField("target", "health")
Simple Fields
These fields return a single value (number).

Object References (UINT64)
These fields contain GUIDs (globally unique identifiers) for game objects:

charm - GUID of the unit that has charmed this unit
summon - GUID of the unit's current summon
charmedBy - GUID of the unit that charmed this unit
summonedBy - GUID of the unit that summoned this unit
createdBy - GUID of the unit that created this unit
target - GUID of the unit's current target
persuaded - GUID of the unit being persuaded
channelObject - GUID of the object being channeled (for channeling spells)
Health and Power (UINT32)
health - Current health points
power1 - Current mana (or energy/rage depending on class)
power2 - Current rage
power3 - Current focus (hunter pets)
power4 - Current energy (rogues, druids in cat/bear form)
power5 - Current happiness (hunter pets)
maxHealth - Maximum health points
maxPower1 - Maximum mana
maxPower2 - Maximum rage
maxPower3 - Maximum focus
maxPower4 - Maximum energy
maxPower5 - Maximum happiness
Basic Unit Info (UINT32)
level - Unit's level
factionTemplate - Unit's faction template ID
flags - Unit flags (combat, dead, mounted, etc.)
dynamicFlags - Dynamic unit flags (lootable, tapped, etc.)
auraState - Aura state flags (reactive abilities like Revenge, Overpower)
npcFlags - NPC flags (vendor, trainer, quest giver, etc.)
npcEmoteState - Current emote state ID
Display and Appearance (UINT32)
displayId - Current display model ID
nativeDisplayId - Original/native display model ID
mountDisplayId - Mount display model ID (if mounted)
Combat Stats (UINT32)
baseAttackTime - Base main-hand attack time in milliseconds
offhandAttackTime - Off-hand attack time in milliseconds
rangedAttackTime - Ranged attack time in milliseconds
Combat Stats (FLOAT)
boundingRadius - Unit's bounding radius for collision
combatReach - Unit's combat reach distance
minDamage - Minimum main-hand damage
maxDamage - Maximum main-hand damage
minOffhandDamage - Minimum off-hand damage
maxOffhandDamage - Maximum off-hand damage
minRangedDamage - Minimum ranged damage
maxRangedDamage - Maximum ranged damage
Pet Info (UINT32)
petNumber - Pet's number identifier
petNameTimestamp - Timestamp of pet name
petExperience - Pet's current experience
petNextLevelExp - Experience needed for pet's next level
Spell/Channel Info (UINT32)
channelSpell - Spell ID of currently channeling spell
createdBySpell - Spell ID that created this unit (for summons)
Casting Speed (FLOAT)
modCastSpeed - Cast speed modifier (1.0 = normal, <1.0 = faster, >1.0 = slower)
Training (UINT32)
trainingPoints - Available training points (for pets and talents)
Base Stats (UINT32)
stat0 - Strength
stat1 - Agility
stat2 - Stamina
stat3 - Intellect
stat4 - Spirit
baseMana - Base mana before modifiers
baseHealth - Base health before modifiers
Attack Power (UINT32)
attackPower - Total melee attack power
attackPowerMods - Attack power modifiers
rangedAttackPower - Total ranged attack power
rangedAttackPowerMods - Ranged attack power modifiers
Attack Power Multipliers (FLOAT)
attackPowerMultiplier - Melee attack power multiplier
rangedAttackPowerMultiplier - Ranged attack power multiplier
Packed Byte Fields (UINT32)
These are special fields that pack multiple values into a single 32-bit integer:

bytes0 - Contains race, class, gender, and power type

Byte 0: Race
Byte 1: Class
Byte 2: Gender
Byte 3: Power type
bytes1 - Contains stand state, pet talent points, vis flags, and anim tier

Byte 0: Stand state
Byte 1: Pet talent points
Byte 2: Vis flags
Byte 3: Anim tier
bytes2 - Contains sheath state, pvp flags, pet flags, and shape shift form

Byte 0: Sheath state
Byte 1: PvP flags
Byte 2: Pet flags
Byte 3: Shape shift form
Array Fields
These fields return a Lua table with numeric indices (1-based).

Visual Items (UINT32 arrays)
virtualItemDisplay [3] - Display IDs for virtual items (weapon visuals, etc.)
virtualItemInfo [6] - Additional virtual item information
Auras/Buffs/Debuffs (UINT32 arrays)
aura [48] - Array of aura (buff/debuff) spell IDs on the unit

Index 1-48 contains spell IDs (0 = no aura in that slot)
auraFlags [6] - Bit flags for aura properties (positive, negative, cancelable, etc.)

Each UINT32 contains flags for 8 auras (4 bits per aura)
auraLevels [48] - Aura caster levels (UINT8 per aura slot)

auraApplications [48] - Aura stack counts (UINT8 per aura slot)

Resistances (UINT32 arrays)
resistances [7] - Resistance values for all schools
Index 1: Armor (physical resistance)
Index 2: Holy resistance
Index 3: Fire resistance
Index 4: Nature resistance
Index 5: Frost resistance
Index 6: Shadow resistance
Index 7: Arcane resistance
Spell Power Modifiers (FLOAT arrays)
powerCostModifier [7] - Flat mana cost modifications per school

Index 1-7: Physical, Holy, Fire, Nature, Frost, Shadow, Arcane
powerCostMultiplier [7] - Percent mana cost modifications per school

Index 1-7: Physical, Holy, Fire, Nature, Frost, Shadow, Arcane
Examples
Health Monitoring
-- Monitor target health percentage
local health = GetUnitField("target", "health")
local maxHealth = GetUnitField("target", "maxHealth")
local healthPct = (health / maxHealth) * 100
print("Target health: " .. healthPct .. "%")
Checking Auras
-- Check if target has a specific debuff
local auras = GetUnitField("target", "aura")
local CURSE_OF_AGONY = 980

for i, spellId in ipairs(auras) do
    if spellId == CURSE_OF_AGONY then
        print("Target has Curse of Agony!")
        break
    end
end
Reading Resistances
-- Get all player resistances
local resistances = GetUnitField("player", "resistances")
print("Armor: " .. resistances[1])
print("Holy resistance: " .. resistances[2])
print("Fire resistance: " .. resistances[3])
print("Nature resistance: " .. resistances[4])
print("Frost resistance: " .. resistances[5])
print("Shadow resistance: " .. resistances[6])
print("Arcane resistance: " .. resistances[7])
Checking Combat State
-- Check if unit is in combat (flags field bit check)
local flags = GetUnitField("target", "flags")
local UNIT_FLAG_IN_COMBAT = 0x00080000
local inCombat = bit.band(flags, UNIT_FLAG_IN_COMBAT) ~= 0
print("In combat: " .. tostring(inCombat))
Monitoring Cast Speed
-- Check your current cast speed modifier
local modCastSpeed = GetUnitField("player", "modCastSpeed")
-- 1.0 = normal, 0.9 = 10% faster, 1.1 = 10% slower
print("Cast speed modifier: " .. modCastSpeed)
Attack Power Info
-- Get your attack power
local ap = GetUnitField("player", "attackPower")
local apMods = GetUnitField("player", "attackPowerMods")
local apMult = GetUnitField("player", "attackPowerMultiplier")
print("Base AP: " .. ap)
print("AP Mods: " .. apMods)
print("AP Multiplier: " .. apMult)
Pet Information
-- Check pet experience
if UnitExists("pet") then
    local petXP = GetUnitField("pet", "petExperience")
    local petNextXP = GetUnitField("pet", "petNextLevelExp")
    local progress = (petXP / petNextXP) * 100
    print("Pet XP: " .. progress .. "%")
end
Notes
GUID fields return numbers but represent 64-bit values. Lua handles these as doubles.
Array indices are 1-based (Lua convention), not 0-based.
Returns nil if the unit doesn't exist or the field cannot be read.
Some fields may require specific game state to be meaningful (e.g., pet fields only work when you have a pet).
Unit flags and other bit fields require bitwise operations to interpret properly.
Related Functions
GetUnitData(unitToken) - Get all fields at once
GetUnitField(unitToken, fieldName) - Get a single field efficiently
GetSpellModifiers(spellId, modifierType) - Get spell modifiers
GetItemStats(itemId) - Get item data
GetSpellRec(spellId) - Get spell data

v2.0.0 Changes
Added spell queuing, automatic retry on error, and quickcasting with lots of customization.

Some other key improvements over Namreeb's version:

Using a buffer to avoid server rejections from casting too quickly (namreeb's uses 0 buffer). See 'Why do I need a buffer?' below for more info.
Using high_resolution_clock instead of GetTickCount for faster timing on when to start casts
Fix broken cast animations when casting spells back to back
Compatability with other addons
Queuing can cause issues with some addons that also manage spell casting. Quickheal/Healbot/Quiver do not work well with queuing. Check github issues for other potential incompatibilities. If someone rewrites these addons to use guids from superwow that would likely fix all issues.

Additionally, if you use pfui mouseover macros there is a timing issue that can occur causing it to target yourself instead of your mouseover target. If you have superwow and latest pfui issue is fixed.

Notgrid mouseover needs to be updated to take advantage of superwow the default version won't work well with queuing.

If you use healcomm can replace all instances of it in your addons with this version to work well with queuing https://github.com/MarcelineVQ/LunaUnitFrames/blob/TurtleWoW/libs/HealComm-1.0/HealComm-1.0.lua (requires superwow).

If all else fails can turn off queuing for a specific macro like so depending on the spell being cast:

/run SetCVar("NP_QueueCastTimeSpells", "0")
/run SetCVar("NP_QueueInstantSpells", "0")
/pfcast YOUR_SPELL
/run SetCVar("NP_QueueCastTimeSpells", "1")
/run SetCVar("NP_QueueInstantSpells", "1")
Installation
Grab the latest nampower.dll from https://gitea.com/avitasia/nampower/releases and place in the same directory as WoW.exe. You can also get the helper addon mentioned below and place that in Interface/Addons.

You will need launch the game with a launcher like Vanillafixes https://github.com/hannesmann/vanillafixes or Unitxp https://github.com/allfoxwy/UnitXP_SP3 to actually have the nampower dll get loaded.

If you would prefer to compile yourself you will need to get:

boost 1.80 32 bit from https://www.boost.org/users/history/version_1_80_0.html
hadesmem from https://github.com/namreeb/hadesmem
CMakeLists.txt is currently looking for boost at set(BOOST_INCLUDEDIR "C:/software/boost_1_80_0") and hadesmem at set(HADESMEM_ROOT "C:/software/hadesmem-v142-Debug-Win32"). Edit as needed.

Configuration
Configure with addon
There is a companion addon to make it easy to check/change the settings in game. You can download it here - nampowersettings.

Manual Configuration
The following CVars control the behavior of the spell queuing system:

You can access CVars in game with /run DEFAULT_CHAT_FRAME:AddMessage(GetCVar("CVarName"))
and set them with /run SetCVar("CVarName", "Value")

You can also just place them in your Config.wtf file in your WTF folder. If they are the default value they will not be written to the file. Example:

SET EnableMusic "0"
SET MasterSoundEffects "0"

SET NP_QuickcastTargetingSpells "1"
SET NP_SpellQueueWindowMs "1000"
SET NP_TargetingQueueWindowMs "1000"
NP_QueueCastTimeSpells - Whether to enable spell queuing for spells with a cast time. 0 to disable, 1 to enable. Default is 1.

NP_QueueInstantSpells - Whether to enable spell queuing for instant cast spells tied to gcd. 0 to disable, 1 to enable. Default is 1.

NP_QueueChannelingSpells - Whether to enable channeling spell queuing as well as whether to allow any queuing during channels. 0 to disable, 1 to enable. Default is 1.

NP_QueueTargetingSpells - Whether to enable terrain targeting spell queuing. 0 to disable, 1 to enable. Default is 1.

NP_QueueOnSwingSpells - Whether to enable on swing spell queuing. 0 to disable, 1 to enable. Default is 0 (changed with 1.17.2 due to changes to on swing spells).

NP_QueueSpellsOnCooldown - Whether to enable queuing for spells coming off cooldown. 0 to disable, 1 to enable. Default is 1.

NP_InterruptChannelsOutsideQueueWindow - Whether to allow interrupting channels (the original client behavior) when trying to cast a spell outside the channeling queue window. Default is 0.

NP_SpellQueueWindowMs - The window in ms before a cast finishes where the next will get queued. Default is 500.

NP_OnSwingBufferCooldownMs - The cooldown time in ms after an on swing spell before you can queue on swing spells. Default is 500.

NP_ChannelQueueWindowMs - The window in ms before a channel finishes where the next will get queued. Default is 1500.

NP_TargetingQueueWindowMs - The window in ms before a terrain targeting spell finishes where the next will get queued. Default is 500.

NP_CooldownQueueWindowMs - The window in ms of remaining cooldown where a spell will get queued instead of failing with 'Spell not Ready Yet'. Default is 250.

NP_MinBufferTimeMs - The minimum buffer delay in ms added to each cast (covered more below). The dynamic buffer adjustments will not go below this value. Default is 55.

NP_NonGcdBufferTimeMs - The buffer delay in ms added AFTER each cast that is not tied to the gcd. Default is 100.

NP_MaxBufferIncreaseMs - The maximum amount of time in ms to increase the buffer by when the server rejects a cast. This prevents getting too long of a buffer if you happen to get a ton of rejections in a row. Default is 30.

NP_RetryServerRejectedSpells - Whether to retry spells that are rejected by the server for these reasons: SPELL_FAILED_ITEM_NOT_READY, SPELL_FAILED_NOT_READY, SPELL_FAILED_SPELL_IN_PROGRESS. 0 to disable, 1 to enable. Default is 1.

NP_QuickcastTargetingSpells - Whether to enable quick casting for ALL spells with terrain targeting. This will cause the spell to instantly cast on your cursor without waiting for you to confirm the targeting circle. Queuing targeting spells will use quickcasting regardless of this value. 0 to disable, 1 to enable. Default is 0.

NP_QuickcastOnDoubleCast - Whether to allow casting targeting spells by attempting to cast them twice, as opposed to the default client behavior which cancels the targeting indicator on double cast. This provides an alternative way to quickcast targeting spells without enabling it for all targeting spells. 0 to disable, 1 to enable. Default is 0.

NP_ReplaceMatchingNonGcdCategory - Whether to replace any queued non gcd spell when a new non gcd spell with the same StartRecoveryCategory is cast (more explanation below). 0 to disable, 1 to enable. Default is 0.

NP_OptimizeBufferUsingPacketTimings - Whether to attempt to optimize your buffer using your latency and server packet timings (more explanation below). 0 to disable, 1 to enable. Default is 0.

NP_PreventRightClickTargetChange - Whether to prevent right-clicking from changing your current target when in combat. If you don't have a target right click will still change your target even with this on. This is mainly to prevent accidentally changing targets in combat when trying to adjust your camera. 0 to disable, 1 to enable. Default is 0.

NP_PreventRightClickPvPAttack - Whether to prevent right-clicking on PvP flagged players to avoid accidental PvP attacks. 0 to disable, 1 to enable. Default is 0.

NP_DoubleCastToEndChannelEarly - Whether to allow double casting a spell within 350ms to end channeling on the next tick. Takes into account your ChannelLatencyReductionPercentage. 0 to disable, 1 to enable. Default is 0.

NP_SpamProtectionEnabled - Whether to enable spam protection functionality that blocks spamming spells while waiting for the server to respond to your initial cast due to issues spamming can cause. 0 to disable, 1 to enable. Default is 1.

NP_PreventMountingWhenBuffCapped - Whether to prevent mounting when you have 32 buffs (buff capped) and are not already mounted. This prevents the issue where you mount but cannot dismount because the mount aura fails to apply due to the buff cap. When blocked, displays an error message. 0 to disable, 1 to enable. Default is 1.

NP_EnableAuraCastEvents - Whether to enable AURA_CAST_ON_SELF and AURA_CAST_ON_OTHER events. 0 to disable, 1 to enable. Default is 0.

NP_EnableAutoAttackEvents - Whether to enable AUTO_ATTACK_SELF and AUTO_ATTACK_OTHER events. 0 to disable, 1 to enable. Default is 0.

NP_EnableSpellStartEvents - Whether to enable SPELL_START_SELF and SPELL_START_OTHER events. 0 to disable, 1 to enable. Default is 0.

NP_EnableSpellGoEvents - Whether to enable SPELL_GO_SELF and SPELL_GO_OTHER events. 0 to disable, 1 to enable. Default is 0.

NP_ChannelLatencyReductionPercentage - The percentage of your latency to subtract from the end of a channel duration to optimize cast time while hopefully not losing any ticks (more explanation below). Default is 75.

NP_NameplateDistance - The distance in yards to display nameplates. Defaults to whatever was set by the game or vanilla tweaks.

Existing Lua Changes
Improved flexibility on spellbook Lua functions
These built-in Lua spell APIs now accept any of the following as their first argument: 1) spell slot (original behavior), 2) spell name, or 3) spellId:number.

Name and spellId lookups are cached internally and validated against current spellbook contents before reuse so you don't have to worry about performance implications or issues after respec'ing.

See examples below for differences in how BOOKTYPE works.

Functions: GetSpellTexture, GetSpellName, GetSpellCooldown, GetSpellAutocast, ToggleSpellAutocast, PickupSpell, CastSpell, IsCurrentCast, IsSpellPassive.

Examples:

/run print(GetSpellTexture(1, "spell")) -- booktype required
/run print(GetSpellTexture("spellId:25978")) -- defaults to BOOKTYPE_SPELL
/run print(GetSpellTexture("spellId:6268", "pet")) -- "pet" needed for pet spells
/run print(GetSpellTexture("Fireball")) -- name search
Custom Lua Functions
For complete documentation of all custom Lua functions added by Nampower, see SCRIPTS.md.

This includes functions for:

Spell/item/unit information (GetItemStats, GetSpellRec, GetUnitData, etc.)
Spell casting and queuing (QueueSpellByName, QueueScript, etc.)
Cast information (GetCastInfo, GetCurrentCastingInfo)
Cooldown tracking (GetSpellIdCooldown, GetItemIdCooldown), including item metadata on cooldown detail tables
Inventory helpers (GetTrinketCooldown, GetTrinkets)
Spell lookups and utilities
Cooldown detail tables now also expose itemId, itemHasActiveSpell, and itemActiveSpellId alongside the existing per-category timing data.

Use GetTrinkets([copy]) to enumerate equipped trinkets and bagged trinkets (backpack/bags 1-4) with itemId, trinketName, texture, itemLevel, bagIndex (nil when equipped), and 1-based slotIndex. It reuses cached tables by default; pass 1 (or any truthy value) to force a fresh copy.

Custom Events
For complete documentation of all custom events added by Nampower, see EVENTS.md.

Available events:

SPELL_QUEUE_EVENT - Fires when spells are queued or dequeued
SPELL_CAST_EVENT - Fires when you cast a spell with additional information. Triggered when you start casting a spell in the client before it is sent to the server.
SPELL_START_SELF and SPELL_START_OTHER - Triggered by the server to notify that a spell with a cast time has begun.
SPELL_GO_SELF and SPELL_GO_OTHER - Triggered by the server to indicate a spell completed casting.
SPELL_DAMAGE_EVENT_SELF and SPELL_DAMAGE_EVENT_OTHER - Combat damage events
Buff/Debuff Events (BUFF_ADDED_SELF, BUFF_REMOVED_SELF, etc.)
AURA_CAST_ON_SELF and AURA_CAST_ON_OTHER - Aura application events (fires once per aura effect per target; "Self" fires when the aura lands on the active player, including self-cast with no explicit target; includes aura metadata + amplitude/misc + aura cap bitfield for buff/debuff slots). Handles single-target and multi-target (AOE) spells. Some auras don't have spell effects and won't trigger this; use BUFF/DEBUFF gains for those. Set NP_EnableAuraCastEvents=1 to enable. See EVENTS.md for details on multi-target behavior and known limitations.
AUTO_ATTACK_SELF and AUTO_ATTACK_OTHER - Auto attack round events (fires when auto attack hits are processed; includes damage, hit info, victim state, absorb/resist/block amounts). Set NP_EnableAutoAttackEvents=1 to enable. See EVENTS.md for details.
UNIT_DIED - Fires when a unit dies
Bug Reporting
If you encounter any bugs please report them in the issues tab. Please include the nampower_debug.txt file in the same directory as your WoW.exe to help me diagnose the issue. If you are able to reproduce the bug please include the steps to reproduce it. In a future version once bugs are ironed out I'll make logging optional.

FAQ & Additional Info
How does queuing work?
Trying to cast a spell within the appropriate window before your current spell finishes will queue your new spell.
The spell will be cast as soon as possible after the current spell finishes.

There are separate configurable queue windows for:

Normal spells
On swing spells (the window functions as a cooldown instead where you cannot immediately double queue on swing spells so that I don't have to track swing timers)
Channeling spells
Spells with terrain targeting
There are 3 separate queues for the following types of spells: GCD(max size:1), non GCD(max size:6), and on-hit(max size:1).

Additionally the queuing system will ignore spells with any of the following attributes/effects to avoid issues with tradeskills/enchants/other out of combat activities:

SpellAttributes::SPELL_ATTR_TRADESPELL
SpellEffects::SPELL_EFFECT_TRADE_SKILL
SpellEffects::SPELL_EFFECT_ENCHANT_ITEM
SpellEffects::SPELL_EFFECT_ENCHANT_ITEM_TEMPORARY
SpellEffects::SPELL_EFFECT_CREATE_ITEM
SpellEffects::SPELL_EFFECT_OPEN_LOCK
SpellEffects::SPELL_EFFECT_OPEN_LOCK_ITEM
Why do I need a buffer?
From my own testing it seems that a buffer is required on spells to avoid "This ability isn't ready yet"/"Another action in progress" errors.
By that I mean that if you cast a 1.5 second cast time spell every 1.5 seconds without your ping changing you will occasionally get errors from the server and your cast will get rejected. If you have 150ms+ ping this can be very punishing.

I believe this is related to the server tick during which incoming spells are processed. There is logic to subtract the server processing time from your gcd in vmangos but other servers do not appear to be doing this.

To compensate for what seems to be a 50ms server tick the default buffer in nampower.cfg is 55ms. If you are close to the server you can experiment with lowering this value. You will occasionally get errors but if they are infrequent enough for you the time saved will be worth it.

Non gcd spells also seem to be affected by this. I suspect that only one spell can be processed per server tick.
This means that if you try to cast 2 non gcd spells in the same server tick only one will be processed.
To avoid this happening there is NP_NonGcdBufferTimeMs which is added after each non gcd spell. There might be more to it than this as using the normal buffer of 55ms was still resulting in skipped casts for me. I found 100ms to be a safe value.

GCD Spells
Only one gcd spell can be queued at a time. Pressing a new gcd spell will replace any existing queued gcd spell.

As of 5/13/2025 the server tick is now subtracted from the gcd timer so a buffer is no longer required for spells with a cast time at least ~50ms less than their gcd :)

Non GCD Spells
Non gcd spells have special handling. You can queue up to 6 non gcd spells, and they will execute in the order queued with NP_NonGcdBufferTimeMs delay after each of them to help avoid server rejection.
The non gcd queue always has priority over queued normal spells.
You can only queue a given spellId once in the non gcd queue, any subsequent attempts will just replace the existing entry in the queue.

NP_ReplaceMatchingNonGcdCategory will cause non gcd spells with the same non zero StartRecoveryCategory to replace each other in the queue.
The vast majority of spells not on the gcd have category '0' so it ignores them to avoid causing issues.
One notable exception is shaman totems that were changed to have separate categories according to their elements.

This can be useful if you want to change your mind about the non gcd spell you have queued. For example, if you queue a mana potion and decide you want to use LIP instead last minute.

On hit Spells
Only one on hit spell can be queued at a time. Pressing a new on hit spell will replace any existing queued on hit spell.
On hit spells have no effect on the gcd or non gcd queues as they are handled entirely separately and are resolved by your auto attack.

Channeling Spells
Channeling spells function differently than other spells in that the channel in the client actually begins when you receive the CHANNEL_START packet from the server. This means the client channel is happening 1/2 your latency after the server channel and that server tick delay is already included in the cast, whereas regular spells are the other way around (the client is ahead of the server).

From my testing it seems that you can usually subtract your full latency from the end of the channel duration without losing any ticks. Since your latency can vary it is safer to do a percentage of your latency instead to minimize the chance of having a tick cut off. This is controlled by the cvar NP_ChannelLatencyReductionPercentage which defaults to 75.

Channeling spells can be interrupted outside the channel queue window by casting any spell if NP_InterruptChannelsOutsideQueueWindow is set to 1. During the channel queue window you cannot interrupt the channel unless you turn off NP_QueueChannelingSpells. You can always move to interrupt a channel at any time.

Spells on Cooldown
If using NP_QueueSpellsOnCooldown when you attempt to cast a spell that has a remaining cooldown of less than NP_CooldownQueueWindowMs it will be queued instead of failing with 'Spell not Ready Yet'. There is a separate queue of size 1 for normal spells and non gcd spells. If something is in either of these cooldown queues and you try to cast a spell that is not on cooldown it will be cast immediately and clear the appropriate cooldown queue.

For example, if Fire Blast is on cooldown and I queue it and then try to cast Fireball it will cast Fireball immediately and Fire Blast will not get automatically cast anymore.

This currently doesn't work for item cooldowns as they work differently, will add in the future.

NP_OptimizeBufferUsingPacketTimings
This feature will attempt to optimize your buffer on individual casts using your latency and server packet timings.
After you begin to cast a spell you will get a cast result packet back from the server letting you know if the cast was successful. The time between when you send your start cast packet and when you receive the cast result packet consists of:

The time it takes for your packet to reach the server
The time it takes for the server to process the packet (see Why do I need a buffer?)
The time it takes for the server to send the result packet back to you
Other delays I'm not sure about like the time it takes for the client to process packets from the server due to being single threaded
If we take this 'Spell Response Time' and subtract your regular latency from it, we should be able to get a rough idea of the time it took for the server to process the cast. If that time was less than your current default buffer we can use that time as the new buffer for the next cast only. In theory if it is more than your current buffer we should also use it, but in practice it seems to regularly be way larger than expected and using the default buffer doesn't result in an error.

Due to this delay varying wildly in testing I'm unsure how reliable this technique is. It needs more testing and a better understanding of all the factors introducing delay. It is disabled by default for now.

v1.0.0 Changes
Now looks for a nampower.cfg file in the same directory with two lines:

The first line should contain the "buffer" time between each cast. This is the amount of time to delay casts to ensure you don't try to cast again too early due to server/packet lag and get rejected by the server with a "This ability isn't ready yet" error. For 150ms I found 30ms to be a reasonable buffer.
The second line is the window in ms before each cast during which nampower will delay cast attempts to send them to the server at the perfect time. So 300 would mean if you cast anytime in the 300ms window before your next optimal cast your cast will be sent at the idea time. This means you don't have to spam cast as aggressively. This feature will cause a small stutter because it is pausing your UI (I couldn't findSpellId a better way to do this but I'm sure one exists now with superwow) so if you don't like that set this to 0.
Namreeb readme
Please consider donating if you use this tool. - Namreeb

Donate

An auto stop-cast tool for World of Warcraft 1.12.1.5875 (for Windows)

There is a design flaw in this version of the client. A player is not allowed to cast a second spell until after the client receives word of the completion of the previous spell. This means that in addition to the cast time, you have to wait for the time it takes a message to arrive from the server. For many U.S. based players connected to E.U. based realms, this can result in approximately a 20% drop in effective DPS.

Consider the following timeline, assuming a latency of 200ms.

t = 0, the player begins casting fireball (assume a cast time of one second or 1000ms) and spell cast message is sent to the server. at this time, the client places a lock on itself, preventing the player from requesting another spell cast.
t = 200, the spell cast message arrives at the server, and the spell cast begins
t = 1200, the spell cast finishes and a finish message is sent to the client
t = 1400, the client receives the finish message and removes the lock it had placed 1400ms ago.
In this scenario, a 1000ms spell takes 1400ms to cast. This tool will work around that design flaw by altering the client behavior to not wait for the server to acknowledge anything.

Using
If you use my launcher, known as wowreeb, you can add the following line to a <Realm> block to tell the launcher to include this tool:

    <DLL Path="c:\path\to\nampower.dll" Method="Load" />
To launch with the built-in launcher, run loader.exe -p c:\path\to\wow.exe (or just loader.exe with it inside the main wow folder)
--[[
	Author: Dennis Werner Garske (DWG) / brian / Mewtiny
	License: MIT License
]]
local _G = _G or getfenv(0)
local CleveRoids = _G.CleveRoids or {}

-- Permanent cache for name normalization (underscores to spaces)
local _normalizedNames = {}

-- PERFORMANCE: Cache for lowercased normalized names (for case-insensitive comparisons)
local _lowerNormalizedNames = {}

-- Cached name normalization
function CleveRoids.NormalizeName(name)
    if not name then return name end
    local c = _normalizedNames[name]
    if c then return c end
    c = string.gsub(name, "_", " ")
    _normalizedNames[name] = c
    return c
end

-- PERFORMANCE: Cached lowercase normalization (underscores to spaces + lowercase)
local function GetLowerNormalizedName(name)
    if not name then return name end
    local c = _lowerNormalizedNames[name]
    if c then return c end
    c = string.lower(string.gsub(name, "_", " "))
    _lowerNormalizedNames[name] = c
    return c
end

-- PERFORMANCE: Cache for lowercased strings
local _lowercaseCache = {}
local function GetLowercaseString(str)
    if not str then return str end
    local c = _lowercaseCache[str]
    if c then return c end
    c = string.lower(str)
    _lowercaseCache[str] = c
    return c
end

-- Direct passthrough functions (no caching overhead for normal usage)
function CleveRoids.GetCachedTime()
    return GetTime()
end

function CleveRoids.GetCachedPlayerHealthPercent()
    local max = UnitHealthMax("player")
    return max > 0 and (100 * UnitHealth("player") / max) or 0
end

function CleveRoids.GetCachedPlayerPowerPercent()
    local max = UnitManaMax("player")
    return max > 0 and (100 * UnitMana("player") / max) or 0
end

function CleveRoids.GetCachedPlayerPower()
    return UnitMana("player")
end

function CleveRoids.GetCachedTargetHealthPercent()
    if not UnitExists("target") then return 0 end
    local max = UnitHealthMax("target")
    return max > 0 and (100 * UnitHealth("target") / max) or 0
end

-- Cooldown uses original function directly
function CleveRoids.GetCachedCooldown(name, ignoreGCD)
    return CleveRoids._GetCooldownUncached(name, ignoreGCD)
end

-- No-ops for compatibility
function CleveRoids.ClearFrameCache() end
function CleveRoids.TrackButtonPress() end
function CleveRoids.GetCacheStats() return nil end
function CleveRoids.SetCacheTTL(ms) end
function CleveRoids.SetMacroThrottle(ms) end
function CleveRoids.GetMacroThrottle() return 0 end

-- ============================================================================
-- PERFORMANCE: Cache spell name -> spell ID mappings for debuff lookups
-- This avoids iterating personalDebuffs/sharedDebuffs and calling SpellInfo() repeatedly
local _spellNameToIDs = {}  -- [spellName] = { spellID1, spellID2, ... }
local _spellNameToIDsBuilt = false

-- Build the spell name to ID cache (called once on first debuff check)
local function BuildSpellNameCache()
    if _spellNameToIDsBuilt then return end
    _spellNameToIDsBuilt = true

    local lib = CleveRoids.libdebuff
    if not lib then return end

    local gsub = string.gsub

    if lib.personalDebuffs then
        for sid, _ in pairs(lib.personalDebuffs) do
            local name = SpellInfo(sid)
            if name then
                name = gsub(name, "%s*%(%s*Rank%s+%d+%s*%)", "")
                if not _spellNameToIDs[name] then
                    _spellNameToIDs[name] = {}
                end
                table.insert(_spellNameToIDs[name], sid)
            end
        end
    end

    if lib.sharedDebuffs then
        for sid, _ in pairs(lib.sharedDebuffs) do
            local name = SpellInfo(sid)
            if name then
                name = gsub(name, "%s*%(%s*Rank%s+%d+%s*%)", "")
                if not _spellNameToIDs[name] then
                    _spellNameToIDs[name] = {}
                end
                -- Avoid duplicates
                local found = false
                for _, existingId in ipairs(_spellNameToIDs[name]) do
                    if existingId == sid then found = true; break end
                end
                if not found then
                    table.insert(_spellNameToIDs[name], sid)
                end
            end
        end
    end
end

-- Get cached spell IDs for a spell name
local function GetSpellIDsForName(spellName)
    BuildSpellNameCache()
    -- Strip rank from input spell name to match cache keys
    -- This handles cases like "Faerie Fire (Feral)(Rank 4)" -> "Faerie Fire (Feral)"
    if spellName then
        spellName = string.gsub(spellName, "%s*%(%s*Rank%s+%d+%s*%)", "")
    end
    return _spellNameToIDs[spellName]
end

-- Invalidate cache (call if debuff lists change)
function CleveRoids.InvalidateSpellNameCache()
    _spellNameToIDs = {}
    _spellNameToIDsBuilt = false
end

-- PERFORMANCE: Equipment cache for HasGearEquipped (avoids 19-slot scan per call)
-- Invalidated on UNIT_INVENTORY_CHANGED via CleveRoids.InvalidateEquipmentCache()
-- Enhanced with Nampower v2.18+ GetEquippedItems when available
local _equippedItemIDs = {}      -- [slot] = itemID (number)
local _equippedItemNames = {}    -- [slot] = itemName (lowercase string)
local _equipmentCacheValid = false

-- Track if we've warned about GetEquippedItems errors (warn once per session)
local _getEquippedItemsErrorWarned = false

local function BuildEquipmentCache()
    if _equipmentCacheValid then return end
    _equipmentCacheValid = true

    -- Clear old data
    for i = 1, 19 do
        _equippedItemIDs[i] = nil
        _equippedItemNames[i] = nil
    end

    local string_find = string.find
    local string_lower = string.lower

    -- Try Nampower GetEquippedItems for faster enumeration
    -- Requires v2.22+ because earlier versions (e.g., v2.19.1) have internal bug
    local API = CleveRoids.NampowerAPI
    local hasValidNampower = API and API.HasMinimumVersion and API.HasMinimumVersion(2, 22, 0)

    if hasValidNampower and GetEquippedItems then
        -- Use pcall to catch any internal Nampower errors and fall back gracefully
        local success, result = pcall(GetEquippedItems, "player")

        if not success then
            -- Log the error once per session for debugging
            if not _getEquippedItemsErrorWarned then
                _getEquippedItemsErrorWarned = true
                local errMsg = tostring(result)
                if CleveRoids.Print then
                    CleveRoids.Print("|cffff6600Warning:|r GetEquippedItems failed: " .. errMsg)
                    CleveRoids.Print("Using fallback equipment detection. Consider updating Nampower.")
                end
            end
            -- Fall through to manual enumeration
        elseif result and type(result) == "table" then
            local usedNampower = false
            for nampowerSlot, itemInfo in pairs(result) do
                -- Nampower uses 0-indexed slots, WoW API uses 1-indexed
                -- tonumber() handles both string and numeric keys from different Nampower versions
                -- Skip non-numeric keys (metadata fields, etc.)
                local slotNum = tonumber(nampowerSlot)
                if slotNum and type(itemInfo) == "table" and itemInfo.itemId then
                    local slot = slotNum + 1
                    -- itemInfo must be a table to access .itemId (userdata from some Nampower versions is not indexable)
                    if slot >= 1 and slot <= 19 then
                        _equippedItemIDs[slot] = itemInfo.itemId
                        usedNampower = true

                        -- Get item name via Nampower API or GetItemInfo
                        local itemName = API and API.GetItemName and API.GetItemName(itemInfo.itemId)
                        if not itemName then
                            itemName = GetItemInfo(itemInfo.itemId)
                        end
                        if itemName then
                            _equippedItemNames[slot] = string_lower(itemName)
                        end
                    end
                end
            end
            if usedNampower then
                return  -- Done with Nampower path
            end
            -- Fall through to manual enumeration if Nampower returned userdata items
        end
    end

    -- Fallback: manual slot enumeration
    for slot = 1, 19 do
        local link = GetInventoryItemLink("player", slot)
        if link then
            local _, _, id = string_find(link, "item:(%d+)")
            local _, _, nameInBrackets = string_find(link, "%[(.+)%]")

            if id then
                _equippedItemIDs[slot] = tonumber(id)
            end
            if nameInBrackets then
                _equippedItemNames[slot] = string_lower(nameInBrackets)
            elseif id then
                -- Fallback: resolve via GetItemInfo
                local itemName = GetItemInfo(tonumber(id))
                if itemName then
                    _equippedItemNames[slot] = string_lower(itemName)
                end
            end
        end
    end
end

-- Invalidate equipment cache (call on UNIT_INVENTORY_CHANGED)
function CleveRoids.InvalidateEquipmentCache()
    _equipmentCacheValid = false
end

-- ============================================================================
-- PERFORMANCE: Unified item location lookup using CleveRoids.Items cache
-- Returns: { type="inventory"|"bag", inventoryID=N } or { type="bag", bag=N, slot=N }
-- Returns nil if item not found
-- Enhanced with Nampower v2.18+ FindPlayerItemSlot when available
-- ============================================================================
local string_lower = string.lower
local string_find = string.find

-- Fast item lookup using cache - O(1) instead of O(n) scan
-- @param item: item ID (number) or item name (string)
-- @return table with location info, or nil if not found
function CleveRoids.FindItemLocation(item)
    -- Try Nampower v2.18+ native lookup first (much faster for item ID/name)
    if FindPlayerItemSlot and item then
        local numericItem = tonumber(item)

        -- Skip native lookup for equipment slot numbers (1-19)
        if not (numericItem and numericItem >= 1 and numericItem <= 19) then
            local bag, slot = FindPlayerItemSlot(item)

            if slot then
                if bag == nil then
                    -- Equipped item - Nampower returns 1-indexed slot
                    return { type = "inventory", inventoryID = slot }
                else
                    -- Bag item
                    return { type = "bag", bag = bag, slot = slot }
                end
            end
            -- If Nampower lookup failed, fall through to cache lookup
            -- (might find via substring match or cached alias)
        end
    end

    -- Fallback to CleveRoids.Items cache
    local Items = CleveRoids.Items
    if not Items then return nil end

    local itemData = nil

    -- Case 1: Numeric item ID
    local numericItem = tonumber(item)
    if numericItem then
        -- Check if it's an equipment slot (1-19)
        if numericItem >= 1 and numericItem <= 19 then
            local link = GetInventoryItemLink("player", numericItem)
            if link then
                return { type = "inventory", inventoryID = numericItem }
            end
            return nil
        end

        -- Look up by item ID in cache (Items[id] = name)
        local itemName = Items[numericItem]
        if itemName then
            itemData = Items[itemName]
        end
    else
        -- Case 2: String item name
        if type(item) == "string" and item ~= "" then
            -- Try exact match first, then lowercase
            itemData = Items[item]
            if not itemData or type(itemData) == "string" then
                local lowerItem = string_lower(item)
                local resolved = Items[lowerItem]
                if type(resolved) == "string" then
                    itemData = Items[resolved]
                elseif type(resolved) == "table" then
                    itemData = resolved
                end
            elseif type(itemData) == "string" then
                -- Resolve indirection (lowercase -> canonical name)
                itemData = Items[itemData]
            end
        end
    end

    if not itemData or type(itemData) ~= "table" then
        return nil
    end

    -- Return location info
    if itemData.inventoryID then
        return { type = "inventory", inventoryID = itemData.inventoryID, itemData = itemData }
    elseif itemData.bagID and itemData.slot then
        return { type = "bag", bag = itemData.bagID, slot = itemData.slot, itemData = itemData }
    end

    return nil
end

-- Fast item existence check using cache
-- @param item: item ID (number) or item name (string)
-- @return boolean
function CleveRoids.HasItemCached(item)
    return CleveRoids.FindItemLocation(item) ~= nil
end

-- Fast item cooldown lookup using cache
-- Enhanced with Nampower v2.18+ GetItemIdCooldown for detailed info
-- @param item: item ID (number) or item name (string)
-- @return remainingSeconds, totalDuration, enabled
function CleveRoids.GetItemCooldownCached(item)
    local location = CleveRoids.FindItemLocation(item)
    if not location then
        return 0, 0, 0
    end

    -- Try Nampower v2.18+ GetItemIdCooldown for more detailed info
    -- This requires knowing the item ID
    if GetItemIdCooldown then
        local itemId = nil

        -- Get item ID from location or input
        if location.itemData and location.itemData.id then
            itemId = location.itemData.id
        elseif type(item) == "number" and item > 19 then
            itemId = item
        else
            -- Extract item ID from inventory/bag link
            local link
            if location.type == "inventory" then
                link = GetInventoryItemLink("player", location.inventoryID)
            else
                link = GetContainerItemLink(location.bag, location.slot)
            end
            if link then
                local _, _, id = string.find(link, "item:(%d+)")
                if id then itemId = tonumber(id) end
            end
        end

        if itemId then
            local cdInfo = GetItemIdCooldown(itemId)
            if cdInfo then
                local remaining = (cdInfo.cooldownRemainingMs or 0) / 1000
                local duration = (cdInfo.individualDurationMs or cdInfo.categoryDurationMs or 0) / 1000
                local enabled = (cdInfo.isOnCooldown == 1) and 1 or 0
                return remaining, duration, enabled
            end
        end
    end

    -- Fallback to standard WoW API
    local start, duration, enable
    if location.type == "inventory" then
        start, duration, enable = GetInventoryItemCooldown("player", location.inventoryID)
    else
        start, duration, enable = GetContainerItemCooldown(location.bag, location.slot)
    end

    -- Normalize cooldown values
    start = tonumber(start) or 0
    duration = tonumber(duration) or 0
    enable = tonumber(enable) or 0

    if duration <= 0 or start <= 0 then
        return 0, 0, enable
    end

    local remaining = (start + duration) - GetTime()
    if remaining < 0 then remaining = 0 end

    return remaining, duration, enable
end

--This table maps stat keys to the functions that retrieve their values.
local stat_checks = {
    -- Base Stats (Corrected to use the 'effective' stat with gear)
    str = function() local _, effective = UnitStat("player", 1); return effective end,
    strength = function() local _, effective = UnitStat("player", 1); return effective end,
    agi = function() local _, effective = UnitStat("player", 2); return effective end,
    agility = function() local _, effective = UnitStat("player", 2); return effective end,
    stam = function() local _, effective = UnitStat("player", 3); return effective end,
    stamina = function() local _, effective = UnitStat("player", 3); return effective end,
    int = function() local _, effective = UnitStat("player", 4); return effective end,
    intellect = function() local _, effective = UnitStat("player", 4); return effective end,
    spi = function() local _, effective = UnitStat("player", 5); return effective end,
    spirit = function() local _, effective = UnitStat("player", 5); return effective end,

    -- Combat Ratings (Corrected to use UnitAttackPower and UnitRangedAttackPower)
    ap = function() local base, pos, neg = UnitAttackPower("player"); return base + pos + neg end,
    attackpower = function() local base, pos, neg = UnitAttackPower("player"); return base + pos + neg end,
    rap = function() local base, pos, neg = UnitRangedAttackPower("player"); return base + pos + neg end,
    rangedattackpower = function() local base, pos, neg = UnitRangedAttackPower("player"); return base + pos + neg end,
    healing = function() return GetBonusHealing() end,
    healingpower = function() return GetBonusHealing() end,

    -- Bonus Spell Damage by School
    arcane_power = function() return GetSpellBonusDamage(6) end,
    fire_power = function() return GetSpellBonusDamage(3) end,
    frost_power = function() return GetSpellBonusDamage(4) end,
    nature_power = function() return GetSpellBonusDamage(2) end,
    shadow_power = function() return GetSpellBonusDamage(5) end,

    -- Defensive Stats
    armor = function() local _, effective = UnitArmor("player"); return effective end,
    defense = function()
        local base, modifier = UnitDefense("player")
        return (base or 0) + (modifier or 0)
    end,

    -- Resistances
    arcane_res = function() local _, val = UnitResistance("player", 7); return val end,
    fire_res = function() local _, val = UnitResistance("player", 3); return val end,
    frost_res = function() local _, val = UnitResistance("player", 5); return val end,
    nature_res = function() local _, val = UnitResistance("player", 4); return val end,
    shadow_res = function() local _, val = UnitResistance("player", 6); return val end
}

-- ============================================================================
-- PERFORMANCE: Specialized comparison functions to avoid closure allocation
-- These functions replace common patterns like:
--   return Or(t, function(v) return (i == tonumber(v)) end)
-- with:
--   return OrEqualsNumber(t, i)
-- ============================================================================

-- Or where any value equals target number (after tonumber conversion)
local function OrEqualsNumber(t, target)
    if type(t) ~= "table" then
        return tonumber(t) == target
    end
    local k, v = next(t)
    while k do
        if tonumber(v) == target then return true end
        k, v = next(t, k)
    end
    return false
end

-- Or where any value equals target string (after string.lower conversion)
local function OrEqualsStringLower(t, target)
    if type(t) ~= "table" then
        return string.lower(t) == target
    end
    local k, v = next(t)
    while k do
        if string.lower(v) == target then return true end
        k, v = next(t, k)
    end
    return false
end

-- Or where any value does NOT equal target number (for negated conditionals)
local function OrNotEqualsNumber(t, target)
    if type(t) ~= "table" then
        return tonumber(t) ~= target
    end
    local k, v = next(t)
    while k do
        if tonumber(v) ~= target then return true end
        k, v = next(t, k)
    end
    return false
end

-- And where ALL values do NOT equal target number (for negated conditionals with AND logic)
local function AndNotEqualsNumber(t, target)
    if type(t) ~= "table" then
        return tonumber(t) ~= target
    end
    local k, v = next(t)
    while k do
        if tonumber(v) == target then return false end
        k, v = next(t, k)
    end
    return true
end

-- PERFORMANCE: Avoid creating wrapper tables for single values
local function And(t, func)
    if type(func) ~= "function" then return false end
    -- PERFORMANCE: Handle non-table case without allocation
    if type(t) ~= "table" then
        return func(t) and true or false
    end
    for k, v in pairs(t) do
        if not func(v) then
            return false
        end
    end
    return true
end

local function Or(t, func)
    if type(func) ~= "function" then return false end
    -- PERFORMANCE: Handle non-table case without allocation
    if type(t) ~= "table" then
        return func(t) and true or false
    end
    for k, v in pairs(t) do
        if func(v) then
            return true
        end
    end
    return false
end

-- Helper to choose And() or Or() based on operator metadata
-- For positive conditionals (hp, power, cooldown, etc.):
--   - OR separator (/) uses Or() logic -> ANY value can match
--   - AND separator (&) uses And() logic -> ALL values must match
local function Multi(t, func, conditionals, condition)
    if type(func) ~= "function" then return false end

    -- PERFORMANCE: Handle non-table case without allocation
    if type(t) ~= "table" then
        return func(t) and true or false
    end

    -- Check for grouped structure (multiple instances of same conditional)
    -- Groups are AND'd together, values within each group use group's operator
    if conditionals and conditionals._groups and conditionals._groups[condition] then
        local groups = conditionals._groups[condition]
        -- All groups must pass (AND between groups)
        for _, group in ipairs(groups) do
            local groupPassed = false
            local groupOp = group.operator or "OR"

            if groupOp == "AND" then
                -- AND within group: ALL values must match
                groupPassed = true
                for _, v in ipairs(group.values) do
                    if not func(v) then
                        groupPassed = false
                        break
                    end
                end
            else
                -- OR within group: ANY value can match
                for _, v in ipairs(group.values) do
                    if func(v) then
                        groupPassed = true
                        break
                    end
                end
            end

            -- If any group fails, the whole conditional fails (AND between groups)
            if not groupPassed then return false end
        end
        return true
    end

    -- Fallback: Check operator type from metadata (single group / backwards compat)
    local operatorType = "OR" -- default
    if conditionals and conditionals._operators and conditionals._operators[condition] then
        operatorType = conditionals._operators[condition]
    end

    if operatorType == "AND" then
        -- AND separator (&): ALL must match
        for k, v in pairs(t) do
            if not func(v) then return false end
        end
        return true
    else
        -- OR separator (/) [default]: ANY can match
        for k, v in pairs(t) do
            if func(v) then return true end
        end
        return false
    end
end

-- Helper to choose And() or Or() based on operator metadata
-- For negated conditionals (nomybuff, nozone, etc.), operators are FLIPPED (De Morgan's law):
--   - OR separator (/) [default]: ALL must be missing (e.g., nobuff:X/Y = no X AND no Y)
--   - AND separator (&): ANY can be missing (e.g., nobuff:X&Y = no X OR no Y)
-- This matches natural language: "no X or Y" intuitively means "neither X nor Y"
local function NegatedMulti(t, func, conditionals, condition)
    if type(func) ~= "function" then return false end

    -- PERFORMANCE: Handle non-table case without allocation
    if type(t) ~= "table" then
        return func(t) and true or false
    end

    -- Check for grouped structure (multiple instances of same conditional)
    -- Groups are AND'd together, values within each group use FLIPPED group operator (De Morgan)
    if conditionals and conditionals._groups and conditionals._groups[condition] then
        local groups = conditionals._groups[condition]
        -- All groups must pass (AND between groups)
        for _, group in ipairs(groups) do
            local groupPassed = false
            local groupOp = group.operator or "OR"

            -- FLIPPED from positive conditionals (De Morgan's law for intuitive behavior)
            if groupOp == "AND" then
                -- AND separator (&) FLIPPED: ANY negation can pass (missing at least one)
                for _, v in ipairs(group.values) do
                    if func(v) then
                        groupPassed = true
                        break
                    end
                end
            else
                -- OR separator (/) FLIPPED: ALL negations must pass (missing all)
                groupPassed = true
                for _, v in ipairs(group.values) do
                    if not func(v) then
                        groupPassed = false
                        break
                    end
                end
            end

            -- If any group fails, the whole conditional fails (AND between groups)
            if not groupPassed then return false end
        end
        return true
    end

    -- Fallback: Check operator type from metadata (single group / backwards compat)
    local operatorType = "OR" -- default
    if conditionals and conditionals._operators and conditionals._operators[condition] then
        operatorType = conditionals._operators[condition]
    end

    -- FLIPPED from positive conditionals (De Morgan's law for intuitive behavior)
    if operatorType == "AND" then
        -- AND separator (&): ANY negation can pass (missing at least one)
        for k, v in pairs(t) do
            if func(v) then return true end
        end
        return false
    else
        -- OR separator (/) [default]: ALL negations must pass (missing all)
        for k, v in pairs(t) do
            if not func(v) then return false end
        end
        return true
    end
end

-- ============================================================================
-- THREAT TRACKING (reads server data via CHAT_MSG_ADDON like TWThreat)
-- ============================================================================

-- Storage for threat data
CleveRoids.ThreatData = {
    playerName = UnitName("player"),
    threats = {},      -- [playerName] = { threat, perc, tank, melee }
    lastUpdate = 0,
}

-- Parse threat packet from server (same format as TWThreat)
-- Format: TWTv4=player1:tank:threat:perc:melee;player2:tank:threat:perc:melee;...
local function ParseThreatPacket(packet)
    local threatApi = "TWTv4="
    local startPos = string.find(packet, threatApi, 1, true)
    if not startPos then return end

    local playersString = string.sub(packet, startPos + string.len(threatApi))
    local playerName = CleveRoids.ThreatData.playerName

    -- Clear old data
    CleveRoids.ThreatData.threats = {}
    CleveRoids.ThreatData.lastUpdate = GetTime()

    -- Split by semicolon
    for playerData in string.gfind(playersString, "[^;]+") do
        -- Split by colon: player:tank:threat:perc:melee
        local parts = {}
        for part in string.gfind(playerData, "[^:]+") do
            table.insert(parts, part)
        end

        if parts[1] and parts[2] and parts[3] and parts[4] and parts[5] then
            local name = parts[1]
            local tank = parts[2] == "1"
            local threat = tonumber(parts[3]) or 0
            local perc = tonumber(parts[4]) or 0
            local melee = parts[5] == "1"

            CleveRoids.ThreatData.threats[name] = {
                threat = threat,
                perc = perc,
                tank = tank,
                melee = melee,
            }
        end
    end
end

-- Get player's threat percentage
function CleveRoids.GetPlayerThreatPercent()
    local playerName = CleveRoids.ThreatData.playerName
    local data = CleveRoids.ThreatData.threats[playerName]
    if data then
        return data.perc
    end
    return nil
end

-- Create frame to listen for threat addon messages
local threatFrame = CreateFrame("Frame", "CleveRoidsThreatFrame")
threatFrame:RegisterEvent("CHAT_MSG_ADDON")
threatFrame:SetScript("OnEvent", function()
    if event == "CHAT_MSG_ADDON" then
        -- arg1 = prefix, arg2 = message, arg3 = channel, arg4 = sender
        if arg2 and string.find(arg2, "TWTv4=", 1, true) then
            ParseThreatPacket(arg2)
        end
    end
end)

-- ============================================================================
-- AUTO-ATTACK EVENT TRACKING (Nampower v2.24+)
-- ============================================================================
-- Tracks player's melee swings and incoming attacks for conditionals:
--   [lastswing:crit/glancing/miss/dodge/parry/blocked/offhand]
--   [incominghit:crit/crushing/dodge/parry/blocked]
--   [buffcapped] / [debuffcapped]
-- Requires NP_EnableAutoAttackEvents=1 and NP_EnableAuraCastEvents=1 CVars

-- State tracking for player's outgoing melee swings
CleveRoids.LastSwing = {
    timestamp = 0,      -- GetTime() when swing occurred
    damage = 0,         -- Total damage dealt
    hitInfo = 0,        -- HitInfo bitfield
    victimState = 0,    -- VictimState enum
    blockedAmount = 0,  -- Amount blocked
    absorbAmount = 0,   -- Amount absorbed
    resistAmount = 0,   -- Amount resisted
    targetGuid = nil,   -- GUID of target hit
}

-- State tracking for incoming attacks on player
CleveRoids.LastIncomingHit = {
    timestamp = 0,
    damage = 0,
    hitInfo = 0,
    victimState = 0,
    blockedAmount = 0,
    absorbAmount = 0,
    resistAmount = 0,
    attackerGuid = nil,
}

-- Aura cap status tracking (from AURA_CAST events)
-- For player: 32 buff slots, 16 debuff slots
-- For enemy NPCs: 16 debuff slots + 32 overflow into buff slots = 48 total visual
CleveRoids.AuraCapStatus = {
    -- Player aura cap status
    playerBuffCapped = false,
    playerDebuffCapped = false,
    playerLastUpdate = 0,
    -- Target aura cap status (tracked per-GUID)
    targetCapStatus = {},  -- [guid] = { buffCapped, debuffCapped, timestamp }
}

-- HitInfo bitfield values (from NampowerAPI.lua, duplicated for local access)
-- Converted to decimal for Lua 5.0 compatibility (no hex literals)
local HITINFO_MISS = 16          -- 0x10
local HITINFO_CRITICALHIT = 128  -- 0x80
local HITINFO_GLANCING = 16384   -- 0x4000
local HITINFO_CRUSHING = 32768   -- 0x8000
local HITINFO_LEFTSWING = 4      -- 0x4 (Off-hand attack)

-- VictimState values
local VICTIMSTATE_DODGE = 2
local VICTIMSTATE_PARRY = 3
local VICTIMSTATE_BLOCKS = 5

-- Aura cap status bitfield
local AURA_CAP_BUFF_FULL = 1
local AURA_CAP_DEBUFF_FULL = 2

-- Helper: Check if a HitInfo bitfield contains a specific flag
local function HasHitFlag(hitInfo, flag)
    if not hitInfo or not flag then return false end
    if bit and bit.band then
        return bit.band(hitInfo, flag) ~= 0
    end
    -- Fallback for environments without bit library
    return false
end

-- Process AUTO_ATTACK_OTHER event (player attacking something, or other units)
local function OnAutoAttackOther(attackerGuid, targetGuid, totalDamage, hitInfo, victimState,
                                  subDamageCount, blockedAmount, totalAbsorb, totalResist)
    -- Check if player is the attacker
    local _, playerGuid = UnitExists("player")
    if not playerGuid or attackerGuid ~= playerGuid then
        return  -- Not player's attack, ignore
    end

    CleveRoids.LastSwing.timestamp = GetTime()
    CleveRoids.LastSwing.damage = totalDamage or 0
    CleveRoids.LastSwing.hitInfo = hitInfo or 0
    CleveRoids.LastSwing.victimState = victimState or 0
    CleveRoids.LastSwing.blockedAmount = blockedAmount or 0
    CleveRoids.LastSwing.absorbAmount = totalAbsorb or 0
    CleveRoids.LastSwing.resistAmount = totalResist or 0
    CleveRoids.LastSwing.targetGuid = targetGuid
end

-- Process AUTO_ATTACK_SELF event (player being attacked)
local function OnAutoAttackSelf(attackerGuid, targetGuid, totalDamage, hitInfo, victimState,
                                 subDamageCount, blockedAmount, totalAbsorb, totalResist)
    CleveRoids.LastIncomingHit.timestamp = GetTime()
    CleveRoids.LastIncomingHit.damage = totalDamage or 0
    CleveRoids.LastIncomingHit.hitInfo = hitInfo or 0
    CleveRoids.LastIncomingHit.victimState = victimState or 0
    CleveRoids.LastIncomingHit.blockedAmount = blockedAmount or 0
    CleveRoids.LastIncomingHit.absorbAmount = totalAbsorb or 0
    CleveRoids.LastIncomingHit.resistAmount = totalResist or 0
    CleveRoids.LastIncomingHit.attackerGuid = attackerGuid
end

-- Process AURA_CAST events for cap status tracking
-- Parameters: spellId, casterGuid, targetGuid, effect, effectAuraName,
--             effectAmplitude, effectMiscValue, durationMs, auraCapStatus
local function OnAuraCastSelf(spellId, casterGuid, targetGuid, effect, effectAuraName,
                               effectAmplitude, effectMiscValue, durationMs, auraCapStatus)
    if not auraCapStatus then return end

    local now = GetTime()
    CleveRoids.AuraCapStatus.playerLastUpdate = now

    -- Check buff bar full (bit 1)
    CleveRoids.AuraCapStatus.playerBuffCapped = HasHitFlag(auraCapStatus, AURA_CAP_BUFF_FULL)
    -- Check debuff bar full (bit 2)
    CleveRoids.AuraCapStatus.playerDebuffCapped = HasHitFlag(auraCapStatus, AURA_CAP_DEBUFF_FULL)
end

local function OnAuraCastOther(spellId, casterGuid, targetGuid, effect, effectAuraName,
                                effectAmplitude, effectMiscValue, durationMs, auraCapStatus)
    if not auraCapStatus or not targetGuid then return end

    local now = GetTime()

    -- Store cap status for this target GUID
    CleveRoids.AuraCapStatus.targetCapStatus[targetGuid] = {
        buffCapped = HasHitFlag(auraCapStatus, AURA_CAP_BUFF_FULL),
        debuffCapped = HasHitFlag(auraCapStatus, AURA_CAP_DEBUFF_FULL),
        timestamp = now,
    }

    -- Cleanup old entries (older than 60 seconds) to prevent memory leak
    -- Only clean up every 100 entries to avoid performance impact
    local count = 0
    for guid, data in pairs(CleveRoids.AuraCapStatus.targetCapStatus) do
        count = count + 1
        if now - data.timestamp > 60 then
            CleveRoids.AuraCapStatus.targetCapStatus[guid] = nil
        end
    end
end

-- Create frame to listen for Nampower auto-attack and aura events
local autoAttackFrame = CreateFrame("Frame", "CleveRoidsAutoAttackFrame")

-- Register for events on PLAYER_ENTERING_WORLD (after CVars are applied)
autoAttackFrame:RegisterEvent("PLAYER_ENTERING_WORLD")
autoAttackFrame:SetScript("OnEvent", function()
    if event == "PLAYER_ENTERING_WORLD" then
        -- Check if Nampower v2.24+ is available for auto-attack events
        local API = CleveRoids.NampowerAPI
        if API and API.features and API.features.hasAutoAttackEvents then
            -- Register for auto-attack events (requires NP_EnableAutoAttackEvents=1)
            this:RegisterEvent("AUTO_ATTACK_OTHER")
            this:RegisterEvent("AUTO_ATTACK_SELF")
        end

        -- Check for aura cast events (v2.20+, requires NP_EnableAuraCastEvents=1)
        if API and API.features and API.features.hasAuraCastEvents then
            this:RegisterEvent("AURA_CAST_ON_SELF")
            this:RegisterEvent("AURA_CAST_ON_OTHER")
        end

    elseif event == "AUTO_ATTACK_OTHER" then
        -- arg1=attackerGuid, arg2=targetGuid, arg3=totalDamage, arg4=hitInfo, arg5=victimState,
        -- arg6=subDamageCount, arg7=blockedAmount, arg8=totalAbsorb, arg9=totalResist
        OnAutoAttackOther(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)

    elseif event == "AUTO_ATTACK_SELF" then
        OnAutoAttackSelf(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)

    elseif event == "AURA_CAST_ON_SELF" then
        -- arg1=spellId, arg2=casterGuid, arg3=targetGuid, arg4=effect, arg5=effectAuraName,
        -- arg6=effectAmplitude, arg7=effectMiscValue, arg8=durationMs, arg9=auraCapStatus
        OnAuraCastSelf(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)

    elseif event == "AURA_CAST_ON_OTHER" then
        OnAuraCastOther(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)
    end
end)

-- ============================================================================
-- VALIDATION FUNCTIONS FOR AUTO-ATTACK CONDITIONALS
-- ============================================================================

-- Validate lastswing conditional
-- swingType: "crit", "glancing", "miss", "dodge", "parry", "blocked", "offhand", or time comparison
function CleveRoids.ValidateLastSwing(swingType, operator, amount)
    local swing = CleveRoids.LastSwing
    if swing.timestamp == 0 then
        return false  -- No swing recorded yet
    end

    local swingTypeLower = swingType and string.lower(swingType)

    -- Time-based check (e.g., [lastswing:<2] = within last 2 seconds)
    if operator and amount then
        local elapsed = GetTime() - swing.timestamp
        if CleveRoids.operators[operator] then
            return CleveRoids.comparators[operator](elapsed, amount)
        end
        return false
    end

    -- Type-based checks
    if swingTypeLower == "crit" or swingTypeLower == "critical" then
        return HasHitFlag(swing.hitInfo, HITINFO_CRITICALHIT)
    elseif swingTypeLower == "glancing" then
        return HasHitFlag(swing.hitInfo, HITINFO_GLANCING)
    elseif swingTypeLower == "miss" then
        return HasHitFlag(swing.hitInfo, HITINFO_MISS)
    elseif swingTypeLower == "dodge" or swingTypeLower == "dodged" then
        return swing.victimState == VICTIMSTATE_DODGE
    elseif swingTypeLower == "parry" or swingTypeLower == "parried" then
        return swing.victimState == VICTIMSTATE_PARRY
    elseif swingTypeLower == "blocked" or swingTypeLower == "block" then
        return swing.victimState == VICTIMSTATE_BLOCKS or swing.blockedAmount > 0
    elseif swingTypeLower == "offhand" or swingTypeLower == "oh" then
        return HasHitFlag(swing.hitInfo, HITINFO_LEFTSWING)
    elseif swingTypeLower == "mainhand" or swingTypeLower == "mh" then
        return not HasHitFlag(swing.hitInfo, HITINFO_LEFTSWING)
    elseif swingTypeLower == "hit" then
        -- A successful hit (not miss, not dodged, not parried)
        return not HasHitFlag(swing.hitInfo, HITINFO_MISS) and
               swing.victimState ~= VICTIMSTATE_DODGE and
               swing.victimState ~= VICTIMSTATE_PARRY
    end

    -- Default: check if any swing was recorded recently (within 5 seconds)
    return (GetTime() - swing.timestamp) < 5
end

-- Validate incominghit conditional
function CleveRoids.ValidateIncomingHit(hitType, operator, amount)
    local hit = CleveRoids.LastIncomingHit
    if hit.timestamp == 0 then
        return false  -- No incoming hit recorded
    end

    local hitTypeLower = hitType and string.lower(hitType)

    -- Time-based check
    if operator and amount then
        local elapsed = GetTime() - hit.timestamp
        if CleveRoids.operators[operator] then
            return CleveRoids.comparators[operator](elapsed, amount)
        end
        return false
    end

    -- Type-based checks
    if hitTypeLower == "crit" or hitTypeLower == "critical" then
        return HasHitFlag(hit.hitInfo, HITINFO_CRITICALHIT)
    elseif hitTypeLower == "crushing" then
        return HasHitFlag(hit.hitInfo, HITINFO_CRUSHING)
    elseif hitTypeLower == "glancing" then
        return HasHitFlag(hit.hitInfo, HITINFO_GLANCING)
    elseif hitTypeLower == "miss" or hitTypeLower == "missed" then
        return HasHitFlag(hit.hitInfo, HITINFO_MISS)
    elseif hitTypeLower == "dodge" or hitTypeLower == "dodged" then
        return hit.victimState == VICTIMSTATE_DODGE
    elseif hitTypeLower == "parry" or hitTypeLower == "parried" then
        return hit.victimState == VICTIMSTATE_PARRY
    elseif hitTypeLower == "blocked" or hitTypeLower == "block" then
        return hit.victimState == VICTIMSTATE_BLOCKS or hit.blockedAmount > 0
    elseif hitTypeLower == "hit" then
        -- A successful incoming hit (not miss, not dodged, not parried by us)
        return not HasHitFlag(hit.hitInfo, HITINFO_MISS) and
               hit.victimState ~= VICTIMSTATE_DODGE and
               hit.victimState ~= VICTIMSTATE_PARRY
    end

    -- Default: check if any incoming hit was recorded recently
    return (GetTime() - hit.timestamp) < 5
end

-- Check if player's buff bar is capped (32 slots)
function CleveRoids.IsPlayerBuffCapped()
    -- First check from AURA_CAST events (most accurate)
    if CleveRoids.AuraCapStatus.playerLastUpdate > 0 then
        return CleveRoids.AuraCapStatus.playerBuffCapped
    end

    -- Fallback: count player buffs manually
    local count = 0
    for i = 0, 31 do
        if GetPlayerBuffTexture(GetPlayerBuff(i, "HELPFUL")) then
            count = count + 1
        end
    end
    return count >= 32
end

-- Check if player's debuff bar is capped (16 slots)
function CleveRoids.IsPlayerDebuffCapped()
    if CleveRoids.AuraCapStatus.playerLastUpdate > 0 then
        return CleveRoids.AuraCapStatus.playerDebuffCapped
    end

    -- Fallback: count player debuffs
    local count = 0
    for i = 0, 15 do
        if GetPlayerBuffTexture(GetPlayerBuff(i, "HARMFUL")) then
            count = count + 1
        end
    end
    return count >= 16
end

-- Check if target's debuff bar is capped
-- For NPCs: 16 debuff slots + 32 overflow = 48 total visual debuff capacity
function CleveRoids.IsTargetDebuffCapped(unit)
    unit = unit or "target"
    if not UnitExists(unit) then return false end

    -- Check cached AURA_CAST data by GUID
    local _, guid = UnitExists(unit)
    if guid then
        local capData = CleveRoids.AuraCapStatus.targetCapStatus[guid]
        if capData and (GetTime() - capData.timestamp) < 30 then
            return capData.debuffCapped
        end
    end

    -- Fallback: count debuffs on target manually
    -- For NPCs: check up to 48 slots (16 debuff + 32 overflow in buff slots)
    if not CleveRoids.hasSuperwow then
        -- Without SuperWoW, can only see 16 debuff slots
        local count = 0
        for i = 1, 16 do
            if UnitDebuff(unit, i) then
                count = count + 1
            else
                break
            end
        end
        return count >= 16
    end

    -- With SuperWoW: count all debuffs including overflow
    local debuffCount = 0

    -- Count regular debuff slots (1-16, dense)
    for i = 1, 16 do
        local texture, _, _, spellId = UnitDebuff(unit, i)
        if texture then
            debuffCount = debuffCount + 1
        else
            break  -- Dense, stop at first nil
        end
    end

    -- Count overflow debuffs in buff slots (sparse, check all 32)
    -- Overflow debuffs appear in buff slots but are filtered by UnitDebuff
    -- We need to use libdebuff or check buff slots for debuff-like effects
    -- For simplicity, consider 16 regular debuffs = capped for most use cases
    return debuffCount >= 16
end

-- Check if target's buff bar is capped (32 slots for NPCs)
function CleveRoids.IsTargetBuffCapped(unit)
    unit = unit or "target"
    if not UnitExists(unit) then return false end

    local _, guid = UnitExists(unit)
    if guid then
        local capData = CleveRoids.AuraCapStatus.targetCapStatus[guid]
        if capData and (GetTime() - capData.timestamp) < 30 then
            return capData.buffCapped
        end
    end

    -- Fallback: count buffs
    local count = 0
    for i = 1, 32 do
        if UnitBuff(unit, i) then
            count = count + 1
        else
            break
        end
    end
    return count >= 32
end

-- ============================================================================

-- pfUI debuff time helper (Vanilla 1.12.1 / Lua 5.0 safe)
local function PFUI_HasLibDebuff()
  return type(pfUI) == "table"
     and type(pfUI.api) == "table"
     and type(pfUI.api.libdebuff) == "table"
     and type(pfUI.api.libdebuff.UnitDebuff) == "function"
end

-- Helper: Get debuff time-left (seconds) from CleveRoids.libdebuff only
local function _get_debuff_timeleft(unitToken, auraName)
    -- Defensive: verify libdebuff is a table before accessing properties
    local lib = type(CleveRoids.libdebuff) == "table" and CleveRoids.libdebuff or nil

    -- Strip rank suffix for consistent matching (e.g., "Rake(Rank 4)" -> "Rake")
    if auraName then
        auraName = string.gsub(auraName, "%s*%(%s*Rank%s+%d+%s*%)", "")
    end

    -- SuperWoW path: GUID-based lookup
    -- SuperWoW debuff slots: 1-16 are regular debuffs, 17-48 overflow to buff slots 1-32
    if CleveRoids.hasSuperwow and lib then
        local _, guid = UnitExists(unitToken)
        if guid and lib.objects and lib.objects[guid] then
            -- Check 1-48: debuff slots 1-16 + overflow debuffs in buff slots 1-32
            -- NOTE: Slots 1-16 are dense (break on nil), slots 17-48 are sparse (continue on nil)
            -- Overflow debuffs in buff slots are mixed with regular buffs, so we can't break early
            for i = 1, 48 do
                local effect, _, _, _, _, duration, timeleft = lib:UnitDebuff(unitToken, i)
                -- Only break for slots 1-16 (regular debuffs are dense)
                -- For overflow slots 17-48, nil means "regular buff filtered out", not "end of list"
                if not effect and i <= 16 then break end
                -- Strip rank from effect name for comparison
                local effectBase = effect and string.gsub(effect, "%s*%(%s*Rank%s+%d+%s*%)", "")
                if effectBase and effectBase == auraName and timeleft and timeleft >= 0 then
                    return timeleft, duration
                end
            end
        end
    end

    -- Non-SuperWoW fallback
    if lib and lib.UnitDebuff then
        for idx = 1, 48 do
            local effect, _, _, _, _, duration, timeleft = lib:UnitDebuff(unitToken, idx)
            -- Only break for slots 1-16 (regular debuffs are dense)
            -- For overflow slots 17-48, nil means "regular buff filtered out", not "end of list"
            if not effect and idx <= 16 then break end
            -- Strip rank from effect name for comparison
            local effectBase = effect and string.gsub(effect, "%s*%(%s*Rank%s+%d+%s*%)", "")
            if effectBase and effectBase == auraName and timeleft and timeleft >= 0 then
                return timeleft, duration
            end
        end
    end

    return nil, nil
end

-- Validates that the given target is either friend (if [help]) or foe (if [harm])
-- target: The unit id to check
-- help: Optional. If set to 1 then the target must be friendly. If set to 0 it must be an enemy.
-- remarks: Will always return true if help is not given
-- returns: Whether or not the given target can either be attacked or supported, depending on help
function CleveRoids.CheckHelp(target, help)
    if help == nil then return true end
    if help then
        return UnitCanAssist("player", target)
    else
        return UnitCanAttack("player", target)
    end
end

-- Ensures the validity of the given target
-- target: The unit id to check
-- help: Optional. If set to 1 then the target must be friendly. If set to 0 it must be an enemy
-- returns: Whether or not the target is a viable target
function CleveRoids.IsValidTarget(target, help)
    -- If the conditional is not for @mouseover, use the existing logic.
    if target ~= "mouseover" then
        if not UnitExists(target) or not CleveRoids.CheckHelp(target, help) then
            return false
        end
        return true
    end

    -- --- START OF PATCH ---
    -- New logic to handle [@mouseover] with pfUI compatibility.

    local effectiveMouseoverUnit = "mouseover" -- Start with the default game token.

    -- Check if the default mouseover exists. If not, check pfUI's internal data,
    -- which is necessary because pfUI frames don't always update the default token.
    if not UnitExists(effectiveMouseoverUnit) then
        if pfUI and pfUI.uf and pfUI.uf.mouseover and pfUI.uf.mouseover.unit and UnitExists(pfUI.uf.mouseover.unit) then
            -- If pfUI has a valid mouseover unit recorded, use that instead.
            effectiveMouseoverUnit = pfUI.uf.mouseover.unit
        else
            -- If neither the default token nor the pfUI unit exists, there's no valid mouseover.
            return false
        end
    end
    -- --- END OF PATCH ---

    -- Finally, perform the help/harm check on the determined mouseover unit (either from the game or from pfUI).
    if not UnitExists(effectiveMouseoverUnit) or not CleveRoids.CheckHelp(effectiveMouseoverUnit, help) then
        return false
    end

    return true
end

-- Returns the current shapeshift / stance index
-- returns: The index of the current shapeshift form / stance. 0 if in no shapeshift form / stance
function CleveRoids.GetCurrentShapeshiftIndex()
    if CleveRoids.playerClass == "PRIEST" then
        return CleveRoids.ValidatePlayerBuff(CleveRoids.Localized.Spells["Shadowform"]) and 1 or 0
    elseif CleveRoids.playerClass == "ROGUE" then
        return CleveRoids.ValidatePlayerBuff(CleveRoids.Localized.Spells["Stealth"]) and 1 or 0
    end
    for i=1, GetNumShapeshiftForms() do
        _, _, active = GetShapeshiftFormInfo(i)
        if active then
            return i
        end
    end

    return 0
end

function CleveRoids.CancelAura(auraName)
	local ix = 0
    auraName = string.lower(string.gsub(auraName, "_"," "))
	while true do
		local aura_ix = GetPlayerBuff(ix,"HELPFUL")
		ix = ix + 1
		if aura_ix == -1 then break end

		if CleveRoids.hasSuperwow then
			local bid = GetPlayerBuffID(aura_ix)
			bid = (bid < -1) and (bid + 65536) or bid
			if string.lower(SpellInfo(bid)) == auraName then
				CancelPlayerBuff(aura_ix)
				return true
			end
		else
			AuraScanTooltip:SetPlayerBuff(aura_ix)
			local name = string.lower(getglobal("AuraScanTooltipTextLeft1"):GetText())
			if name == auraName then
				CancelPlayerBuff(aura_ix)
				break
			end
		end

	end
	return false
end

function CleveRoids.HasGearEquipped(gearId)
    if not gearId then return false end

    -- PERFORMANCE: Build/refresh equipment cache if needed
    BuildEquipmentCache()

    -- Handle both numeric IDs and string IDs like "5196"
    local wantId = tonumber(gearId)
    local wantName = (type(gearId) == "string" and not wantId) and string.lower(gearId) or nil

    -- PERFORMANCE: Use cached data instead of scanning all slots
    for slot = 1, 19 do
        if wantId and _equippedItemIDs[slot] == wantId then
            return true
        end
        if wantName and _equippedItemNames[slot] == wantName then
            return true
        end
    end
    return false
end


-- Checks whether or not the given weaponType is currently equipped
-- weaponType: The name of the weapon's type (e.g. Axe, Shield, etc.)
-- returns: True when equipped, otherwhise false
function CleveRoids.HasWeaponEquipped(weaponType)
    if not CleveRoids.WeaponTypeNames[weaponType] then
        return false
    end

    local slotName = CleveRoids.WeaponTypeNames[weaponType].slot
    local localizedName = CleveRoids.WeaponTypeNames[weaponType].name
    local slotId = GetInventorySlotInfo(slotName)
    local slotLink = GetInventoryItemLink("player",slotId)

    if not slotLink then
        return false
    end

    local _,_,itemId = string.find(slotLink,"item:(%d+)")
    if not itemId then -- Also good to check if itemId was found
        return false
    end
    local _name,_link,_,_lvl,_type,subtype = GetItemInfo(itemId)
    -- just had to be special huh?
    local fist = string.find(subtype,"^Fist")
    -- drops things like the One-Handed prefix
    local _,_,subtype = string.find(subtype,"%s?(%S+)$")

    if subtype == localizedName or (fist and (CleveRoids.WeaponTypeNames[weaponType].name == CleveRoids.Localized.FistWeapon)) then
        return true
    end

    return false
end

-- Checks whether or not the given UnitId is in your party or your raid
-- target: The UnitId of the target to check
-- groupType: The name of the group type your target has to be in ("party" or "raid")
-- returns: True when the given target is in the given groupType, otherwhise false
function CleveRoids.IsTargetInGroupType(target, groupType)
    local groupSize = (groupType == "raid") and 40 or 5

    for i = 1, groupSize do
        if UnitIsUnit(groupType..i, target) then
            return true
        end
    end

    return false
end

function CleveRoids.GetSpammableConditional(name)
    return CleveRoids.spamConditions[name] or "nomybuff"
end

-- PERFORMANCE: Cache for stripped spell names (removes rank suffix)
local _strippedNameCache = {}
local _strippedCacheSize = 0
local _STRIPPED_CACHE_MAX = 128

local function GetStrippedSpellName(name)
    if not name or name == "" then return "" end
    local cached = _strippedNameCache[name]
    if cached then return cached end

    local stripped = string.gsub(name, "%(.-%)%s*", "")
    if _strippedCacheSize < _STRIPPED_CACHE_MAX then
        _strippedNameCache[name] = stripped
        _strippedCacheSize = _strippedCacheSize + 1
    end
    return stripped
end

-- Checks whether or not we're currently casting a spell with cast time
-- Returns TRUE if we should allow the cast (not casting, or not casting the specified spell)
-- Returns FALSE if we should block the cast (currently casting)
function CleveRoids.CheckCasting(castingSpell)
    -- No parameter: check if we're casting ANYTHING
    if not castingSpell or castingSpell == "" then
        -- Time-based prediction: if we know cast duration, check if it should be done
        if CleveRoids.CurrentSpell.type == "cast" and CleveRoids.castStartTime and CleveRoids.castDuration then
            local elapsed = GetTime() - CleveRoids.castStartTime
            local remaining = CleveRoids.castDuration - elapsed

            -- If cast should be done (with 0.1s grace period), treat as not casting
            if remaining <= 0.1 then
                CleveRoids.CurrentSpell.type = ""
                return true
            end
        end

        return CleveRoids.CurrentSpell.type ~= "cast"
    end

    -- With parameter: check if we're casting a specific spell
    -- PERFORMANCE: Use cached stripped names to avoid string.gsub per call
    local spellName = GetStrippedSpellName(CleveRoids.CurrentSpell.spellName)
    local casting = GetStrippedSpellName(castingSpell)

    -- If we're casting this specific spell, block the recast
    if CleveRoids.CurrentSpell.type == "cast" and spellName == casting then
        return false
    end

    -- Not casting the specified spell, allow the cast
    return true
end

-- Checks whether or not we're currently casting a channeled spell
-- Returns TRUE if we should allow the cast (not channeling, or not channeling the specified spell)
-- Returns FALSE if we should block the cast (currently channeling)
function CleveRoids.CheckChanneled(channeledSpell)
    -- No parameter: check if we're channeling ANYTHING
    if not channeledSpell or channeledSpell == "" then
        -- Time-based prediction: if we know channel duration, check if it should be done
        if CleveRoids.CurrentSpell.type == "channeled" and CleveRoids.channelStartTime and CleveRoids.channelDuration then
            local elapsed = GetTime() - CleveRoids.channelStartTime
            local remaining = CleveRoids.channelDuration - elapsed

            -- If channel should be done (with 0.1s grace period), treat as not channeling
            if remaining <= 0.1 then
                CleveRoids.CurrentSpell.type = ""
                return true
            end
        end

        return CleveRoids.CurrentSpell.type ~= "channeled"
    end

    -- Remove the "(Rank X)" part from the spells name in order to allow downranking
    -- PERFORMANCE: Use cached stripped names to avoid string.gsub per call
    local spellName = GetStrippedSpellName(CleveRoids.CurrentSpell.spellName)
    local channeled = GetStrippedSpellName(channeledSpell)

    -- If we're channeling this specific spell, block the recast
    if CleveRoids.CurrentSpell.type == "channeled" and spellName == channeled then
        return false
    end

    -- Special cases for auto-attacks
    if channeled == CleveRoids.Localized.Attack then
        return not CleveRoids.CurrentSpell.autoAttack
    end

    if channeled == CleveRoids.Localized.AutoShot then
        return not CleveRoids.CurrentSpell.autoShot
    end

    if channeled == CleveRoids.Localized.Shoot then
        return not CleveRoids.CurrentSpell.wand
    end

    -- If none of the special cases matched, allow the cast (not channeling the specified spell)
    return true
end

function CleveRoids.ValidateComboPoints(operator, amount)
    if not operator or not amount then return false end
    local points = GetComboPoints()

    if CleveRoids.operators[operator] then
        return CleveRoids.comparators[operator](points, amount)
    end

    return false
end

-- Validates swing timer percentage for SP_SwingTimer addon integration
-- operator: Comparison operator (>, <, =, >=, <=, ~=)
-- amount: Percentage of swing time elapsed (e.g., 20 means 20% of swing has elapsed)
-- returns: True if percentElapsed [operator] amount
function CleveRoids.ValidateSwingTimer(operator, amount)
    if not operator or not amount then return false end

    -- Check if SP_SwingTimer is loaded by checking for st_timer global
    if st_timer == nil then
        -- Only show error once per session
        if not CleveRoids._swingTimerErrorShown then
            DEFAULT_CHAT_FRAME:AddMessage("|cffff0000[SuperCleveRoidMacros]|r The [swingtimer] conditional requires the SP_SwingTimer addon. Get it at: https://github.com/jrc13245/SP_SwingTimer", 1, 0.5, 0.5)
            CleveRoids._swingTimerErrorShown = true
        end
        return false
    end

    -- Get player's attack speed (main hand)
    local attackSpeed = UnitAttackSpeed("player")
    if not attackSpeed or attackSpeed <= 0 then return false end

    -- Calculate percentage of swing elapsed
    -- st_timer counts down from attackSpeed to 0 (time remaining)
    -- So: timeElapsed = attackSpeed - st_timer
    local timeElapsed = attackSpeed - st_timer
    local percentElapsed = (timeElapsed / attackSpeed) * 100

    -- Compare percent elapsed against threshold
    if CleveRoids.operators[operator] then
        return CleveRoids.comparators[operator](percentElapsed, amount)
    end

    return false
end

-- Constants for Slam window calculations
local GCD_DURATION = 1.5  -- Global cooldown in seconds
local DEFAULT_SLAM_CAST = 2.5  -- Default Slam cast time in Turtle WoW

-- Cache for Slam cast time from tooltip
local cachedSlamCastTime = nil
local slamCastTimeLastUpdate = 0
local SLAM_CACHE_DURATION = 2  -- Re-scan tooltip every 2 seconds

-- Hidden tooltip for scanning spell info
local SlamScanTooltip = nil

-- Create hidden tooltip for scanning (once)
local function GetSlamScanTooltip()
    if not SlamScanTooltip then
        SlamScanTooltip = CreateFrame("GameTooltip", "CleveRoidsSlamScanTooltip", nil, "GameTooltipTemplate")
        SlamScanTooltip:SetOwner(WorldFrame, "ANCHOR_NONE")
    end
    return SlamScanTooltip
end

-- Parse cast time from tooltip text (e.g., "1.5 sec cast" or "1.59 sec cast")
local function ParseCastTimeFromText(text)
    if not text then return nil end
    -- Match patterns like "1.5 sec cast", "1.59 sec cast", "2 sec cast"
    local castTime = string.match(text, "(%d+%.?%d*) sec cast")
    if castTime then
        return tonumber(castTime)
    end
    return nil
end

-- Get Slam's spellbook slot
local function GetSlamSpellSlot()
    -- Search through spellbook for Slam
    local i = 1
    while true do
        local spellName, spellRank = GetSpellName(i, BOOKTYPE_SPELL)
        if not spellName then break end
        if spellName == "Slam" then
            return i, BOOKTYPE_SPELL
        end
        i = i + 1
    end
    return nil, nil
end
-- Expose for debug command
CleveRoids.GetSlamSpellSlot = GetSlamSpellSlot

-- Scan Slam tooltip for cast time
local function ScanSlamCastTime()
    local slot, bookType = GetSlamSpellSlot()
    if not slot then return nil end

    local tooltip = GetSlamScanTooltip()
    tooltip:ClearLines()
    tooltip:SetSpell(slot, bookType)

    -- Scan tooltip lines for cast time
    for i = 1, tooltip:NumLines() do
        local leftText = getglobal("CleveRoidsSlamScanTooltipTextLeft" .. i)
        if leftText then
            local text = leftText:GetText()
            local castTime = ParseCastTimeFromText(text)
            if castTime then
                return castTime
            end
        end
        local rightText = getglobal("CleveRoidsSlamScanTooltipTextRight" .. i)
        if rightText then
            local text = rightText:GetText()
            local castTime = ParseCastTimeFromText(text)
            if castTime then
                return castTime
            end
        end
    end

    return nil
end

-- Get Slam's cast time in seconds (with caching)
-- Reads from spellbook tooltip to get accurate cast time with haste/talents
function CleveRoids.GetSlamCastTime()
    local now = GetTime()

    -- Use cached value if still valid
    if cachedSlamCastTime and (now - slamCastTimeLastUpdate) < SLAM_CACHE_DURATION then
        return cachedSlamCastTime
    end

    -- Try to scan tooltip for cast time
    local castTime = ScanSlamCastTime()
    if castTime and castTime > 0 then
        cachedSlamCastTime = castTime
        slamCastTimeLastUpdate = now
        return castTime
    end

    -- Fall back to default
    return DEFAULT_SLAM_CAST
end

-- Force refresh of cached Slam cast time (call when buffs change)
function CleveRoids.RefreshSlamCastTime()
    cachedSlamCastTime = nil
    slamCastTimeLastUpdate = 0
end

-- Calculate maximum elapsed swing timer % to cast Slam without clipping auto-attack
-- Formula: MaxSlamPercent = (SwingTimer - SlamCastTime) / SwingTimer * 100
function CleveRoids.GetSlamWindowPercent()
    local attackSpeed = UnitAttackSpeed("player")
    if not attackSpeed or attackSpeed <= 0 then return 0 end

    local slamCastTime = CleveRoids.GetSlamCastTime()
    local maxSlamStart = attackSpeed - slamCastTime

    if maxSlamStart <= 0 then return 0 end  -- Slam cast time exceeds swing timer

    return (maxSlamStart / attackSpeed) * 100
end

-- Calculate maximum elapsed swing timer % to cast instant without clipping NEXT Slam
-- Scenario: No Slam this swing, cast instant, then Slam next swing without clipping
-- Formula: MaxInstantPercent = (2 * SwingTimer - SlamCastTime - GCD) / SwingTimer * 100
function CleveRoids.GetInstantWindowPercent()
    local attackSpeed = UnitAttackSpeed("player")
    if not attackSpeed or attackSpeed <= 0 then return 0 end

    local slamCastTime = CleveRoids.GetSlamCastTime()
    local maxInstantStart = (2 * attackSpeed) - slamCastTime - GCD_DURATION

    if maxInstantStart <= 0 then return 0 end  -- Window is impossible with current timings

    return (maxInstantStart / attackSpeed) * 100
end

-- Validate if current swing timer is within the Slam window (no clip)
-- Returns true if casting Slam NOW will NOT clip the auto-attack
function CleveRoids.ValidateNoSlamClip()
    -- Check if SP_SwingTimer is loaded
    if st_timer == nil then
        if not CleveRoids._slamClipErrorShown then
            DEFAULT_CHAT_FRAME:AddMessage("|cffff0000[SuperCleveRoidMacros]|r The [noslamclip] conditional requires the SP_SwingTimer addon. Get it at: https://github.com/jrc13245/SP_SwingTimer", 1, 0.5, 0.5)
            CleveRoids._slamClipErrorShown = true
        end
        return false
    end

    local attackSpeed = UnitAttackSpeed("player")
    if not attackSpeed or attackSpeed <= 0 then return false end

    local timeElapsed = attackSpeed - st_timer
    local percentElapsed = (timeElapsed / attackSpeed) * 100
    local maxPercent = CleveRoids.GetSlamWindowPercent()

    return percentElapsed <= maxPercent
end

-- Validate if current swing timer is within the instant window for next Slam
-- Returns true if casting an instant NOW will NOT cause the NEXT Slam to clip
function CleveRoids.ValidateNoNextSlamClip()
    -- Check if SP_SwingTimer is loaded
    if st_timer == nil then
        if not CleveRoids._slamClipErrorShown then
            DEFAULT_CHAT_FRAME:AddMessage("|cffff0000[SuperCleveRoidMacros]|r The [nonextslamclip] conditional requires the SP_SwingTimer addon. Get it at: https://github.com/jrc13245/SP_SwingTimer", 1, 0.5, 0.5)
            CleveRoids._slamClipErrorShown = true
        end
        return false
    end

    local attackSpeed = UnitAttackSpeed("player")
    if not attackSpeed or attackSpeed <= 0 then return false end

    local timeElapsed = attackSpeed - st_timer
    local percentElapsed = (timeElapsed / attackSpeed) * 100
    local maxPercent = CleveRoids.GetInstantWindowPercent()

    return percentElapsed <= maxPercent
end

function CleveRoids.ValidateLevel(unit, operator, amount)
    if not unit or not operator or not amount then return false end
    local level = UnitLevel(unit)

    -- Treat skull/boss mobs (??) as level 63
    if level == -1 then
        level = 63
    end

    if level and CleveRoids.operators[operator] then
        return CleveRoids.comparators[operator](level, amount)
    end

    return false
end

--- Validates a threat percentage conditional using server threat data.
--- Usage: [threat:>80] [threat:<50] [threat:=100]
--- operator: Comparison operator (>, <, =, >=, <=, ~=)
--- amount: Threat percentage (0-100+, where 100 = will pull aggro)
--- returns: True if playerThreat [operator] amount
--- Note: Requires TWThreat addon to be running (sends threat requests to server)
function CleveRoids.ValidateThreat(operator, amount)
    if not operator or not amount then return false end

    -- Get threat percentage from parsed server data
    local threatpct = CleveRoids.GetPlayerThreatPercent()

    -- No threat data available
    if threatpct == nil then
        return false
    end

    -- Compare threat percentage against threshold
    if CleveRoids.operators[operator] then
        return CleveRoids.comparators[operator](threatpct, amount)
    end

    return false
end

--- Validates a Time-To-Kill conditional using TimeToKill addon.
--- Usage: [ttk:<10] [ttk:>30] [ttk:=5]
--- operator: Comparison operator (>, <, =, >=, <=, ~=)
--- amount: Time in seconds until target death
--- returns: True if TTK [operator] amount
function CleveRoids.ValidateTTK(operator, amount)
    if not operator or not amount then return false end

    -- Check if TimeToKill is loaded
    if type(TimeToKill) ~= "table" or type(TimeToKill.GetTTK) ~= "function" then
        -- Only show error once per session
        if not CleveRoids._ttkErrorShown then
            DEFAULT_CHAT_FRAME:AddMessage("|cffff0000[SuperCleveRoidMacros]|r The [ttk] conditional requires the TimeToKill addon.", 1, 0.5, 0.5)
            CleveRoids._ttkErrorShown = true
        end
        return false
    end

    local ttk = TimeToKill.GetTTK()
    if ttk == nil then
        return false -- Not tracking TTK
    end

    -- Compare TTK against threshold
    if CleveRoids.operators[operator] then
        return CleveRoids.comparators[operator](ttk, amount)
    end

    return false
end

--- Validates a Time-To-Execute conditional using TimeToKill addon.
--- Usage: [tte:<5] [tte:>10]
--- operator: Comparison operator (>, <, =, >=, <=, ~=)
--- amount: Time in seconds until target reaches 20% HP
--- returns: True if TTE [operator] amount
function CleveRoids.ValidateTTE(operator, amount)
    if not operator or not amount then return false end

    -- Check if TimeToKill is loaded
    if type(TimeToKill) ~= "table" or type(TimeToKill.GetTTE) ~= "function" then
        if not CleveRoids._ttkErrorShown then
            DEFAULT_CHAT_FRAME:AddMessage("|cffff0000[SuperCleveRoidMacros]|r The [tte] conditional requires the TimeToKill addon.", 1, 0.5, 0.5)
            CleveRoids._ttkErrorShown = true
        end
        return false
    end

    local tte = TimeToKill.GetTTE()
    if tte == nil then
        return false -- Not tracking or already in execute phase
    end

    if CleveRoids.operators[operator] then
        return CleveRoids.comparators[operator](tte, amount)
    end

    return false
end

-- ============================================================================
-- CURSIVE ADDON INTEGRATION
-- ============================================================================
-- Integrates with Cursive addon for accurate debuff time tracking
-- Cursive tracks debuffs by GUID with precise timing (accounts for Dark Harvest, etc.)

--- Check if Cursive addon is available and enabled
--- @return boolean True if Cursive is available
function CleveRoids.HasCursive()
    return type(Cursive) == "table" and
           type(Cursive.curses) == "table" and
           type(Cursive.curses.HasCurse) == "function"
end

--- Require Cursive for a feature, warn once if missing
--- @param feature string Feature name for warning message
--- @return boolean True if Cursive is available
function CleveRoids.RequireCursive(feature)
    if CleveRoids.HasCursive() then
        return true
    end
    if not CleveRoids._cursiveErrorShown then
        DEFAULT_CHAT_FRAME:AddMessage("|cffff0000[SuperCleveRoidMacros]|r The [cursive] conditional requires the Cursive addon.", 1, 0.5, 0.5)
        CleveRoids._cursiveErrorShown = true
    end
    return false
end

--- Get time remaining on a Cursive-tracked debuff
--- @param unit string Unit to check (will be converted to GUID)
--- @param spellName string Spell name to check (will be lowercased and rank-stripped)
--- @return number|nil Time remaining in seconds, or nil if not found
function CleveRoids.GetCursiveTimeRemaining(unit, spellName)
    if not CleveRoids.HasCursive() then return nil end
    if not unit or not UnitExists(unit) then return nil end

    local _, guid = UnitExists(unit)
    if not guid then return nil end

    -- Normalize spell name (lowercase, no rank) to match Cursive's format
    local lowercaseName = Cursive.utils.GetLowercaseSpellNameNoRank(spellName)

    local curseData = Cursive.curses:GetCurseData(lowercaseName, guid)
    if not curseData then return nil end

    return Cursive.curses:TimeRemaining(curseData)
end

--- Check if unit has a Cursive-tracked debuff with optional time comparison
--- @param unit string Unit to check
--- @param spellName string Spell name to check
--- @param operator string|nil Comparison operator (>, <, =, >=, <=, ~=)
--- @param amount number|nil Time threshold in seconds
--- @return boolean True if debuff exists and passes time check
function CleveRoids.ValidateCursiveDebuff(unit, spellName, operator, amount)
    if not CleveRoids.HasCursive() then return false end
    if not unit or not UnitExists(unit) then return false end

    local _, guid = UnitExists(unit)
    if not guid then return false end

    -- Normalize spell name for Cursive lookup
    local lowercaseName = Cursive.utils.GetLowercaseSpellNameNoRank(spellName)

    -- If no operator, just check if debuff exists with any time remaining
    if not operator then
        return Cursive.curses:HasCurse(lowercaseName, guid, 0) == true
    end

    -- With operator, check time remaining
    local timeRemaining = CleveRoids.GetCursiveTimeRemaining(unit, spellName)
    -- If debuff not found, treat as 0 seconds remaining (matches [debuff] behavior)
    -- This makes [cursive:Rake<5] true when Rake is missing (0 < 5 = true)
    if not timeRemaining then timeRemaining = 0 end

    if CleveRoids.operators[operator] and amount then
        return CleveRoids.comparators[operator](timeRemaining, amount)
    end

    return false
end

--- Check if ANY Cursive-tracked debuff exists on unit
--- @param unit string Unit to check
--- @return boolean True if unit has any tracked debuffs
function CleveRoids.HasAnyCursiveDebuff(unit)
    if not CleveRoids.HasCursive() then return false end
    if not unit or not UnitExists(unit) then return false end

    local _, guid = UnitExists(unit)
    if not guid then return false end

    return Cursive.curses:HasAnyCurse(guid) == true
end

function CleveRoids.ValidateKnown(args)
    if not args then
        return false
    end
    if table.getn(CleveRoids.Talents) == 0 then
        CleveRoids.IndexTalents()
    end

    local effective_name_to_check
    local original_args_for_rank_check = args

    if type(args) ~= "table" then
        effective_name_to_check = args
        args = { name = args }
    else
        effective_name_to_check = args.name
    end

    local spell = CleveRoids.GetSpell(effective_name_to_check)
    local talent_points = nil

    if not spell then
        talent_points = CleveRoids.GetTalent(effective_name_to_check)
    end

    if not spell and talent_points == nil then
        return false
    end

    local arg_amount = nil
    local arg_operator = nil
    if type(original_args_for_rank_check) == "table" then
        arg_amount = original_args_for_rank_check.amount
        arg_operator = original_args_for_rank_check.operator
    end

    if spell then
        local spell_rank_str = spell.rank or (spell.highest and spell.highest.rank) or ""
        -- FLEXIBLY extract just the number from the rank string
        local _, _, spell_rank_num_str = string.find(spell_rank_str, "(%d+)")

        if not arg_amount and not arg_operator then
            return true
        elseif arg_amount and arg_operator and CleveRoids.operators[arg_operator] and spell_rank_num_str and spell_rank_num_str ~= "" then
            local numeric_rank = tonumber(spell_rank_num_str)
            if numeric_rank then
                return CleveRoids.comparators[arg_operator](numeric_rank, arg_amount)
            else
                return false
            end
        else
            return false
        end
    elseif talent_points ~= nil then
        if not arg_amount and not arg_operator then
            return talent_points > 0
        elseif arg_amount and arg_operator and CleveRoids.operators[arg_operator] then
            return CleveRoids.comparators[arg_operator](talent_points, arg_amount)
        else
            return false
        end
    end

    return false
end

function CleveRoids.ValidateResting()
    return IsResting()
end


-- TODO: refactor numeric comparisons...

-- Checks whether or not the given unit has power in percent vs the given amount
-- unit: The unit we're checking
-- operator: valid comparitive operator symbol
-- amount: The required amount
-- returns: True or false
function CleveRoids.ValidatePower(unit, operator, amount)
    if not unit or not operator or not amount then return false end
    local powerPercent = 100 / UnitManaMax(unit) * UnitMana(unit)

    if powerPercent and CleveRoids.operators[operator] then
        return CleveRoids.comparators[operator](powerPercent, amount)
    end

    return false
end

-- Checks whether or not the given unit has current power vs the given amount
-- unit: The unit we're checking
-- operator: valid comparitive operator symbol
-- amount: The required amount
-- returns: True or false
function CleveRoids.ValidateRawPower(unit, operator, amount)
    if not unit or not operator or not amount then return false end
    local power = UnitMana(unit)

    if power and CleveRoids.operators[operator] then
        return CleveRoids.comparators[operator](power, amount)
    end

    return false
end

-- Raw caster-form mana for druids (SuperWoW: 2nd return of UnitMana)
function CleveRoids.ValidateDruidRawMana(unit, operator, amount)
    unit = unit or "player"
    if not operator or amount == nil then return false end
    if (CleveRoids.playerClass ~= "DRUID") then return false end

    -- SuperWoW returns: current-form power, caster-form mana
    local _, casterMana = UnitMana(unit)

    -- Fallback: if for some reason we didn't get a 2nd value and we're in caster form now
    if type(casterMana) ~= "number" then
        if UnitPowerType and UnitPowerType(unit) == 0 then
            casterMana = UnitMana(unit)
        else
            return false
        end
    end

    local cmp = CleveRoids.comparators and CleveRoids.comparators[operator]
    return cmp and cmp(casterMana, amount) or false
end

-- Checks whether or not the given unit has a power deficit vs the amount specified
-- unit: The unit we're checking
-- operator: valid comparitive operator symbol
-- amount: The required amount
-- returns: True or false
function CleveRoids.ValidatePowerLost(unit, operator, amount)
    if not unit or not operator or not amount then return false end
    local powerLost = UnitManaMax(unit) - UnitMana(unit)

    if CleveRoids.operators[operator] then
        return CleveRoids.comparators[operator](powerLost, amount)
    end

    return false
end

-- Checks whether or not the given unit has hp in percent vs the given amount
-- unit: The unit we're checking
-- operator: valid comparitive operator symbol
-- amount: The required amount
-- returns: True or false
function CleveRoids.ValidateHp(unit, operator, amount)
    if not unit or not operator or not amount then return false end
    local hpPercent = 100 / UnitHealthMax(unit) * UnitHealth(unit)

    if CleveRoids.operators[operator] then
        return CleveRoids.comparators[operator](hpPercent, amount)
    end

    return false
end

-- Checks whether or not the given unit has hp vs the given amount
-- unit: The unit we're checking
-- operator: valid comparitive operator symbol
-- amount: The required amount
-- returns: True or false
function CleveRoids.ValidateRawHp(unit, operator, amount)
    if not unit or not operator or not amount then return false end
    local rawhp = UnitHealth(unit)

    if CleveRoids.operators[operator] then
        return CleveRoids.comparators[operator](rawhp, amount)
    end

    return false
end

-- Checks whether or not the given unit has an hp deficit vs the amount specified
-- unit: The unit we're checking
-- operator: valid comparitive operator symbol
-- amount: The required amount
-- returns: True or false
function CleveRoids.ValidateHpLost(unit, operator, amount)
    if not unit or not operator or not amount then return false end
    local hpLost = UnitHealthMax(unit) - UnitHealth(unit)

    if CleveRoids.operators[operator] then
        return CleveRoids.comparators[operator](hpLost, amount)
    end

    return false
end

-- Checks whether the given creatureType is the same as the target's creature type
-- creatureType: The type to check
-- target: The target's unitID
-- returns: True or false
-- remarks: Allows for both localized and unlocalized type names
function CleveRoids.ValidateCreatureType(creatureType, target)
    if not target then return false end
    local targetType = UnitCreatureType(target)
    if not targetType then return false end -- ooze or silithid etc
    local ct = string.lower(creatureType)
    local cl = UnitClassification(target)
    -- Check classification: "boss" matches both "boss" and "worldboss"
    if ct == "boss" then
        if cl == "boss" or cl == "worldboss" then
            return true
        end
    elseif ct == cl then
        return true
    end
    if ct == "boss" then creatureType = "worldboss" end
    local englishType = CleveRoids.Localized.CreatureTypes[targetType]
    return ct == string.lower(targetType) or creatureType == englishType
end

-- TODO: Look into https://github.com/Stanzilla/WoWUIBugs/issues/47 if needed
function CleveRoids.ValidateCooldown(args, ignoreGCD)
    if not args then return false end

    local name
    if type(args) ~= "table" then
        -- PERFORMANCE: Use cached normalization
        name = CleveRoids.NormalizeName(args)

        -- If this is a numeric slot (1-19), resolve to the equipped item's name
        local slotNum = tonumber(name)
        if slotNum and slotNum >= 1 and slotNum <= 19 then
            local link = GetInventoryItemLink("player", slotNum)
            if link then
                local _, _, itemName = string.find(link, "%[(.+)%]")
                if itemName then name = itemName end
            end
        end
        args = {name = name}
    else
        if args.name then
            -- PERFORMANCE: Use cached normalization
            name = CleveRoids.NormalizeName(args.name)

            -- If this is a numeric slot (1-19), resolve to the equipped item's name
            local slotNum = tonumber(name)
            if slotNum and slotNum >= 1 and slotNum <= 19 then
                local link = GetInventoryItemLink("player", slotNum)
                if link then
                    local _, _, itemName = string.find(link, "%[(.+)%]")
                    if itemName then name = itemName end
                end
            end
            args.name = name
        else
            name = args.name
        end
    end

    -- PERFORMANCE: GetCooldown is now cached per-frame
    local expires = CleveRoids.GetCooldown(args.name, ignoreGCD)
    local now = CleveRoids.GetCachedTime()

    if not args.operator and not args.amount then
        return expires > now
    elseif CleveRoids.operators[args.operator] then
        return CleveRoids.comparators[args.operator](expires - now, args.amount)
    end
end

function CleveRoids.GetPlayerAura(index, isbuff)
    if not index then return false end

    local buffType = isbuff and "HELPFUL" or "HARMFUL"
    local bid = GetPlayerBuff(index, buffType)
    if bid < 0 then return end

    local spellID = CleveRoids.hasSuperwow and GetPlayerBuffID(bid)

    return GetPlayerBuffTexture(bid), GetPlayerBuffApplications(bid), spellID, GetPlayerBuffTimeLeft(bid)
end

-- PERFORMANCE: Local function refs and reusable pattern for buff checking
local _string_lower = string.lower
local _string_gsub = string.gsub
local _RANK_PATTERN = "%s*%(%s*Rank%s+%d+%s*%)"

-- PERFORMANCE: Simple cache for lowercase spell names (cleared periodically)
local _spellNameCache = {}
local _spellNameCacheSize = 0
local _MAX_SPELL_CACHE = 200

-- PERFORMANCE: Cache for base spell names (rank stripped, not lowercased)
local _baseNameCache = {}
local _baseNameCacheSize = 0

local function GetLowercaseSpellName(spellID)
    local cached = _spellNameCache[spellID]
    if cached then return cached end

    local name = SpellInfo(spellID)
    if not name then return nil end

    -- Strip rank and lowercase
    local baseName = _string_gsub(name, _RANK_PATTERN, "")
    local lowerName = _string_lower(baseName)

    -- Cache if not too large
    if _spellNameCacheSize < _MAX_SPELL_CACHE then
        _spellNameCache[spellID] = lowerName
        _spellNameCacheSize = _spellNameCacheSize + 1
    end

    return lowerName
end

-- PERFORMANCE: Get base spell name (rank stripped) and full name - cached
local function GetSpellNames(spellID)
    local cached = _baseNameCache[spellID]
    if cached then
        return cached.base, cached.full
    end

    local fullName = SpellInfo(spellID)
    if not fullName then return nil, nil end

    local baseName = _string_gsub(fullName, _RANK_PATTERN, "")

    -- Cache if not too large
    if _baseNameCacheSize < _MAX_SPELL_CACHE then
        _baseNameCache[spellID] = { base = baseName, full = fullName }
        _baseNameCacheSize = _baseNameCacheSize + 1
    end

    return baseName, fullName
end

-- Clear spell name caches (called periodically from Core.lua cleanup)
function CleveRoids.ClearSpellNameCaches()
    for k in pairs(_spellNameCache) do
        _spellNameCache[k] = nil
    end
    _spellNameCacheSize = 0

    for k in pairs(_baseNameCache) do
        _baseNameCache[k] = nil
    end
    _baseNameCacheSize = 0
end

function CleveRoids.ValidateAura(unit, args, isbuff)
    if not args or not UnitExists(unit) then return false end

    if not CleveRoids.hasSuperwow then
        return false
    end

    if type(args) ~= "table" then
        args = {name = args}
    end

    local isPlayer = UnitIsUnit(unit, "player")
    local found = false
    local stacks, remaining
    local i = isPlayer and 0 or 1

    -- Strip rank suffix for consistent matching (e.g., "Faerie Fire (Feral)(Rank 4)" -> "Faerie Fire (Feral)")
    if args.name then
        args.name = string.gsub(args.name, "%s*%(%s*Rank%s+%d+%s*%)", "")
    end

    -- PERFORMANCE: Cache lowercased search name to avoid repeated string.lower calls
    local searchName = args.name and _string_lower(args.name)

    -- Primary search: BUFFS if isbuff==true, DEBUFFS if isbuff==false
    while true do
        local texture
        local current_spellID = nil

        if isPlayer then
            -- GetPlayerAura(index, isbuff) => texture, stacks, spellID, timeLeft
            texture, stacks, current_spellID, remaining = CleveRoids.GetPlayerAura(i, isbuff)
        else
            if isbuff then
                -- UnitBuff => texture, stacks, spellID
                texture, stacks, current_spellID = UnitBuff(unit, i)
            else
                -- UnitDebuff => texture, stacks, debuffType, spellID
                texture, stacks, _, current_spellID = UnitDebuff(unit, i)
            end
            remaining = nil
        end

        if not texture then break end

        if current_spellID and searchName then
            -- PERFORMANCE: Use cached lowercase spell name lookup
            local lowerName = GetLowercaseSpellName(current_spellID)
            if lowerName and lowerName == searchName then
                found = true
                break
            end
        end

        i = i + 1
    end

    -- Overflow handling: when searching DEBUFFS on non-players, also scan BUFFS
    if not isbuff and not isPlayer and not found and searchName then
        i = 1
        while true do
            local texture
            local current_spellID = nil

            -- UnitBuff => texture, stacks, spellID
            texture, stacks, current_spellID = UnitBuff(unit, i)
            if not texture then break end

            if current_spellID then
                -- PERFORMANCE: Use cached lowercase spell name lookup
                local lowerName = GetLowercaseSpellName(current_spellID)
                if lowerName and lowerName == searchName then
                    found = true
                    break
                end
            end

            i = i + 1
        end
    end

    local ops = CleveRoids.operators

    -- Handle multi-comparison (e.g., >0&<10)
    if args.comparisons and type(args.comparisons) == "table" then
        if not found then
            return false  -- Aura doesn't exist, so all comparisons fail
        end

        -- ALL comparisons must pass (AND logic)
        for _, comp in ipairs(args.comparisons) do
            if not ops[comp.operator] then
                return false  -- Invalid operator
            end

            local value_to_check
            if comp.checkStacks then
                value_to_check = stacks or -1
            elseif isPlayer then
                value_to_check = remaining or -1
            else
                -- Non-player units don't have remaining time, only check existence
                return found
            end

            if not CleveRoids.comparators[comp.operator](value_to_check, comp.amount) then
                return false  -- One comparison failed
            end
        end
        return true  -- All comparisons passed
    end

    -- Single comparison (backward compatibility)
    if not args.amount and not args.operator and not args.checkStacks then
        return found
    elseif isPlayer and not args.checkStacks and args.amount and ops[args.operator] then
        return CleveRoids.comparators[args.operator](remaining or -1, args.amount)
    elseif args.amount and args.checkStacks and ops[args.operator] then
        return CleveRoids.comparators[args.operator](stacks or -1, args.amount)
    else
        return false
    end
end

function CleveRoids.ValidateUnitBuff(unit, args)
    return CleveRoids.ValidateAura(unit, args, true)
end

function CleveRoids.ValidateUnitDebuff(unit, args)
    if not args or not UnitExists(unit) then return false end
    if type(args) ~= "table" then
        args = { name = args }
    end
    if not args.name then return false end

    -- Strip rank suffix for consistent matching (e.g., "Faerie Fire (Feral)(Rank 4)" -> "Faerie Fire (Feral)")
    args.name = string.gsub(args.name, "%s*%(%s*Rank%s+%d+%s*%)", "")

    local found = false
    local texture, stacks, spellID, remaining
    local i

    -- PERFORMANCE: For non-SuperWoW, early return if no texture registered
    if not CleveRoids.hasSuperwow and not CleveRoids.auraTextures[args.name] then
        return false
    end

    -- For non-player units, check tracking table directly
    -- SIMPLE: Did the player cast this spell? Is the timer still valid?
    -- Defensive: verify libdebuff is a table before accessing properties
    local lib = type(CleveRoids.libdebuff) == "table" and CleveRoids.libdebuff or nil
    if unit ~= "player" and lib and lib.objects then
        local _, guid = UnitExists(unit)
        if not guid then return false end

        -- Normalize GUID to string for consistent table key lookups
        guid = CleveRoids.NormalizeGUID(guid)
        if not guid then return false end

        -- PERFORMANCE: Use cached spell name -> ID mapping instead of iterating every call
        local matchingSpellIDs = GetSpellIDsForName(args.name) or {}

        -- Check tracking table for ANY rank of this spell: Did player cast this? Is timer valid?
        if matchingSpellIDs and table.getn(matchingSpellIDs) > 0 then
            for _, spellID in ipairs(matchingSpellIDs) do
                local rec = lib.objects[guid] and lib.objects[guid][spellID]
                -- For shared debuffs (Sunder, Faerie Fire, etc.), accept any caster (including nil)
                -- For personal debuffs (Rip, Rupture, etc.), only accept player casts
                local isSharedDebuff = lib.IsPersonalDebuff and lib:IsPersonalDebuff(spellID) == false
                if rec and rec.duration and rec.start and (isSharedDebuff or rec.caster == "player") then
                    local timeRemaining = rec.duration + rec.start - GetTime()
                    if timeRemaining > 0 then
                        found = true
                        remaining = timeRemaining
                        stacks = rec.stacks or 0

                        if CleveRoids.debug then
                            DEFAULT_CHAT_FRAME:AddMessage(
                                string.format("|cff00ff00[Tracking]|r %s (ID:%d): %.1fs left", args.name, spellID, timeRemaining)
                            )
                        end

                        -- Get texture (optional, just for display)
                        for i = 1, 16 do
                            local _, _, _, sid = UnitDebuff(unit, i)
                            if sid == spellID then
                                texture = UnitDebuff(unit, i)
                                break
                            end
                        end
                        if not texture then
                            for i = 1, 32 do
                                local _, _, sid = UnitBuff(unit, i)
                                if sid == spellID then
                                    texture = UnitBuff(unit, i)
                                    break
                                end
                            end
                        end

                        -- Found active debuff, stop searching
                        break
                    elseif rec then
                        -- Debuff expired - remove it from tracking to avoid spam
                        local expiredTime = GetTime() - (rec.start + rec.duration)
                        if CleveRoids.debug and expiredTime < 2.0 then
                            DEFAULT_CHAT_FRAME:AddMessage(
                                string.format("|cffff6600[Tracking]|r %s (ID:%d) expired %.1fs ago",
                                    args.name, spellID, expiredTime)
                            )
                        end
                        -- Remove expired debuff to prevent repeated "expired" messages
                        if lib.objects[guid] then
                            lib.objects[guid][spellID] = nil
                        end
                    end
                end
            end

            -- Only show "not in tracking" message if CleveRoids.debugVerbose is enabled
            -- (too spammy for normal debug mode)
            if not found and CleveRoids.debugVerbose then
                DEFAULT_CHAT_FRAME:AddMessage(
                    string.format("|cffff0000[Tracking]|r %s not in tracking table (checked %d ranks)",
                        args.name, table.getn(matchingSpellIDs))
                )
            end
        elseif CleveRoids.debug then
            DEFAULT_CHAT_FRAME:AddMessage(
                string.format("|cffff0000[Tracking]|r Unknown spell: %s", args.name)
            )
        end

        -- FALLBACK: If not found in tracking table, scan actual debuffs on target
        -- This handles:
        -- 1. Shared debuffs from other players (we only track player's own casts)
        -- 2. Personal debuffs during the 0.2s pending delay after casting
        -- 3. Any debuffs not yet registered in tracking (edge cases)
        --
        -- For simple existence checks ([nodebuff]Spell), we want to find the debuff
        -- regardless of whether it's in our tracking table. Time-remaining checks
        -- will use tracking table data when available, but existence is from scan.
        local isSimpleExistenceCheck = not args.operator and not args.amount

        if not found and CleveRoids.hasSuperwow and isSimpleExistenceCheck then
            -- Scan debuff slots
            for i = 1, 16 do
                local tex, debuffStacks, _, debuffSpellID = UnitDebuff(unit, i)
                if not tex then break end

                if debuffSpellID then
                    -- PERFORMANCE: Use cached spell name lookup
                    local baseName, fullName = GetSpellNames(debuffSpellID)
                    if baseName and (baseName == args.name or fullName == args.name) then
                        found = true
                        texture = tex
                        stacks = debuffStacks or 0
                        spellID = debuffSpellID
                        -- No duration tracking for shared debuffs
                        remaining = nil
                        break
                    end
                end
            end

            -- If still not found, check buff slots (overflow debuffs)
            if not found then
                for i = 1, 32 do
                    local tex, buffStacks, buffSpellID = UnitBuff(unit, i)
                    if not tex then break end

                    if buffSpellID then
                        -- PERFORMANCE: Use cached spell name lookup
                        local baseName, fullName = GetSpellNames(buffSpellID)
                        if baseName and (baseName == args.name or fullName == args.name) then
                            found = true
                            texture = tex
                            stacks = buffStacks or 0
                            spellID = buffSpellID
                            remaining = nil
                            break
                        end
                    end
                end
            end
        end
    -- For player unit, use standard search (player only sees own debuffs on self)
    elseif unit == "player" then
        -- Search DEBUFFS first
        i = 0
        while true do
            texture, stacks, spellID, remaining = CleveRoids.GetPlayerAura(i, false)
            if not texture then break end

            if CleveRoids.hasSuperwow then
                -- PERFORMANCE: Use cached spell name lookup
                local baseName, fullName = GetSpellNames(spellID)
                if baseName and (baseName == args.name or fullName == args.name) then
                    found = true
                    break
                end
            elseif texture == CleveRoids.auraTextures[args.name] then
                found = true
                break
            end
            i = i + 1
        end

        -- If not found, search BUFFS (overflow debuffs shown as buffs on some servers)
        if not found then
            i = 0
            while true do
                texture, stacks, spellID, remaining = CleveRoids.GetPlayerAura(i, true)
                if not texture then break end

                if CleveRoids.hasSuperwow then
                    -- PERFORMANCE: Use cached spell name lookup
                    local baseName, fullName = GetSpellNames(spellID)
                    if baseName and (baseName == args.name or fullName == args.name) then
                        found = true
                        break
                    end
                elseif texture == CleveRoids.auraTextures[args.name] then
                    found = true
                    break
                end
                i = i + 1
            end
        end
    end

    -- Step 3: Perform conditional validation
    local ops = CleveRoids.operators
    local cmp = CleveRoids.comparators

    -- Handle multi-comparison (e.g., >0&<10)
    if args.comparisons and type(args.comparisons) == "table" then
        if not found then
            return false  -- Debuff doesn't exist, so all comparisons fail
        end

        -- For non-player units, get time remaining once (used for all time comparisons)
        local nonPlayerTimeRemaining = nil
        if unit ~= "player" then
            nonPlayerTimeRemaining = _get_debuff_timeleft(unit, args.name) or 0
        end

        -- ALL comparisons must pass (AND logic)
        for _, comp in ipairs(args.comparisons) do
            if not ops[comp.operator] then
                return false  -- Invalid operator
            end

            local value_to_check
            if comp.checkStacks then
                value_to_check = stacks or 0
            elseif unit == "player" then
                value_to_check = remaining or 0
            else
                -- Non-player units: use time remaining from libdebuff
                value_to_check = nonPlayerTimeRemaining
            end

            if not cmp[comp.operator](value_to_check, comp.amount) then
                return false  -- One comparison failed
            end
        end
        return true  -- All comparisons passed
    end

    local hasNumCheck = (args.amount ~= nil) and (args.operator ~= nil) and ops[args.operator]

    -- Case A: No numeric/stack condition, just check for existence.
    if not hasNumCheck and not args.checkStacks then
        return found
    end

    -- Case B: Numeric/stack condition exists.
    if hasNumCheck then
        -- Stacks compare path
        if args.checkStacks then
            if found then
                return cmp[args.operator](stacks or 0, args.amount)
            else
                return cmp[args.operator](0, args.amount)
            end
        end

        -- Time-left compare path
        if unit == "player" then
            if not found then
                return false  -- debuff doesn't exist, fail the check
            end
            local tl = remaining or 0
            return cmp[args.operator](tl, args.amount)
        else
            -- Non-player: try pfUI → internal libdebuff → 0s
            local tl = _get_debuff_timeleft(unit, args.name)
            if tl ~= nil then
                return cmp[args.operator](tl or 0, args.amount)
            end

            -- Defensive: verify libdebuff is a table before accessing properties
            if type(CleveRoids.libdebuff) == "table" and CleveRoids.libdebuff.UnitDebuff then
                local atl = nil
                local caster = nil

                -- Auto-detect if this is a personal debuff (unless explicitly overridden)
                local filterCaster = nil
                if args.mine == true then
                    -- User explicitly requested player-only filtering
                    filterCaster = "player"
                elseif args.mine == false then
                    -- User explicitly requested no filtering
                    filterCaster = nil
                else
                    -- Auto-detect based on spell type (if available and personal, filter to player)
                    -- We'll determine this during the search
                    filterCaster = nil
                end

                -- Check 1-48: debuff slots 1-16 + overflow debuffs in buff slots 1-32
                for idx = 1, 48 do
                    local effect, _, _, _, _, duration, timeleft, effectCaster = CleveRoids.libdebuff:UnitDebuff(unit, idx, filterCaster)
                    -- Only break for slots 1-16 (regular debuffs are dense)
                    -- For overflow slots 17-48, nil means "regular buff filtered out", not "end of list"
                    if not effect and idx <= 16 then break end
                    -- Strip rank from effect name for comparison
                    local effectBase = effect and string.gsub(effect, "%s*%(%s*Rank%s+%d+%s*%)", "")
                    if effectBase and effectBase == args.name then
                        local shouldSkip = false

                        -- Auto-detect: If args.mine not specified and this is a personal debuff, only match player casts
                        if args.mine == nil and spellID and CleveRoids.libdebuff.IsPersonalDebuff then
                            if CleveRoids.libdebuff:IsPersonalDebuff(spellID) and effectCaster ~= "player" then
                                -- This is a personal debuff from another player, skip it
                                shouldSkip = true
                            end
                        end

                        if not shouldSkip then
                            atl = (timeleft and timeleft >= 0) and timeleft or 0
                            caster = effectCaster
                            break
                        end
                    end
                end
                if atl ~= nil then
                    return cmp[args.operator](atl, args.amount)
                end
            end

           -- No timers at all: treat missing/unknown as 0s and compare
            if not found then
                -- If debuff doesn't exist, treat as 0 seconds and compare
                return cmp[args.operator](0, args.amount)
            end
            -- If we reach here with no timer data, treat as 0
            return cmp[args.operator](0, args.amount)
        end
    end

    -- If we get here, nothing matched
    return false
end

function CleveRoids.ValidatePlayerBuff(args)
    -- First check regular buffs
    local found = CleveRoids.ValidateAura("player", args, true)
    if found then return true end

    -- Also check shapeshift forms (Cat Form, Bear Form, etc. are not regular buffs)
    -- This is needed for !Cat Form syntax to work correctly
    local searchName = type(args) == "table" and args.name or args
    if searchName then
        -- PERFORMANCE: Use cached lowercase normalization to avoid per-call string allocation
        searchName = GetLowerNormalizedName(searchName)
        local numForms = GetNumShapeshiftForms()
        for i = 1, numForms do
            local icon, name, isActive, isCastable = GetShapeshiftFormInfo(i)
            -- PERFORMANCE: Use cached lowercase to avoid per-iteration string allocation
            if name and isActive and GetLowercaseString(name) == searchName then
                return true
            end
        end
    end

    return false
end

function CleveRoids.ValidatePlayerDebuff(args)
    return CleveRoids.ValidateAura("player", args, false)
end

function CleveRoids.ValidateWeaponImbue(slot, args)
    -- Check if weapon has enchant via API
    local hasMainEnchant, mainExpiration, mainCharges, hasOffEnchant, offExpiration, offCharges = GetWeaponEnchantInfo()

    local hasEnchant, expiration, charges
    if slot == "mh" then
        hasEnchant = hasMainEnchant
        expiration = mainExpiration
        charges = mainCharges
    else
        hasEnchant = hasOffEnchant
        expiration = offExpiration
        charges = offCharges
    end

    -- Only consider temporary enchants (with time or charges)
    -- This filters out permanent enchants like Crusader, Lifestealing, etc.
    local hasTemporaryEnchant = hasEnchant and (expiration and expiration > 0 or charges and charges > 0)

    -- Convert expiration from milliseconds to seconds
    local remaining = expiration and (expiration / 1000) or -1
    local stacks = charges or 0

    -- Normalize args to table format
    if type(args) ~= "table" then
        args = { name = args }
    end

    local imbueName = args.name

    -- If no specific imbue requested and no comparison operators, return temporary enchant status
    if (not imbueName or imbueName == "") and not args.operator and not args.comparisons then
        return hasTemporaryEnchant
    end

    -- If no temporary enchant, don't bother with further checks
    if not hasTemporaryEnchant then
        return false
    end

    -- If we have a specific imbue name, verify it via tooltip scan
    if imbueName and imbueName ~= "" then
        local nameFound = CleveRoids.CheckWeaponImbueByName(slot, imbueName)
        if not nameFound then
            return false  -- Specific imbue not found
        end
    end

    -- Handle numeric comparisons (time remaining or charges)
    local ops = CleveRoids.operators

    -- Handle multi-comparison (e.g., >60&<300)
    if args.comparisons and type(args.comparisons) == "table" then
        -- ALL comparisons must pass (AND logic)
        for _, comp in ipairs(args.comparisons) do
            if not ops[comp.operator] then
                return false  -- Invalid operator
            end

            local value_to_check
            if comp.checkStacks then
                value_to_check = stacks
            else
                value_to_check = remaining
            end

            if not CleveRoids.comparators[comp.operator](value_to_check, comp.amount) then
                return false  -- One comparison failed
            end
        end
        return true  -- All comparisons passed
    end

    -- Single comparison (backward compatibility)
    if not args.amount and not args.operator and not args.checkStacks then
        return true  -- Name matched (or no name required), no numeric check needed
    elseif not args.checkStacks and args.amount and ops[args.operator] then
        -- Time remaining check
        return CleveRoids.comparators[args.operator](remaining, args.amount)
    elseif args.amount and args.checkStacks and ops[args.operator] then
        -- Charge count check
        return CleveRoids.comparators[args.operator](stacks, args.amount)
    else
        return false
    end
end

-- Helper function: Parse imbue conditional arguments into a normalized args table
-- Handles: boolean, string, or table with name/operator/amount/checkStacks/comparisons
function CleveRoids.ParseImbueArgs(value, conditionals)
    -- Boolean true means check for any imbue
    if value == true then
        return nil
    end

    -- Simple string means just check for name
    if type(value) == "string" then
        return { name = value }
    end

    -- Table format - could be array of values or parsed args with operator
    if type(value) == "table" then
        -- Check if it's already a parsed args table (has operator or comparisons)
        if value.operator or value.comparisons or value.checkStacks then
            return value
        end

        -- It's an array of values - use the first one
        if table.getn(value) > 0 then
            local first = value[1]
            -- First element could be a string or a parsed args table
            if type(first) == "string" then
                return { name = first }
            elseif type(first) == "table" then
                return first  -- Already parsed (has name, operator, amount, etc.)
            end
        end
    end

    return nil  -- Default: check for any imbue
end

-- Helper function: Check if specific imbue name is on weapon via tooltip scan
function CleveRoids.CheckWeaponImbueByName(slot, imbueName)
    if not imbueName or imbueName == "" then
        return true  -- No name to check
    end

    -- Create tooltip scanner if needed
    if not CleveRoidsTooltip then
        CreateFrame("GameTooltip", "CleveRoidsTooltip", nil, "GameTooltipTemplate")
    end

    -- Scan weapon tooltip
    CleveRoidsTooltip:SetOwner(UIParent, "ANCHOR_NONE")
    CleveRoidsTooltip:ClearLines()
    CleveRoidsTooltip:SetInventoryItem("player", slot == "mh" and 16 or 17)

    -- PERFORMANCE: Use cached normalization to avoid per-call string allocation
    local searchTerm = GetLowerNormalizedName(imbueName)

    -- Look for green text with time markers - check ALL green lines with time
    for i = 1, CleveRoidsTooltip:NumLines() do
        local text = _G["CleveRoidsTooltipTextLeft"..i]
        if text then
            local line = text:GetText()
            if line then
                local r, g, b = text:GetTextColor()
                -- Green text indicates enchant
                if g > 0.8 and r < 0.2 and b < 0.2 then
                    local lowerLine = string.lower(line)
                    -- Only check lines with time markers (temporary enchants)
                    -- This skips permanent weapon stats like "Equip: ... critical strike ..."
                    if string.find(lowerLine, "%(") and (string.find(lowerLine, " min%)") or string.find(lowerLine, " sec%)") or string.find(lowerLine, " charge")) then
                        -- This is a temporary enchant line, check if it matches
                        if string.find(lowerLine, searchTerm, 1, true) then
                            return true  -- Found it!
                        end
                    end
                end
            end
        end
    end

    -- Checked all lines, didn't find it
    return false
end

-- TODO: Look into https://github.com/Stanzilla/WoWUIBugs/issues/47 if needed
-- PERFORMANCE: Uncached version - called by GetCachedCooldown
function CleveRoids._GetCooldownUncached(name, ignoreGCD)
    if not name then return 0 end

    -- Check if it's a spell first
    local spell = CleveRoids.GetSpell(name)
    if spell then
        local expires = CleveRoids.GetSpellCooldown(name, ignoreGCD)
        return expires  -- GetSpellCooldown already returns absolute time
    end

    -- Not a spell, check if it's an item
    -- GetItemCooldown returns (remainingSeconds, totalDuration, enabled)
    local remaining, duration, enabled = CleveRoids.GetItemCooldown(name, ignoreGCD)

    -- Convert remaining seconds to absolute expiry time
    if remaining and remaining > 0 then
        return CleveRoids.GetCachedTime() + remaining
    end

    return 0
end

-- PERFORMANCE: Cached wrapper - use this for conditional checks
function CleveRoids.GetCooldown(name, ignoreGCD)
    return CleveRoids.GetCachedCooldown(name, ignoreGCD)
end

-- TODO: Look into https://github.com/Stanzilla/WoWUIBugs/issues/47 if needed
-- Returns the cooldown of the given spellName or nil if no such spell was found
function CleveRoids.GetSpellCooldown(spellName, ignoreGCD)
    if not spellName then return 0 end

    local spell = CleveRoids.GetSpell(spellName)
    if not spell then return 0 end

    local start, cd = GetSpellCooldown(spell.spellSlot, spell.bookType)
    if ignoreGCD and cd and cd > 0 and cd <= 1.5 then
        return 0
    else
        return (start + cd)
    end
end

-- Check if an item exists in bags or equipped
-- Returns: true if found, false otherwise
-- PERFORMANCE: Uses CleveRoids.Items cache for O(1) lookup, with fallback for substring matches
function CleveRoids.HasItem(item)
  -- Fast path: check cache first (O(1) lookup)
  if CleveRoids.HasItemCached(item) then
    return true
  end

  -- Slow path fallback: only needed for substring matching on strings
  -- The cache handles exact matches by ID and name, but not partial/substring matches
  if type(item) == "string" and item ~= "" then
    local itemLower = string.lower(item)

    -- Check equipped slots for substring match
    for slot = 0, 19 do
      local link = GetInventoryItemLink("player", slot)
      if link then
        if string.find(string.lower(link), itemLower, 1, true) then
          return true
        end
      end
    end

    -- Check bags for substring match
    for bag = 0, 4 do
      local size = GetContainerNumSlots(bag)
      if size and size > 0 then
        for slotIndex = 1, size do
          local link = GetContainerItemLink(bag, slotIndex)
          if link then
            if string.find(string.lower(link), itemLower, 1, true) then
              return true
            end
          end
        end
      end
    end
  end

  return false
end

-- TODO: Look into https://github.com/Stanzilla/WoWUIBugs/issues/47 if needed
-- Hardened item cooldown resolver (Vanilla 1.12.1 / Lua 5.0)
-- Returns: remainingSeconds, totalDuration, enabled
-- PERFORMANCE: Uses CleveRoids.Items cache for O(1) lookup, with fallback for substring matches
function CleveRoids.GetItemCooldown(item)
  -- Helper to normalize cooldown values
  local function _norm(s, d, e)
    s = tonumber(s) or 0
    d = tonumber(d) or 0
    e = tonumber(e) or 0
    if d <= 0 or s <= 0 then
      return 0, 0, e
    end
    local rem = (s + d) - GetTime()
    if rem < 0 then rem = 0 end
    return rem, d, e
  end

  -- Fast path: check cache first (O(1) lookup)
  local remaining, duration, enable = CleveRoids.GetItemCooldownCached(item)
  if duration > 0 or remaining > 0 then
    return remaining, duration, enable
  end

  -- If cache found the item but cooldown is 0, that's a valid result
  local location = CleveRoids.FindItemLocation(item)
  if location then
    return 0, 0, enable or 0
  end

  -- Slow path fallback: only needed for substring matching on strings
  if type(item) == "string" and item ~= "" then
    local itemLower = string.lower(item)
    local start, dur, en

    -- Check equipped slots for substring match
    for slot = 0, 19 do
      local link = GetInventoryItemLink("player", slot)
      if link then
        if string.find(string.lower(link), itemLower, 1, true) then
          start, dur, en = GetInventoryItemCooldown("player", slot)
          return _norm(start, dur, en)
        end
      end
    end

    -- Check bags for substring match
    for bag = 0, 4 do
      local size = GetContainerNumSlots(bag)
      if size and size > 0 then
        for slotIndex = 1, size do
          local link = GetContainerItemLink(bag, slotIndex)
          if link then
            if string.find(string.lower(link), itemLower, 1, true) then
              start, dur, en = GetContainerItemCooldown(bag, slotIndex)
              return _norm(start, dur, en)
            end
          end
        end
      end
    end
  end

  -- Fallback: unknown item → no cooldown
  return 0, 0, 0
end

function CleveRoids.ValidatePlayerAuraCount(bigger, amount)
    -- Count player buffs by iterating all 32 slots
    -- (matches IsPlayerBuffCapped logic for consistency)
    local count = 0
    for i = 0, 31 do
        if GetPlayerBuffTexture(GetPlayerBuff(i, "HELPFUL")) then
            count = count + 1
        end
    end
    if bigger == 0 then
        return count < tonumber(amount)
    else
        return count > tonumber(amount)
    end
end

function CleveRoids.IsReactive(name)
    return CleveRoids.reactiveSpells[spellName] ~= nil
end

function CleveRoids.GetActionButtonInfo(slot)
    local macroName, actionType, id = GetActionText(slot)
    if actionType == "MACRO" then
        return actionType, id, macroName
    elseif actionType == "SPELL" and id then
        local spellName, rank = SpellInfo(id)
        return actionType, id, spellName, rank
    elseif actionType == "ITEM" and id then
        local item = CleveRoids.GetItem(id)
        return actionType, id, (item and item.name), (item and item.id)
    end
end

function CleveRoids.IsReactiveUsable(spellName)
    -- For Overpower, Revenge, and Riposte: ONLY use combat log tracking
    -- These spells have specific proc conditions tracked via combat log
    if spellName == "Overpower" or spellName == "Revenge" or spellName == "Riposte" then
        if CleveRoids.HasReactiveProc and CleveRoids.HasReactiveProc(spellName) then
            return 1
        else
            return nil
        end
    end

    -- For other reactive spells, use fallback methods
    -- Use Nampower's IsSpellUsable if available (more accurate)
    if IsSpellUsable then
        -- pcall to handle spells not in spellbook (Nampower throws error)
        local ok, usable, oom = pcall(IsSpellUsable, spellName)
        if ok then
            if usable == 1 and oom ~= 1 then
                return 1
            else
                return nil, oom
            end
        end
        -- If pcall failed, spell not in spellbook - fall through to action bar check
    end

    -- Fallback to action bar slot checking (requires correct stance)
    if not CleveRoids.reactiveSlots[spellName] then return false end
    local actionSlot = CleveRoids.reactiveSlots[spellName]
    local isUsable, oom = CleveRoids.Hooks.OriginalIsUsableAction(actionSlot)
    local start, duration = GetActionCooldown(actionSlot)
    if isUsable and (start == 0 or duration == 1.5) then -- 1.5 just means gcd is active
        return 1
    else
        return nil, oom
    end
end

-- Check if any spell is usable (not just reactive)
function CleveRoids.CheckSpellUsable(spellName)
    if not spellName then return false end

    -- Use Nampower's IsSpellUsable if available
    if IsSpellUsable then
        -- pcall to handle spells not in spellbook (Nampower throws error)
        local ok, usable, oom = pcall(IsSpellUsable, spellName)
        if ok then
            return (usable == 1 and oom ~= 1)
        end
        -- If pcall failed, spell not in spellbook - fall through to fallback
    end

    -- Fallback: check if spell exists and player has mana/rage/energy
    local spell = CleveRoids.GetSpell(spellName)
    if not spell then return false end

    -- Check mana cost
    local currentPower = UnitMana("player")
    if spell.cost and currentPower < spell.cost then
        return false
    end

    -- Check cooldown (ignore GCD)
    local start, duration = GetSpellCooldown(spell.spellSlot, spell.bookType)
    if start > 0 and duration > 1.5 then
        return false
    end

    return true
end

function CleveRoids.CheckSpellCast(unit, spell)
    local spell = spell or ""
    local _,guid = UnitExists(unit)
    if not guid then return false end

    -- BUGFIX: Special handling for player unit - check CurrentSpell.type
    -- This is event-driven and more reliable than spell_tracking for the player
    if unit == "player" then
        -- Check if player is casting or channeling
        if CleveRoids.CurrentSpell and CleveRoids.CurrentSpell.type ~= "" then
            -- If checking for any spell, return true
            if spell == "" then
                return true
            end
            -- If checking for specific spell, compare spell names
            -- Note: CurrentSpell.spellName may not be set, so also check spell_tracking as fallback
            if CleveRoids.CurrentSpell.spellName and CleveRoids.CurrentSpell.spellName == spell then
                return true
            end
        end
        -- Fallback to spell_tracking for player if CurrentSpell doesn't have the info
    end

    -- For non-player units or as fallback, use spell_tracking
    if not CleveRoids.hasSuperwow then return false end

    if not CleveRoids.spell_tracking[guid] then
        return false
    else
        -- are we casting a specific spell, or any spell
        if spell == SpellInfo(CleveRoids.spell_tracking[guid].spell_id) or (spell == "") then
            return true
        end
        return false
    end
end

-- ============================================================================
-- CC (Crowd Control) Mechanic Detection
-- Uses BuffLib if available, otherwise uses built-in spell database
-- ============================================================================

-- Maps CC type names to mechanic constants (matches DBC mechanic IDs)
-- Note: Some types map to multiple mechanics via CCMechanicGroups below
CleveRoids.CCMechanics = {
    -- Movement/control impairment
    charm       = 1,   -- Mind Control, Seduction
    disoriented = 2,   -- Scatter Shot, Blind (disorient component)
    disorient   = 2,   -- Alias for disoriented
    disarm      = 3,   -- Disarm, Riposte disarm
    distract    = 4,   -- Distract (Rogue ability)
    fear        = 5,   -- Fear, Psychic Scream, Howl of Terror
    grip        = 6,   -- Grip effects
    root        = 7,   -- Entangling Roots, Frost Nova, Improved Hamstring
    pacify      = 8,   -- Pacify effects
    silence     = 9,   -- Silence, Kick, Counterspell (lockout)
    sleep       = 10,  -- Hibernate, Wyvern Sting sleep
    snare       = 11,  -- Hamstring, Wing Clip, Crippling Poison
    slow        = 11,  -- Alias for snare
    stun        = 12,  -- Consolidated: Stun(12) + Knockout(14) + Sap(30)
    freeze      = 13,  -- Freeze effects (Frost Nova freeze)
    bleed       = 15,  -- Rend, Garrote, Deep Wounds
    polymorph   = 17,  -- Polymorph (all variants)
    banish      = 18,  -- Banish (Warlock)
    shackle     = 20,  -- Shackle Undead
    horror      = 24,  -- Death Coil (Warlock), Intimidating Shout (horror)
    daze        = 27,  -- Dazed effects
}

-- Mechanic groups: CC types that check multiple DBC mechanics
-- Used when a single conditional should match several related effects
CleveRoids.CCMechanicGroups = {
    stun = {12, 14, 30},  -- Stun(12), Knockout/Gouge(14), Sap(30)
}

-- CC types that count as "crowd controlled" (loss of control)
-- Note: Mechanics 12, 14, 30 are all consolidated under "stun" for conditionals
CleveRoids.CCTypesLossOfControl = {
    [1] = true,   -- charm
    [2] = true,   -- disoriented
    [5] = true,   -- fear
    [10] = true,  -- sleep
    [12] = true,  -- stun (Cheap Shot, Kidney Shot, etc.)
    [13] = true,  -- freeze
    [14] = true,  -- knockout/gouge (now part of stun group)
    [17] = true,  -- polymorph
    [18] = true,  -- banish
    [20] = true,  -- shackle
    [24] = true,  -- horror
    [30] = true,  -- sap (now part of stun group)
}

-- Complete spell ID to mechanic mapping from DBC data
-- Extracted from BuffLib SpellData - 785 spells with mechanics
-- Mechanic IDs: 1=Charm, 2=Disorient, 3=Disarm, 5=Fear, 7=Root, 9=Silence,
--               10=Sleep, 11=Snare, 12=Stun, 13=Freeze, 14=Knockout,
--               15=Bleed, 17=Polymorph, 18=Banish, 20=Shackle, 21=Mount,
--               23=Turn, 24=Horror, 25=Invuln, 27=Daze
CleveRoids.CCSpellMechanics = {
    [17] = 19, [56] = 12, [89] = 11, [113] = 7, [118] = 17, [228] = 17,
    [246] = 11, [339] = 7, [408] = 12, [451] = 9, [458] = 21, [459] = 21,
    [468] = 21, [470] = 21, [471] = 21, [472] = 21, [474] = 6, [498] = 25,
    [507] = 6, [512] = 7, [578] = 21, [579] = 21, [580] = 21, [581] = 21,
    [592] = 19, [593] = 6, [600] = 19, [605] = 1, [642] = 25, [676] = 3,
    [700] = 10, [703] = 15, [710] = 18, [745] = 7, [746] = 16, [771] = 1,
    [772] = 15, [835] = 12, [851] = 17, [853] = 12, [861] = 9, [867] = 6,
    [998] = 6, [1020] = 25, [1022] = 25, [1062] = 7, [1079] = 15, [1090] = 10,
    [1098] = 1, [1159] = 16, [1513] = 5, [1776] = 14, [1777] = 14, [1833] = 12,
    [1943] = 15, [2070] = 14, [2094] = 2, [2637] = 10, [2878] = 23, [2880] = 12,
    [2937] = 10, [3109] = 5, [3143] = 12, [3147] = 15, [3242] = 12, [3263] = 12,
    [3267] = 16, [3268] = 16, [3355] = 13, [3363] = 21, [3409] = 11, [3410] = 11,
    [3446] = 12, [3542] = 7, [3551] = 12, [3589] = 9, [3600] = 11, [3604] = 11,
    [3609] = 12, [3635] = 12, [3636] = 10, [3747] = 19, [4060] = 17, [4064] = 12,
    [4065] = 12, [4066] = 12, [4067] = 12, [4068] = 12, [4069] = 12, [4102] = 15,
    [4244] = 15, [4962] = 7, [5106] = 12, [5116] = 11, [5134] = 5, [5159] = 11,
    [5164] = 12, [5195] = 7, [5196] = 7, [5211] = 12, [5246] = 5, [5259] = 3,
    [5276] = 12, [5376] = 4, [5403] = 12, [5484] = 5, [5530] = 12, [5531] = 12,
    [5567] = 7, [5573] = 25, [5588] = 12, [5589] = 12, [5597] = 15, [5598] = 15,
    [5599] = 25, [5627] = 23, [5648] = 12, [5649] = 12, [5703] = 12, [5708] = 12,
    [5782] = 5, [5784] = 21, [5917] = 6, [5918] = 12, [6065] = 19, [6066] = 19,
    [6136] = 11, [6146] = 11, [6213] = 5, [6215] = 5, [6253] = 12, [6266] = 12,
    [6304] = 12, [6358] = 1, [6388] = 11, [6409] = 12, [6435] = 12, [6466] = 12,
    [6524] = 12, [6533] = 7, [6546] = 15, [6547] = 15, [6548] = 15, [6605] = 5,
    [6607] = 12, [6608] = 3, [6648] = 21, [6653] = 21, [6654] = 21, [6713] = 3,
    [6726] = 9, [6728] = 12, [6730] = 12, [6749] = 12, [6770] = 14, [6777] = 21,
    [6788] = 19, [6798] = 12, [6896] = 21, [6897] = 21, [6898] = 21, [6899] = 21,
    [6927] = 12, [6942] = 9, [6945] = 12, [6982] = 12, [6984] = 11, [6985] = 11,
    [7074] = 9, [7093] = 5, [7139] = 12, [7279] = 11, [7321] = 11, [7399] = 5,
    [7645] = 1, [7803] = 12, [7922] = 12, [7926] = 16, [7927] = 16, [7964] = 12,
    [7967] = 10, [7992] = 11, [8040] = 10, [8122] = 5, [8124] = 5, [8142] = 7,
    [8150] = 12, [8208] = 12, [8225] = 5, [8242] = 12, [8281] = 9, [8285] = 12,
    [8312] = 7, [8346] = 7, [8377] = 7, [8379] = 3, [8391] = 12, [8394] = 21,
    [8395] = 21, [8396] = 21, [8399] = 10, [8629] = 14, [8631] = 15, [8632] = 15,
    [8633] = 15, [8639] = 15, [8640] = 15, [8643] = 12, [8646] = 12, [8715] = 5,
    [8716] = 11, [8818] = 15, [8901] = 10, [8902] = 10, [8980] = 21, [8983] = 12,
    [8988] = 9, [8994] = 18, [9005] = 12, [9007] = 15, [9080] = 11, [9159] = 10,
    [9484] = 20, [9485] = 20, [9552] = 9, [9823] = 12, [9824] = 15, [9826] = 15,
    [9827] = 12, [9852] = 7, [9853] = 7, [9896] = 15, [9915] = 7, [10017] = 7,
    [10234] = 10, [10253] = 17, [10266] = 15, [10278] = 25, [10308] = 12,
    [10326] = 23, [10787] = 21, [10788] = 21, [10789] = 21, [10790] = 21,
    [10792] = 21, [10793] = 21, [10795] = 21, [10796] = 21, [10798] = 21,
    [10799] = 21, [10800] = 21, [10801] = 21, [10802] = 21, [10803] = 21,
    [10804] = 21, [10838] = 16, [10839] = 16, [10851] = 3, [10852] = 7,
    [10855] = 11, [10856] = 12, [10873] = 21, [10888] = 5, [10890] = 5,
    [10898] = 19, [10899] = 19, [10900] = 19, [10901] = 19, [10911] = 1,
    [10912] = 1, [10955] = 20, [10969] = 21, [10987] = 11, [11020] = 12,
    [11201] = 11, [11264] = 7, [11273] = 15, [11274] = 15, [11275] = 15,
    [11285] = 14, [11286] = 14, [11289] = 15, [11290] = 15, [11297] = 14,
    [11428] = 12, [11430] = 12, [11436] = 11, [11446] = 1, [11572] = 15,
    [11573] = 15, [11574] = 15, [11578] = 12, [11579] = 12, [11641] = 17, [11650] = 12, [11725] = 1,
    [11726] = 1, [11820] = 7, [11831] = 7, [11836] = 12, [11876] = 12,
    [11879] = 3, [11922] = 7, [11958] = 13, [11977] = 15, [12023] = 7,
    [12024] = 7, [12054] = 15, [12096] = 5, [12098] = 10, [12252] = 7,
    [12323] = 11, [12355] = 12, [12421] = 12, [12461] = 12, [12484] = 11,
    [12485] = 11, [12486] = 11, [12494] = 7, [12528] = 9, [12531] = 11,
    [12540] = 14, [12542] = 5, [12543] = 12, [12551] = 11, [12562] = 12,
    [12674] = 7, [12705] = 11, [12721] = 15, [12730] = 5, [12734] = 12,
    [12747] = 7, [12748] = 7, [12798] = 12, [12809] = 12, [12824] = 17,
    [12825] = 17, [12826] = 17, [12946] = 9, [13005] = 12, [13099] = 7,
    [13119] = 7, [13138] = 7, [13181] = 1, [13237] = 12, [13318] = 15,
    [13323] = 17, [13327] = 14, [13443] = 15, [13445] = 15, [13534] = 3,
    [13579] = 14, [13608] = 7, [13704] = 5, [13738] = 15, [13747] = 11,
    [13808] = 12, [13810] = 11, [13819] = 21, [13902] = 12, [14030] = 7,
    [14087] = 15, [14100] = 5, [14102] = 12, [14118] = 15, [14180] = 3,
    [14207] = 11, [14308] = 13, [14309] = 13, [14326] = 5, [14327] = 5,
    [14331] = 15, [14515] = 1, [14621] = 17, [14874] = 15, [14897] = 11,
    [14902] = 12, [14903] = 15, [14907] = 7, [15063] = 7, [15091] = 14,
    [15269] = 12, [15283] = 12, [15398] = 12, [15471] = 7, [15474] = 7,
    [15487] = 9, [15531] = 7, [15532] = 7, [15534] = 17, [15535] = 12,
    [15583] = 15, [15593] = 12, [15609] = 7, [15618] = 12, [15621] = 12,
    [15652] = 12, [15655] = 12, [15744] = 14, [15752] = 3, [15753] = 12,
    [15779] = 21, [15780] = 21, [15781] = 21, [15822] = 10, [15859] = 1,
    [15878] = 12, [15970] = 10, [15976] = 15, [16045] = 18, [16046] = 14,
    [16050] = 11, [16053] = 1, [16055] = 21, [16056] = 21, [16058] = 21,
    [16059] = 21, [16060] = 21, [16075] = 12, [16080] = 21, [16081] = 21,
    [16082] = 21, [16083] = 21, [16084] = 21, [16095] = 15, [16096] = 5,
    [16097] = 17, [16104] = 12, [16350] = 12, [16393] = 15, [16403] = 15,
    [16406] = 15, [16451] = 18, [16469] = 7, [16497] = 12, [16508] = 5,
    [16509] = 15, [16566] = 7, [16568] = 11, [16600] = 12, [16707] = 17,
    [16708] = 17, [16709] = 17, [16727] = 12, [16790] = 12, [16798] = 10,
    [16803] = 12, [16838] = 9, [16869] = 12, [16922] = 12, [17011] = 12,
    [17145] = 14, [17153] = 15, [17165] = 11, [17172] = 17, [17174] = 11,
    [17229] = 21, [17276] = 12, [17277] = 14, [17286] = 12, [17293] = 12,
    [17308] = 12, [17405] = 1, [17450] = 21, [17453] = 21, [17454] = 21,
    [17455] = 21, [17456] = 21, [17458] = 21, [17459] = 21, [17460] = 21,
    [17461] = 21, [17462] = 21, [17463] = 21, [17464] = 21, [17465] = 21,
    [17481] = 21, [17500] = 12, [17504] = 15, [17738] = 17, [17928] = 5,
    [18075] = 15, [18078] = 15, [18093] = 12, [18103] = 12, [18106] = 15,
    [18118] = 11, [18144] = 12, [18200] = 15, [18202] = 15, [18223] = 11,
    [18278] = 9, [18327] = 9, [18328] = 11, [18363] = 21, [18395] = 12,
    [18425] = 9, [18431] = 5, [18469] = 9, [18498] = 9, [18503] = 17,
    [18608] = 16, [18610] = 16, [18647] = 18, [18657] = 10, [18658] = 10,
    [18763] = 12, [18802] = 11, [18812] = 12, [18972] = 11, [18989] = 21,
    [18990] = 21, [18991] = 21, [18992] = 21, [19128] = 12, [19134] = 5,
    [19136] = 12, [19137] = 11, [19185] = 7, [19229] = 7, [19364] = 12,
    [19386] = 10, [19393] = 9, [19408] = 5, [19410] = 12, [19469] = 1,
    [19482] = 12, [19496] = 11, [19501] = 2, [19503] = 2, [19641] = 12,
    [19718] = 3, [19769] = 12, [19771] = 15, [19780] = 12, [19784] = 12,
    [19821] = 9, [19970] = 7, [19971] = 7, [19972] = 7, [19973] = 7,
    [19974] = 7, [19975] = 7, [20066] = 14, [20170] = 12, [20253] = 12,
    [20276] = 12, [20277] = 12, [20310] = 12, [20511] = 5, [20549] = 12,
    [20604] = 1, [20614] = 12, [20615] = 12, [20654] = 7, [20663] = 10,
    [20669] = 10, [20683] = 12, [20685] = 12, [20699] = 7, [20706] = 19,
    [20740] = 1, [20882] = 1, [20907] = 15, [20908] = 15, [20989] = 10,
    [21099] = 12, [21152] = 12, [21330] = 5, [21331] = 7, [21748] = 12,
    [21749] = 12, [21869] = 5, [21898] = 5, [21949] = 15, [21990] = 12,
    [22127] = 7, [22274] = 17, [22289] = 12, [22356] = 11, [22415] = 7,
    [22419] = 3, [22424] = 14, [22427] = 12, [22519] = 7, [22566] = 17,
    [22570] = 14, [22592] = 12, [22639] = 11, [22645] = 7, [22666] = 9,
    [22678] = 5, [22686] = 5, [22691] = 3, [22692] = 12, [22717] = 21,
    [22718] = 21, [22719] = 21, [22720] = 21, [22721] = 21, [22722] = 21,
    [22723] = 21, [22724] = 21, [22744] = 7, [22752] = 19, [22800] = 7,
    [22884] = 5, [22914] = 11, [22915] = 12, [22919] = 11, [22924] = 7,
    [22994] = 7, [23039] = 14, [23103] = 12, [23113] = 14, [23161] = 21,
    [23207] = 9, [23214] = 21, [23219] = 21, [23220] = 21, [23221] = 21,
    [23222] = 21, [23223] = 21, [23225] = 21, [23227] = 21, [23228] = 21,
    [23229] = 21, [23238] = 21, [23239] = 21, [23240] = 21, [23241] = 21,
    [23242] = 21, [23243] = 21, [23246] = 21, [23247] = 21, [23248] = 21,
    [23249] = 21, [23250] = 21, [23251] = 21, [23252] = 21, [23275] = 5,
    [23338] = 21, [23364] = 12, [23365] = 3, [23454] = 12, [23509] = 21,
    [23510] = 21, [23567] = 16, [23568] = 16, [23569] = 16, [23600] = 11,
    [23603] = 17, [23618] = 12, [23694] = 7, [23696] = 16, [23918] = 9,
    [23919] = 12, [23953] = 11, [24004] = 10, [24053] = 17, [24110] = 7,
    [24118] = 15, [24119] = 15, [24120] = 15, [24132] = 10, [24133] = 10,
    [24152] = 7, [24192] = 15, [24213] = 12, [24225] = 11, [24242] = 21,
    [24252] = 21, [24259] = 9, [24327] = 1, [24331] = 15, [24332] = 15,
    [24333] = 12, [24335] = 10, [24360] = 10, [24375] = 12, [24394] = 12,
    [24412] = 16, [24413] = 16, [24414] = 16, [24415] = 11, [24576] = 21,
    [24600] = 12, [24648] = 7, [24664] = 10, [24671] = 12, [24687] = 9,
    [24698] = 14, [24712] = 17, [24713] = 17, [24735] = 17, [24736] = 17,
    [24778] = 10, [25022] = 11, [25049] = 14, [25056] = 12, [25057] = 3,
    [25187] = 11, [25189] = 12, [25260] = 5, [25654] = 12, [25655] = 3,
    [25675] = 21, [25771] = 25, [25809] = 11, [25815] = 5, [25852] = 12,
    [25858] = 21, [25859] = 21, [25863] = 21, [25953] = 21, [25999] = 7,
    [26042] = 5, [26054] = 21, [26055] = 21, [26056] = 21, [26069] = 9,
    [26070] = 5, [26071] = 7, [26078] = 11, [26108] = 2, [26141] = 11,
    [26143] = 11, [26157] = 17, [26180] = 10, [26211] = 11, [26272] = 17,
    [26273] = 17, [26274] = 17, [26379] = 11, [26580] = 5, [26641] = 5,
    [26655] = 21, [26740] = 1, [27555] = 15, [27556] = 15, [27559] = 9,
    [27565] = 18, [27581] = 3, [27607] = 19, [27610] = 5, [27615] = 12,
    [27619] = 13, [27634] = 11, [27638] = 15, [27640] = 11, [27641] = 5,
    [27758] = 12, [27760] = 17, [27880] = 12, [27990] = 5, [27993] = 11,
    [28270] = 17, [28271] = 17, [28272] = 17, [28314] = 12, [28315] = 5,
    [28445] = 12, [28456] = 14, [28725] = 12, [28858] = 7, [28911] = 15,
    [28913] = 15, [28991] = 7, [29059] = 21, [29168] = 5, [29407] = 11,
    [29419] = 5, [29544] = 5, [29685] = 5, [29848] = 17, [29849] = 7,
    [29915] = 15, [29943] = 9, [30001] = 5, [30002] = 5, [30020] = 16,
    [30094] = 7, [30174] = 21, [30225] = 9, [30285] = 15, [31365] = 5,
    [31700] = 21,
}

-- Check if BuffLib is available with full mechanic support
function CleveRoids.HasBuffLib()
    -- Defensive: ensure BuffLib.SpellData is a table, not a function
    return BuffLib and BuffLib.GetUnitDebuffsByMechanic
        and type(BuffLib.SpellData) == "table"
        and BuffLib.SpellData.GetMechanic
end

-- Get mechanic for a spell ID (uses BuffLib if available, otherwise built-in table)
function CleveRoids.GetSpellMechanic(spellID)
    if not spellID or spellID <= 0 then return 0 end

    -- Try BuffLib first (has complete DBC data)
    -- Defensive: verify SpellData is a table before indexing
    if BuffLib and type(BuffLib.SpellData) == "table" and BuffLib.SpellData.GetMechanic then
        local mechanic = BuffLib.SpellData:GetMechanic(spellID)
        if mechanic and mechanic > 0 then
            return mechanic
        end
    end

    -- Fall back to built-in table
    return CleveRoids.CCSpellMechanics[spellID] or 0
end

-- Validate CC on a unit (target, focus, player, etc.)
-- Returns true if the unit has the specified CC mechanic active
function CleveRoids.ValidateUnitCC(unit, ccType)
    if not unit or not UnitExists(unit) then return false end

    local ccTypeLower = string.lower(ccType or "")

    -- Special case: "cc" means any loss-of-control effect
    if ccTypeLower == "cc" or ccTypeLower == "any" then
        return CleveRoids.ValidateUnitAnyCrowdControl(unit)
    end

    -- Check if this CC type maps to a group of mechanics
    local mechanicGroup = CleveRoids.CCMechanicGroups[ccTypeLower]
    if mechanicGroup then
        -- Check all mechanics in the group (e.g., stun checks 12, 14, 30)
        for _, mechanic in ipairs(mechanicGroup) do
            if CleveRoids.ValidateUnitCCSingleMechanic(unit, mechanic) then
                return true
            end
        end
        return false
    end

    -- Single mechanic lookup
    local mechanic = CleveRoids.CCMechanics[ccTypeLower]
    if not mechanic then return false end

    return CleveRoids.ValidateUnitCCSingleMechanic(unit, mechanic)
end

-- Validate a single CC mechanic on a unit (helper function)
function CleveRoids.ValidateUnitCCSingleMechanic(unit, mechanic)
    -- Use BuffLib if available (most accurate - tracks overflow debuffs and hidden auras)
    if CleveRoids.HasBuffLib() then
        local _, guid = UnitExists(unit)
        if not guid then return false end

        if unit == "player" then
            return BuffLib:HasDebuffOfMechanic(mechanic)
        else
            local debuffs = BuffLib:GetUnitDebuffsByMechanic(guid, mechanic)
            return debuffs and table.getn(debuffs) > 0
        end
    end

    -- Fallback: scan unit debuffs directly
    return CleveRoids.ValidateUnitCCDirect(unit, mechanic)
end

-- Check if unit has any crowd control (loss of control) effect
function CleveRoids.ValidateUnitAnyCrowdControl(unit)
    if not unit or not UnitExists(unit) then return false end

    -- Use BuffLib if available
    if CleveRoids.HasBuffLib() then
        local _, guid = UnitExists(unit)
        if not guid then return false end

        if unit == "player" then
            for mechanic, _ in pairs(CleveRoids.CCTypesLossOfControl) do
                if BuffLib:HasDebuffOfMechanic(mechanic) then
                    return true
                end
            end
        else
            for mechanic, _ in pairs(CleveRoids.CCTypesLossOfControl) do
                local debuffs = BuffLib:GetUnitDebuffsByMechanic(guid, mechanic)
                if debuffs and table.getn(debuffs) > 0 then
                    return true
                end
            end
        end
        return false
    end

    -- Fallback: check all loss-of-control mechanics directly
    for mechanic, _ in pairs(CleveRoids.CCTypesLossOfControl) do
        if CleveRoids.ValidateUnitCCDirect(unit, mechanic) then
            return true
        end
    end
    return false
end

-- Direct CC check - scans unit debuffs using SuperWoW API
-- Works without BuffLib by using built-in spell mechanic table
function CleveRoids.ValidateUnitCCDirect(unit, mechanic)
    if not CleveRoids.hasSuperwow then return false end

    -- Players only have 16 debuff slots, no overflow
    -- Non-player units can have overflow debuffs in buff slots (17-48)
    local isPlayer = (unit == "player")
    local maxDebuffSlots = 16
    local maxOverflowSlots = isPlayer and 0 or 32

    -- Scan regular debuff slots (1-16)
    for i = 1, maxDebuffSlots do
        local texture, stacks, debuffType, spellID = UnitDebuff(unit, i)
        if not texture then break end

        if spellID and spellID > 0 then
            local spellMechanic = CleveRoids.GetSpellMechanic(spellID)
            if spellMechanic == mechanic then
                return true
            end
        end
    end

    -- Scan overflow slots in buff bar (non-player units only)
    if maxOverflowSlots > 0 then
        for i = 1, maxOverflowSlots do
            local texture, stacks, spellID = UnitBuff(unit, i)
            if not texture then break end

            if spellID and spellID > 0 then
                local spellMechanic = CleveRoids.GetSpellMechanic(spellID)
                if spellMechanic == mechanic then
                    return true
                end
            end
        end
    end

    return false
end

-- A list of Conditionals and their functions to validate them
CleveRoids.Keywords = {
    exists = function(conditionals)
        return UnitExists(conditionals.target)
    end,

    noexists = function(conditionals)
        return not UnitExists(conditionals.target)
    end,

    -- Check if player has NO current target (target frame is empty)
    -- Different from noexists: notarget checks player's target, noexists checks @unit
    -- Usage: /target [notarget,@mouseover] - target mouseover only if no current target
    notarget = function(conditionals)
        return not UnitExists("target")
    end,

    -- Check if player HAS a current target (target frame is occupied)
    -- Usage: /cast [hastarget] Spell - only cast if player has a target selected
    hastarget = function(conditionals)
        return UnitExists("target")
    end,

    help = function(conditionals)
        return conditionals.help and conditionals.target and UnitExists(conditionals.target) and UnitCanAssist("player", conditionals.target)
    end,

    -- [nohelp] - Target is NOT friendly (cannot assist)
    nohelp = function(conditionals)
        if not conditionals.target or not UnitExists(conditionals.target) then
            return true
        end
        return not UnitCanAssist("player", conditionals.target)
    end,

    harm = function(conditionals)
        return conditionals.harm and conditionals.target and UnitExists(conditionals.target) and UnitCanAttack("player", conditionals.target)
    end,

    -- [noharm] - Target is NOT hostile (cannot attack)
    noharm = function(conditionals)
        if not conditionals.target or not UnitExists(conditionals.target) then
            return true
        end
        return not UnitCanAttack("player", conditionals.target)
    end,

    stance = function(conditionals)
        local i = CleveRoids.GetCurrentShapeshiftIndex()
        -- PERFORMANCE: Use specialized function to avoid closure allocation
        return OrEqualsNumber(conditionals.stance, i)
    end,

    nostance = function(conditionals)
        local i = CleveRoids.GetCurrentShapeshiftIndex()
        local forbiddenStances = conditionals.nostance
        if type(forbiddenStances) ~= "table" then
            return i == 0
        end
        -- PERFORMANCE: Use specialized function to avoid closure allocation
        return AndNotEqualsNumber(forbiddenStances, i)
    end,

    noform = function(conditionals)
        local i = CleveRoids.GetCurrentShapeshiftIndex()
        local forbiddenForms = conditionals.noform
        if type(forbiddenForms) ~= "table" then
            return i == 0
        end
        -- PERFORMANCE: Use specialized function to avoid closure allocation
        return AndNotEqualsNumber(forbiddenForms, i)
    end,

    form = function(conditionals)
        local i = CleveRoids.GetCurrentShapeshiftIndex()
        -- PERFORMANCE: Use specialized function to avoid closure allocation
        return OrEqualsNumber(conditionals.form, i)
    end,

    mod = function(conditionals)
        if type(conditionals.mod) ~= "table" then
            return CleveRoids.kmods.mod()
        end
        return Multi(conditionals.mod, function(mod)
            return CleveRoids.kmods[mod]()
        end, conditionals, "mod")
    end,

    nomod = function(conditionals)
        if type(conditionals.nomod) ~= "table" then
            return CleveRoids.kmods.nomod()
        end
        return NegatedMulti(conditionals.nomod, function(mod)
            return not CleveRoids.kmods[mod]()
        end, conditionals, "nomod")
    end,

    target = function(conditionals)
        return CleveRoids.IsValidTarget(conditionals.target, conditionals.help)
    end,

    combat = function(conditionals)
        -- Check if an argument like :target or :focus was provided. The parser turns this into a table.
        if type(conditionals.combat) == "table" then
            -- If so, run the check on the provided unit(s).
            return Multi(conditionals.combat, function(unit)
                return UnitExists(unit) and UnitAffectingCombat(unit)
            end, conditionals, "combat")
        else
            -- Otherwise, this is a bare [combat]. The value might be 'true' or a spell name.
            -- PERFORMANCE: Use event-driven cache for player combat state
            local cached = CleveRoids._cachedPlayerInCombat
            if cached ~= nil then
                return cached
            end
            -- Fallback if cache not yet initialized
            return UnitAffectingCombat("player")
        end
    end,

    nocombat = function(conditionals)
        -- Check if an argument like :target or :focus was provided.
        if type(conditionals.nocombat) == "table" then
            -- If so, run the check on the provided unit(s).
            return NegatedMulti(conditionals.nocombat, function(unit)
                if not UnitExists(unit) then
                    return true
                end
                return not UnitAffectingCombat(unit)
            end, conditionals, "nocombat")
        else
            -- Otherwise, this is a bare [nocombat]. Default to checking the player.
            -- PERFORMANCE: Use event-driven cache for player combat state
            local cached = CleveRoids._cachedPlayerInCombat
            if cached ~= nil then
                return not cached
            end
            -- Fallback if cache not yet initialized
            return not UnitAffectingCombat("player")
        end
    end,

    stealth = function(conditionals)
        return (
            (CleveRoids.playerClass == "ROGUE" and CleveRoids.ValidatePlayerBuff(CleveRoids.Localized.Spells["Stealth"]))
            or (CleveRoids.playerClass == "DRUID" and CleveRoids.ValidatePlayerBuff(CleveRoids.Localized.Spells["Prowl"]))
        )
    end,

    nostealth = function(conditionals)
        return (
            (CleveRoids.playerClass == "ROGUE" and not CleveRoids.ValidatePlayerBuff(CleveRoids.Localized.Spells["Stealth"]))
            or (CleveRoids.playerClass == "DRUID" and not CleveRoids.ValidatePlayerBuff(CleveRoids.Localized.Spells["Prowl"]))
        )
    end,

    casting = function(conditionals)
        if type(conditionals.casting) ~= "table" then return CleveRoids.CheckSpellCast(conditionals.target, "") end
        return Or(conditionals.casting, function (spell)
            return CleveRoids.CheckSpellCast(conditionals.target, spell)
        end)
    end,

    nocasting = function(conditionals)
        if type(conditionals.nocasting) ~= "table" then return not CleveRoids.CheckSpellCast(conditionals.target, "") end
        return NegatedMulti(conditionals.nocasting, function (spell)
            return not CleveRoids.CheckSpellCast(conditionals.target, spell)
        end, conditionals, "nocasting")
    end,

    -- NEW: Direct player casting check with time-based prediction
    -- Uses our accurate state tracking instead of GetCurrentCastingInfo polling
    selfcasting = function(conditionals)
        -- Check for cast with time-based prediction
        if CleveRoids.CurrentSpell.type == "cast" and CleveRoids.castStartTime and CleveRoids.castDuration then
            local remaining = CleveRoids.castDuration - (GetTime() - CleveRoids.castStartTime)
            if remaining <= 0.1 then
                return false -- Cast is done
            end
        end

        -- Check for channel with time-based prediction
        if CleveRoids.CurrentSpell.type == "channeled" and CleveRoids.channelStartTime and CleveRoids.channelDuration then
            local remaining = CleveRoids.channelDuration - (GetTime() - CleveRoids.channelStartTime)
            if remaining <= 0.1 then
                return false -- Channel is done
            end
        end

        return CleveRoids.CurrentSpell.type == "cast" or CleveRoids.CurrentSpell.type == "channeled"
    end,

    noselfcasting = function(conditionals)
        -- Inverse of selfcasting with same prediction logic
        if CleveRoids.CurrentSpell.type == "cast" and CleveRoids.castStartTime and CleveRoids.castDuration then
            local remaining = CleveRoids.castDuration - (GetTime() - CleveRoids.castStartTime)
            if remaining <= 0.1 then
                return true -- Cast is done
            end
        end

        if CleveRoids.CurrentSpell.type == "channeled" and CleveRoids.channelStartTime and CleveRoids.channelDuration then
            local remaining = CleveRoids.channelDuration - (GetTime() - CleveRoids.channelStartTime)
            if remaining <= 0.1 then
                return true -- Channel is done
            end
        end

        return CleveRoids.CurrentSpell.type ~= "cast" and CleveRoids.CurrentSpell.type ~= "channeled"
    end,

    zone = function(conditionals)
        local zone = GetRealZoneText()
        local sub_zone = GetSubZoneText()
        return Or(conditionals.zone, function (v)
            return (sub_zone ~= "" and (v == sub_zone) or (v == zone))
        end)
    end,

    nozone = function(conditionals)
        local zone = GetRealZoneText()
        local sub_zone = GetSubZoneText()
        return NegatedMulti(conditionals.nozone, function (v)
            return not ((sub_zone ~= "" and v == sub_zone)) or (v == zone)
        end, conditionals, "nozone")
    end,

    equipped = function(conditionals)
        local itemsToCheck = {}

        -- Case 1: conditionals.equipped is a string (e.g., [equipped]ItemName)
        if type(conditionals.equipped) == "string" then
            table.insert(itemsToCheck, conditionals.equipped)
        -- Case 2: conditionals.equipped is a table (e.g., [equipped:Shields])
        elseif type(conditionals.equipped) == "table" and table.getn(conditionals.equipped) > 0 then
            itemsToCheck = conditionals.equipped
        -- Case 3: No value provided, check the action
        elseif conditionals.action then
            table.insert(itemsToCheck, conditionals.action)
        else
            return false
        end

        -- Check all items
        return Or(itemsToCheck, function(v)
            return (CleveRoids.HasWeaponEquipped(v) or CleveRoids.HasGearEquipped(v))
        end)
    end,

    noequipped = function(conditionals)
        local itemsToCheck = {}

        -- Case 1: conditionals.noequipped is a string (e.g., [noequipped]ItemName)
        if type(conditionals.noequipped) == "string" then
            table.insert(itemsToCheck, conditionals.noequipped)
        -- Case 2: conditionals.noequipped is a table (e.g., [noequipped:Shields])
        elseif type(conditionals.noequipped) == "table" and table.getn(conditionals.noequipped) > 0 then
            itemsToCheck = conditionals.noequipped
        -- Case 3: No value provided, check the action
        elseif conditionals.action then
            table.insert(itemsToCheck, conditionals.action)
        else
            return false
        end

        -- Check all items - ALL must be NOT equipped for this to pass
        return And(itemsToCheck, function(v)
            return not (CleveRoids.HasWeaponEquipped(v) or CleveRoids.HasGearEquipped(v))
        end)
    end,

    dead = function(conditionals)
        if not conditionals.target then return false end
        return UnitIsDeadOrGhost(conditionals.target)
    end,

    alive = function(conditionals)
        if not conditionals.target then return false end
        return not UnitIsDeadOrGhost(conditionals.target)
    end,

    noalive = function(conditionals)
        if not conditionals.target then return false end
        return UnitIsDeadOrGhost(conditionals.target)
    end,

    nodead = function(conditionals)
        if not conditionals.target then return false end
        return not UnitIsDeadOrGhost(conditionals.target)
    end,

    reactive = function(conditionals)
        return Multi(conditionals.reactive, function (v)
            return CleveRoids.IsReactiveUsable(v)
        end, conditionals, "reactive")
    end,

    noreactive = function(conditionals)
        return NegatedMulti(conditionals.noreactive, function (v)
            return not CleveRoids.IsReactiveUsable(v)
        end, conditionals, "noreactive")
    end,

    usable = function(conditionals)
        return Multi(conditionals.usable, function(name)
            -- If checking a reactive spell, use reactive logic
            if CleveRoids.reactiveSpells[name] then
                return CleveRoids.IsReactiveUsable(name)
            end

            -- Check if it's a spell first
            local spell = CleveRoids.GetSpell(name)
            if spell then
                return CleveRoids.CheckSpellUsable(name)
            end

            -- Not a spell - check if it's an item or slot number
            local itemName = name
            local slotNum = tonumber(name)
            if slotNum and slotNum >= 1 and slotNum <= 19 then
                -- Resolve slot number to item name
                local link = GetInventoryItemLink("player", slotNum)
                if link then
                    local _, _, extractedName = string.find(link, "%[(.+)%]")
                    if extractedName then
                        itemName = extractedName
                    end
                end
            end

            -- Check if item exists in bags/equipped first
            if not CleveRoids.HasItem(itemName) then
                return false
            end

            -- Check item cooldown (0 remaining = usable)
            local remaining = CleveRoids.GetItemCooldown(itemName)
            return remaining == 0
        end, conditionals, "usable")
    end,

    nousable = function(conditionals)
        return NegatedMulti(conditionals.nousable, function(name)
            -- If checking a reactive spell, use reactive logic
            if CleveRoids.reactiveSpells[name] then
                return not CleveRoids.IsReactiveUsable(name)
            end

            -- Check if it's a spell first
            local spell = CleveRoids.GetSpell(name)
            if spell then
                return not CleveRoids.CheckSpellUsable(name)
            end

            -- Not a spell - check if it's an item or slot number
            local itemName = name
            local slotNum = tonumber(name)
            if slotNum and slotNum >= 1 and slotNum <= 19 then
                -- Resolve slot number to item name
                local link = GetInventoryItemLink("player", slotNum)
                if link then
                    local _, _, extractedName = string.find(link, "%[(.+)%]")
                    if extractedName then
                        itemName = extractedName
                    end
                end
            end

            -- Item not existing counts as "not usable"
            if not CleveRoids.HasItem(itemName) then
                return true
            end

            -- Check item cooldown (>0 remaining = not usable)
            local remaining = CleveRoids.GetItemCooldown(itemName)
            return remaining > 0
        end, conditionals, "nousable")
    end,

    member = function(conditionals)
        return Or(conditionals.member, function(v)
            return
                CleveRoids.IsTargetInGroupType(conditionals.target, "party")
                or CleveRoids.IsTargetInGroupType(conditionals.target, "raid")
        end)
    end,

    -- [nomember] - check if target is NOT in party or raid
    nomember = function(conditionals)
        return not (
            CleveRoids.IsTargetInGroupType(conditionals.target, "party")
            or CleveRoids.IsTargetInGroupType(conditionals.target, "raid")
        )
    end,

    -- [party] or [party:unitid] - check if unit is in your party
    -- Default unit is conditionals.target
    party = function(conditionals)
        local unit = conditionals.party
        if unit == true or unit == nil then
            unit = conditionals.target
        end
        return CleveRoids.IsTargetInGroupType(unit, "party")
    end,

    -- [noparty] or [noparty:unitid] - check if unit is NOT in your party
    noparty = function(conditionals)
        local unit = conditionals.noparty
        if unit == true or unit == nil then
            unit = conditionals.target
        end
        return not CleveRoids.IsTargetInGroupType(unit, "party")
    end,

    -- [raid] or [raid:unitid] - check if unit is in your raid
    -- Default unit is conditionals.target
    raid = function(conditionals)
        local unit = conditionals.raid
        if unit == true or unit == nil then
            unit = conditionals.target
        end
        return CleveRoids.IsTargetInGroupType(unit, "raid")
    end,

    -- [noraid] or [noraid:unitid] - check if unit is NOT in your raid
    noraid = function(conditionals)
        local unit = conditionals.noraid
        if unit == true or unit == nil then
            unit = conditionals.target
        end
        return not CleveRoids.IsTargetInGroupType(unit, "raid")
    end,

    -- [tag] - target is tapped (tagged) by anyone
    tag = function(conditionals)
        return conditionals.target and UnitIsTapped(conditionals.target)
    end,

    -- [notag] - target is not tapped
    notag = function(conditionals)
        return conditionals.target and not UnitIsTapped(conditionals.target)
    end,

    -- [mytag] - target is tapped by the player
    mytag = function(conditionals)
        return conditionals.target and UnitIsTappedByPlayer(conditionals.target)
    end,

    -- [nomytag] - target is not tapped by the player
    nomytag = function(conditionals)
        return conditionals.target and not UnitIsTappedByPlayer(conditionals.target)
    end,

    -- [othertag] - target is tapped by someone else (not the player)
    othertag = function(conditionals)
        return conditionals.target and UnitIsTapped(conditionals.target) and not UnitIsTappedByPlayer(conditionals.target)
    end,

    -- [noothertag] - target is not tapped by someone else (not tapped, or tapped by player)
    noothertag = function(conditionals)
        return conditionals.target and (not UnitIsTapped(conditionals.target) or UnitIsTappedByPlayer(conditionals.target))
    end,

    -- [group] or [group:party] or [group:raid] or [group:party/raid]
    -- Checks if the PLAYER is in a group (not unit membership)
    group = function(conditionals)
        local groupVal = conditionals.group
        -- Boolean form [group] - check if in any group
        if groupVal == true then
            return GetNumPartyMembers() > 0 or GetNumRaidMembers() > 0
        end
        -- Value form [group:party] or [group:raid] or [group:party/raid]
        return Multi(groupVal, function(groupType)
            if groupType == "party" then
                return GetNumPartyMembers() > 0
            elseif groupType == "raid" then
                return GetNumRaidMembers() > 0
            end
            return false
        end, conditionals, "group")
    end,

    -- [nogroup] or [nogroup:party] or [nogroup:raid] or [nogroup:party/raid]
    -- Checks if the PLAYER is NOT in a group
    nogroup = function(conditionals)
        local groupVal = conditionals.nogroup
        -- Boolean form [nogroup] - check if not in any group
        if groupVal == true then
            return GetNumPartyMembers() == 0 and GetNumRaidMembers() == 0
        end
        -- Value form with De Morgan's law via NegatedMulti
        return NegatedMulti(groupVal, function(groupType)
            if groupType == "party" then
                return GetNumPartyMembers() == 0
            elseif groupType == "raid" then
                return GetNumRaidMembers() == 0
            end
            return true
        end, conditionals, "nogroup")
    end,

    checkchanneled = function(conditionals)
        if conditionals.checkchanneled == true then
            -- Boolean form [checkchanneled] - check if NOT channeling anything
            return CleveRoids.CheckChanneled(nil)
        else
            -- String form [checkchanneled:SpellName] - check if NOT channeling that spell
            return Multi(conditionals.checkchanneled, function(channeledSpells)
                return CleveRoids.CheckChanneled(channeledSpells)
            end, conditionals, "checkchanneled")
        end
    end,

    checkcasting = function(conditionals)
        if conditionals.checkcasting == true then
            -- Boolean form [checkcasting] - check if NOT casting anything
            return CleveRoids.CheckCasting(nil)
        else
            -- String form [checkcasting:SpellName] - check if NOT casting that spell
            return Multi(conditionals.checkcasting, function(castingSpells)
                return CleveRoids.CheckCasting(castingSpells)
            end, conditionals, "checkcasting")
        end
    end,

    buff = function(conditionals)
        return Multi(conditionals.buff, function(v)
            return CleveRoids.ValidateUnitBuff(conditionals.target, v)
        end, conditionals, "buff")
    end,

    nobuff = function(conditionals)
        return NegatedMulti(conditionals.nobuff, function(v)
            return not CleveRoids.ValidateUnitBuff(conditionals.target, v)
        end, conditionals, "nobuff")
    end,

    debuff = function(conditionals)
        return Multi(conditionals.debuff, function(v)
            return CleveRoids.ValidateUnitDebuff(conditionals.target, v)
        end, conditionals, "debuff")
    end,

    nodebuff = function(conditionals)
        return NegatedMulti(conditionals.nodebuff, function(v)
            return not CleveRoids.ValidateUnitDebuff(conditionals.target, v)
        end, conditionals, "nodebuff")
    end,

    mybuff = function(conditionals)
        return Multi(conditionals.mybuff, function(v)
            return CleveRoids.ValidatePlayerBuff(v)
        end, conditionals, "mybuff")
    end,

    nomybuff = function(conditionals)
        return NegatedMulti(conditionals.nomybuff, function(v)
            return not CleveRoids.ValidatePlayerBuff(v)
        end, conditionals, "nomybuff")
    end,

    mydebuff = function(conditionals)
        return Multi(conditionals.mydebuff, function(v)
            return CleveRoids.ValidatePlayerDebuff(v)
        end, conditionals, "mydebuff")
    end,

    nomydebuff = function(conditionals)
        return NegatedMulti(conditionals.nomydebuff, function(v)
            return not CleveRoids.ValidatePlayerDebuff(v)
        end, conditionals, "nomydebuff")
    end,

    power = function(conditionals)
        return Multi(conditionals.power, function(args)
            if type(args) ~= "table" then return false end

            -- Handle multi-comparison (e.g., >50&<80)
            if args.comparisons and type(args.comparisons) == "table" then
                local unit = conditionals.target or "target"
                if not UnitExists(unit) then return false end
                local powerPercent = 100 / UnitManaMax(unit) * UnitMana(unit)

                -- ALL comparisons must pass (AND logic)
                for _, comp in ipairs(args.comparisons) do
                    if not CleveRoids.operators[comp.operator] then
                        return false
                    end
                    if not CleveRoids.comparators[comp.operator](powerPercent, comp.amount) then
                        return false
                    end
                end
                return true
            end

            return CleveRoids.ValidatePower(conditionals.target or "target", args.operator, args.amount)
        end, conditionals, "power")
    end,

    mypower = function(conditionals)
        return Multi(conditionals.mypower, function(args)
            if type(args) ~= "table" then return false end

            -- Handle multi-comparison (e.g., >50&<80)
            if args.comparisons and type(args.comparisons) == "table" then
                -- PERFORMANCE: Use cached player power
                local powerPercent = CleveRoids.GetCachedPlayerPowerPercent()

                -- ALL comparisons must pass (AND logic)
                for _, comp in ipairs(args.comparisons) do
                    if not CleveRoids.operators[comp.operator] then
                        return false
                    end
                    if not CleveRoids.comparators[comp.operator](powerPercent, comp.amount) then
                        return false
                    end
                end
                return true
            end

            return CleveRoids.ValidatePower("player", args.operator, args.amount)
        end, conditionals, "mypower")
    end,

    rawpower = function(conditionals)
        return Multi(conditionals.rawpower, function(args)
            if type(args) ~= "table" then return false end

            -- Handle multi-comparison (e.g., >500&<1000)
            if args.comparisons and type(args.comparisons) == "table" then
                local unit = conditionals.target or "target"
                if not UnitExists(unit) then return false end
                local power = UnitMana(unit)

                -- ALL comparisons must pass (AND logic)
                for _, comp in ipairs(args.comparisons) do
                    if not CleveRoids.operators[comp.operator] then
                        return false
                    end
                    if not CleveRoids.comparators[comp.operator](power, comp.amount) then
                        return false
                    end
                end
                return true
            end

            return CleveRoids.ValidateRawPower(conditionals.target or "target", args.operator, args.amount)
        end, conditionals, "rawpower")
    end,

    myrawpower = function(conditionals)
        return Multi(conditionals.myrawpower, function(args)
            if type(args) ~= "table" then return false end

            -- Handle multi-comparison (e.g., >500&<1000)
            if args.comparisons and type(args.comparisons) == "table" then
                -- PERFORMANCE: Use cached player power
                local power = CleveRoids.GetCachedPlayerPower()

                -- ALL comparisons must pass (AND logic)
                for _, comp in ipairs(args.comparisons) do
                    if not CleveRoids.operators[comp.operator] then
                        return false
                    end
                    if not CleveRoids.comparators[comp.operator](power, comp.amount) then
                        return false
                    end
                end
                return true
            end

            return CleveRoids.ValidateRawPower("player", args.operator, args.amount)
        end, conditionals, "myrawpower")
    end,

    druidmana = function(conditionals)
        return Multi(conditionals.druidmana, function(args)
            if type(args) ~= "table" then return false end
            return CleveRoids.ValidateDruidRawMana("player", args.operator, args.amount)
        end, conditionals, "druidmana")
    end,

    powerlost = function(conditionals)
        return Multi(conditionals.powerlost, function(args)
            if type(args) ~= "table" then return false end
            return CleveRoids.ValidatePowerLost(conditionals.target, args.operator, args.amount)
        end, conditionals, "powerlost")
    end,

    mypowerlost = function(conditionals)
        return Multi(conditionals.mypowerlost, function(args)
            if type(args) ~= "table" then return false end
            return CleveRoids.ValidatePowerLost("player", args.operator, args.amount)
        end, conditionals, "mypowerlost")
    end,

    hp = function(conditionals)
        return Multi(conditionals.hp, function(args)
            if type(args) ~= "table" then return false end

            -- Handle multi-comparison (e.g., >50&<80)
            if args.comparisons and type(args.comparisons) == "table" then
                local unit = conditionals.target or "target"
                if not UnitExists(unit) then return false end

                -- PERFORMANCE: Use cached health for target
                local hp
                if unit == "target" then
                    hp = CleveRoids.GetCachedTargetHealthPercent()
                else
                    local maxHp = UnitHealthMax(unit)
                    hp = maxHp > 0 and (100 * UnitHealth(unit) / maxHp) or 0
                end

                -- ALL comparisons must pass (AND logic)
                for _, comp in ipairs(args.comparisons) do
                    if not CleveRoids.operators[comp.operator] then
                        return false
                    end
                    if not CleveRoids.comparators[comp.operator](hp, comp.amount) then
                        return false
                    end
                end
                return true
            end

            return CleveRoids.ValidateHp(conditionals.target or "target", args.operator, args.amount)
        end, conditionals, "hp")
    end,

    level = function(conditionals)
        return Multi(conditionals.level, function(args)
            if type(args) ~= "table" then return false end

            -- Handle multi-comparison (e.g., >50&<60)
            if args.comparisons and type(args.comparisons) == "table" then
                local unit = conditionals.target or "target"
                if not UnitExists(unit) then return false end
                local level = UnitLevel(unit)

                -- Treat skull/boss mobs (??) as level 63
                if level == -1 then
                    level = 63
                end

                -- ALL comparisons must pass (AND logic)
                for _, comp in ipairs(args.comparisons) do
                    if not CleveRoids.operators[comp.operator] then
                        return false
                    end
                    if not CleveRoids.comparators[comp.operator](level, comp.amount) then
                        return false
                    end
                end
                return true
            end

            return CleveRoids.ValidateLevel(conditionals.target or "target", args.operator, args.amount)
        end, conditionals, "level")
    end,

    mylevel = function(conditionals)
        return Multi(conditionals.mylevel, function(args)
            if type(args) ~= "table" then return false end

            -- Handle multi-comparison (e.g., >50&<60)
            if args.comparisons and type(args.comparisons) == "table" then
                local level = UnitLevel("player")

                -- ALL comparisons must pass (AND logic)
                for _, comp in ipairs(args.comparisons) do
                    if not CleveRoids.operators[comp.operator] then
                        return false
                    end
                    if not CleveRoids.comparators[comp.operator](level, comp.amount) then
                        return false
                    end
                end
                return true
            end

            return CleveRoids.ValidateLevel("player", args.operator, args.amount)
        end, conditionals, "mylevel")
    end,

    myhp = function(conditionals)
        return Multi(conditionals.myhp, function(args)
            if type(args) ~= "table" then return false end

            -- Handle multi-comparison (e.g., >50&<80)
            if args.comparisons and type(args.comparisons) == "table" then
                -- PERFORMANCE: Use cached player health
                local hp = CleveRoids.GetCachedPlayerHealthPercent()

                -- ALL comparisons must pass (AND logic)
                for _, comp in ipairs(args.comparisons) do
                    if not CleveRoids.operators[comp.operator] then
                        return false
                    end
                    if not CleveRoids.comparators[comp.operator](hp, comp.amount) then
                        return false
                    end
                end
                return true
            end

            return CleveRoids.ValidateHp("player", args.operator, args.amount)
        end, conditionals, "myhp")
    end,

    rawhp = function(conditionals)
        return Multi(conditionals.rawhp, function(args)
            if type(args) ~= "table" then return false end
            return CleveRoids.ValidateRawHp(conditionals.target or "target", args.operator, args.amount)
        end, conditionals, "rawhp")
    end,

    myrawhp = function(conditionals)
        return Multi(conditionals.myrawhp, function(args)
            if type(args) ~= "table" then return false end
            return CleveRoids.ValidateRawHp("player", args.operator, args.amount)
        end, conditionals, "myrawhp")
    end,

    hplost = function(conditionals)
        return Multi(conditionals.hplost, function(args)
            if type(args) ~= "table" then return false end
            return CleveRoids.ValidateHpLost(conditionals.target, args.operator, args.amount)
        end, conditionals, "hplost")
    end,

    myhplost = function(conditionals)
        return Multi(conditionals.myhplost, function(args)
            if type(args) ~= "table" then return false end
            return CleveRoids.ValidateHpLost("player", args.operator, args.amount)
        end, conditionals, "myhplost")
    end,

    type = function(conditionals)
        return Or(conditionals.type, function(unittype)
            return CleveRoids.ValidateCreatureType(unittype, conditionals.target)
        end)
    end,

    notype = function(conditionals)
        return NegatedMulti(conditionals.notype, function(unittype)
            return not CleveRoids.ValidateCreatureType(unittype, conditionals.target)
        end, conditionals, "notype")
    end,

    cooldown = function(conditionals)
        return Multi(conditionals.cooldown,function (v)
            return CleveRoids.ValidateCooldown(v, true)
        end, conditionals, "cooldown")
    end,

    nocooldown = function(conditionals)
        return NegatedMulti(conditionals.nocooldown,function (v)
            return not CleveRoids.ValidateCooldown(v, true)
        end, conditionals, "nocooldown")
    end,

    cdgcd = function(conditionals)
        return Multi(conditionals.cdgcd,function (v)
            return CleveRoids.ValidateCooldown(v, false)
        end, conditionals, "cdgcd")
    end,

    nocdgcd = function(conditionals)
        return NegatedMulti(conditionals.nocdgcd,function (v)
            return not CleveRoids.ValidateCooldown(v, false)
        end, conditionals, "nocdgcd")
    end,

    -- GCD conditional - check if GCD is active/remaining
    -- Usage: [gcd] - true if GCD is active
    --        [gcd:<1] - true if GCD has less than 1 second remaining
    --        [nogcd] - true if GCD is not active
    gcd = function(conditionals)
        return Multi(conditionals.gcd, function(args)
            -- Get GCD remaining in seconds
            local gcdRemaining = 0

            -- Try Nampower API first (most accurate)
            if CleveRoids.NampowerAPI and CleveRoids.NampowerAPI.GetGCDRemainingMs then
                local gcdMs = CleveRoids.NampowerAPI.GetGCDRemainingMs()
                if gcdMs and gcdMs > 0 then
                    gcdRemaining = gcdMs / 1000
                end
            else
                -- Fallback: check the first spell in spellbook for GCD
                -- GCD shows as cooldown <= 1.5s on any GCD-triggering spell
                for i = 1, 200 do
                    local spellName = GetSpellName(i, BOOKTYPE_SPELL)
                    if not spellName then break end
                    local start, duration = GetSpellCooldown(i, BOOKTYPE_SPELL)
                    if start and duration and duration > 0 and duration <= 1.5 then
                        gcdRemaining = (start + duration) - GetTime()
                        if gcdRemaining < 0 then gcdRemaining = 0 end
                        break
                    end
                end
            end

            -- No args or just [gcd] - check if GCD is active
            if not args or args == "" or (type(args) == "table" and not args.operator) then
                return gcdRemaining > 0
            end

            -- With operator: [gcd:<1] etc
            if type(args) == "table" and args.operator and args.amount then
                if CleveRoids.operators[args.operator] then
                    return CleveRoids.comparators[args.operator](gcdRemaining, args.amount)
                end
            end

            return gcdRemaining > 0
        end, conditionals, "gcd")
    end,

    nogcd = function(conditionals)
        return NegatedMulti(conditionals.nogcd, function(args)
            -- Get GCD remaining in seconds
            local gcdRemaining = 0

            -- Try Nampower API first (most accurate)
            if CleveRoids.NampowerAPI and CleveRoids.NampowerAPI.GetGCDRemainingMs then
                local gcdMs = CleveRoids.NampowerAPI.GetGCDRemainingMs()
                if gcdMs and gcdMs > 0 then
                    gcdRemaining = gcdMs / 1000
                end
            else
                -- Fallback: check the first spell in spellbook for GCD
                for i = 1, 200 do
                    local spellName = GetSpellName(i, BOOKTYPE_SPELL)
                    if not spellName then break end
                    local start, duration = GetSpellCooldown(i, BOOKTYPE_SPELL)
                    if start and duration and duration > 0 and duration <= 1.5 then
                        gcdRemaining = (start + duration) - GetTime()
                        if gcdRemaining < 0 then gcdRemaining = 0 end
                        break
                    end
                end
            end

            -- [nogcd] - true if GCD is NOT active
            if not args or args == "" or (type(args) == "table" and not args.operator) then
                return gcdRemaining <= 0
            end

            -- With operator: [nogcd:<1] means NOT (gcd < 1), i.e., gcd >= 1
            if type(args) == "table" and args.operator and args.amount then
                if CleveRoids.operators[args.operator] then
                    return not CleveRoids.comparators[args.operator](gcdRemaining, args.amount)
                end
            end

            return gcdRemaining <= 0
        end, conditionals, "nogcd")
    end,

    channeled = function(conditionals)
        -- Use time-based prediction for accuracy
        if CleveRoids.CurrentSpell.type == "channeled" and CleveRoids.channelStartTime and CleveRoids.channelDuration then
            local remaining = CleveRoids.channelDuration - (GetTime() - CleveRoids.channelStartTime)
            if remaining <= 0.1 then
                return false -- Channel is done
            end
        end
        return CleveRoids.CurrentSpell.type == "channeled"
    end,

    nochanneled = function(conditionals)
        -- Use time-based prediction for accuracy
        if CleveRoids.CurrentSpell.type == "channeled" and CleveRoids.channelStartTime and CleveRoids.channelDuration then
            local remaining = CleveRoids.channelDuration - (GetTime() - CleveRoids.channelStartTime)
            if remaining <= 0.1 then
                return true -- Channel is done
            end
        end
        return CleveRoids.CurrentSpell.type ~= "channeled"
    end,

    channeltime = function(conditionals)
        -- Calculate remaining time (0 if not channeling)
        local timeLeft = 0

        if CleveRoids.CurrentSpell.type == "channeled" and CleveRoids.channelStartTime and CleveRoids.channelDuration then
            local elapsed = GetTime() - CleveRoids.channelStartTime
            timeLeft = CleveRoids.channelDuration - elapsed
            -- Don't allow negative time
            if timeLeft < 0 then timeLeft = 0 end
        end

        local check = conditionals.channeltime

        -- channeltime is stored as an array by the parser, get the first element
        if type(check) == "table" and type(check[1]) == "table" then
            check = check[1]
        end

        if type(check) == "table" and check.operator and check.amount then
            -- Now compare: if not channeling, timeLeft is 0, so [channeltime:<0.5] returns true
            return CleveRoids.comparators[check.operator](timeLeft, check.amount)
        end

        return false
    end,

    -- [nochanneltime] - Negated channel time comparison
    -- Usage: [nochanneltime:<0.5] = true if NOT (channeltime < 0.5), i.e., >= 0.5 seconds remaining
    nochanneltime = function(conditionals)
        -- Calculate remaining time (0 if not channeling)
        local timeLeft = 0

        if CleveRoids.CurrentSpell.type == "channeled" and CleveRoids.channelStartTime and CleveRoids.channelDuration then
            local elapsed = GetTime() - CleveRoids.channelStartTime
            timeLeft = CleveRoids.channelDuration - elapsed
            if timeLeft < 0 then timeLeft = 0 end
        end

        local check = conditionals.nochanneltime

        if type(check) == "table" and type(check[1]) == "table" then
            check = check[1]
        end

        if type(check) == "table" and check.operator and check.amount then
            return not CleveRoids.comparators[check.operator](timeLeft, check.amount)
        end

        return true
    end,

    casttime = function(conditionals)
        -- Calculate remaining time (0 if not casting)
        local timeLeft = 0

        if CleveRoids.CurrentSpell.type == "cast" and CleveRoids.castStartTime and CleveRoids.castDuration then
            local elapsed = GetTime() - CleveRoids.castStartTime
            timeLeft = CleveRoids.castDuration - elapsed
            -- Don't allow negative time
            if timeLeft < 0 then timeLeft = 0 end
        end

        local check = conditionals.casttime

        -- casttime is stored as an array by the parser, get the first element
        if type(check) == "table" and type(check[1]) == "table" then
            check = check[1]
        end

        if type(check) == "table" and check.operator and check.amount then
            -- Now compare: if not casting, timeLeft is 0, so [casttime:<0.5] returns true
            return CleveRoids.comparators[check.operator](timeLeft, check.amount)
        end

        return false
    end,

    -- [nocasttime] - Negated cast time comparison
    -- Usage: [nocasttime:<0.5] = true if NOT (casttime < 0.5), i.e., >= 0.5 seconds remaining
    nocasttime = function(conditionals)
        -- Calculate remaining time (0 if not casting)
        local timeLeft = 0

        if CleveRoids.CurrentSpell.type == "cast" and CleveRoids.castStartTime and CleveRoids.castDuration then
            local elapsed = GetTime() - CleveRoids.castStartTime
            timeLeft = CleveRoids.castDuration - elapsed
            if timeLeft < 0 then timeLeft = 0 end
        end

        local check = conditionals.nocasttime

        if type(check) == "table" and type(check[1]) == "table" then
            check = check[1]
        end

        if type(check) == "table" and check.operator and check.amount then
            return not CleveRoids.comparators[check.operator](timeLeft, check.amount)
        end

        return true
    end,

    targeting = function(conditionals)
        return Or(conditionals.targeting, function (unit)
            return (UnitIsUnit("targettarget", unit) == 1)
        end)
    end,

    notargeting = function(conditionals)
        return NegatedMulti(conditionals.notargeting, function (unit)
            return UnitIsUnit("targettarget", unit) ~= 1
        end, conditionals, "notargeting")
    end,

    isplayer = function(conditionals)
        return UnitIsPlayer(conditionals.target)
    end,

    -- [noisplayer] - Target is NOT a player (same as isnpc)
    noisplayer = function(conditionals)
        return not UnitIsPlayer(conditionals.target)
    end,

    isnpc = function(conditionals)
        return not UnitIsPlayer(conditionals.target)
    end,

    -- [noisnpc] - Target is NOT an NPC (same as isplayer)
    noisnpc = function(conditionals)
        return UnitIsPlayer(conditionals.target)
    end,

    inrange = function(conditionals)
        if not IsSpellInRange then return end
        local API = CleveRoids.NampowerAPI
        return Multi(conditionals.inrange, function(spellName)
            local target = conditionals.target or "target"
            local checkValue = spellName or conditionals.action

            -- Use API wrapper which handles self-cast spells correctly
            local result = API.IsSpellInRange(checkValue, target)
            return result == 1
        end, conditionals, "inrange")
    end,

    noinrange = function(conditionals)
        if not IsSpellInRange then return end
        local API = CleveRoids.NampowerAPI
        return NegatedMulti(conditionals.noinrange, function(spellName)
            local target = conditionals.target or "target"
            local checkValue = spellName or conditionals.action

            -- Use API wrapper which handles self-cast spells correctly
            local result = API.IsSpellInRange(checkValue, target)
            return result == 0
        end, conditionals, "noinrange")
    end,

    outrange = function(conditionals)
        if not IsSpellInRange then return end
        local API = CleveRoids.NampowerAPI
        return Multi(conditionals.outrange, function(spellName)
            local target = conditionals.target or "target"
            local checkValue = spellName or conditionals.action

            -- Use API wrapper which handles self-cast spells correctly
            local result = API.IsSpellInRange(checkValue, target)
            return result == 0
        end, conditionals, "outrange")
    end,

    -- [nooutrange] - Target is NOT out of range (same as inrange)
    nooutrange = function(conditionals)
        if not IsSpellInRange then return end
        local API = CleveRoids.NampowerAPI
        return NegatedMulti(conditionals.nooutrange, function(spellName)
            local target = conditionals.target or "target"
            local checkValue = spellName or conditionals.action

            local result = API.IsSpellInRange(checkValue, target)
            return result == 1  -- In range = nooutrange passes
        end, conditionals, "nooutrange")
    end,

    combo = function(conditionals)
        return Multi(conditionals.combo, function(args)
            return CleveRoids.ValidateComboPoints(args.operator, args.amount)
        end, conditionals, "combo")
    end,

    nocombo = function(conditionals)
        return NegatedMulti(conditionals.nocombo, function(args)
            return not CleveRoids.ValidateComboPoints(args.operator, args.amount)
        end, conditionals, "nocombo")
    end,

    known = function(conditionals)
        return Multi(conditionals.known, function(args)
            return CleveRoids.ValidateKnown(args)
        end, conditionals, "known")
    end,

    noknown = function(conditionals)
        return NegatedMulti(conditionals.noknown, function(args)
            return not CleveRoids.ValidateKnown(args)
        end, conditionals, "noknown")
    end,

    resting = function()
        return IsResting() == 1
    end,

    noresting = function()
        return IsResting() == nil
    end,

    stat = function(conditionals)
        return Multi(conditionals.stat, function(args)
            if type(args) ~= "table" or not args.name then
                return false -- Malformed arguments from the parser.
            end

            local stat_key = string.lower(args.name)
            local get_stat_func = stat_checks[stat_key]

            if not get_stat_func then
                return false -- The requested stat key is invalid.
            end

            local current_value = get_stat_func()
            if not current_value then return false end

            -- Check if this is a multi-comparison stat conditional
            -- args.comparisons will be a table of {operator=, amount=} if multiple
            if args.comparisons and type(args.comparisons) == "table" then
                -- ALL comparisons must pass (AND logic)
                for _, comp in ipairs(args.comparisons) do
                    if not CleveRoids.comparators[comp.operator] then
                        return false -- Invalid operator
                    end
                    if not CleveRoids.comparators[comp.operator](current_value, comp.amount) then
                        return false -- One comparison failed, so the whole conditional fails
                    end
                end
                return true -- All comparisons passed
            else
                -- Single comparison (backward compatibility)
                if not args.operator or not args.amount then
                    return false
                end
                return CleveRoids.comparators[args.operator](current_value, args.amount)
            end
        end, conditionals, "stat")
    end,

    -- [nostat] - Negated stat comparison
    -- Usage: [nostat:agi>100] = true if NOT (agi > 100), i.e., agi <= 100
    nostat = function(conditionals)
        return NegatedMulti(conditionals.nostat, function(args)
            if type(args) ~= "table" or not args.name then
                return true -- Malformed = negation passes
            end

            local stat_key = string.lower(args.name)
            local get_stat_func = stat_checks[stat_key]

            if not get_stat_func then
                return true -- Invalid stat = negation passes
            end

            local current_value = get_stat_func()
            if not current_value then return true end

            -- Handle multi-comparison
            if args.comparisons and type(args.comparisons) == "table" then
                for _, comp in ipairs(args.comparisons) do
                    if not CleveRoids.comparators[comp.operator] then
                        return true
                    end
                    if not CleveRoids.comparators[comp.operator](current_value, comp.amount) then
                        return true -- One failed = negation passes
                    end
                end
                return false -- All passed = negation fails
            else
                if not args.operator or not args.amount then
                    return true
                end
                return not CleveRoids.comparators[args.operator](current_value, args.amount)
            end
        end, conditionals, "nostat")
    end,

    class = function(conditionals)
        -- Determine which unit to check. Defaults to 'target' if no @unitid was specified.
        local unitToCheck = conditionals.target or "target"

        -- The conditional must fail if the unit doesn't exist OR is not a player.
        if not UnitExists(unitToCheck) or not UnitIsPlayer(unitToCheck) then
            return false
        end

        -- Get the player's class.
        local localizedClass, englishClass = UnitClass(unitToCheck)
        if not localizedClass then return false end -- Failsafe for unusual cases

        -- The "Or" helper handles multiple values like [class:Warrior/Druid].
        return Or(conditionals.class, function(requiredClass)
            return string.lower(requiredClass) == string.lower(localizedClass) or string.lower(requiredClass) == string.lower(englishClass)
        end)
    end,

    noclass = function(conditionals)
        -- Determine which unit to check. Defaults to 'target' if no @unitid was specified.
        local unitToCheck = conditionals.target or "target"

        -- A unit that doesn't exist cannot have a specific player class.
        if not UnitExists(unitToCheck) then
            return true
        end

        -- An NPC cannot have a specific player class.
        if not UnitIsPlayer(unitToCheck) then
            return true
        end

        -- If we get here, the unit is a player. Now check their class.
        local localizedClass, englishClass = UnitClass(unitToCheck)
        -- A player should always have a class, but if not, this condition is still met.
        if not localizedClass then return true end

        -- The "NegatedMulti" helper ensures the player's class is not any of the forbidden classes.
        return NegatedMulti(conditionals.noclass, function(forbiddenClass)
            return string.lower(forbiddenClass) ~= string.lower(localizedClass) and string.lower(forbiddenClass) ~= string.lower(englishClass)
        end, conditionals, "noclass")
    end,

    pet = function(conditionals)
        if not UnitExists("pet") then
            return false
        end

        return Or(conditionals.pet, function(petType)
            local currentPet = UnitCreatureFamily("pet")
            if not currentPet then
                return false
            end
            return string.lower(currentPet) == string.lower(petType)
        end)
    end,

    nopet = function(conditionals)
        if not UnitExists("pet") then
            return true
        end

        return NegatedMulti(conditionals.nopet, function(petType)
            local currentPet = UnitCreatureFamily("pet")
            if not currentPet then
                return true
            end
            return string.lower(currentPet) ~= string.lower(petType)
        end, conditionals, "nopet")
    end,

    swimming = function(conditionals)
        -- Check if "Aquatic Form" is in the reactive list and usable
        return CleveRoids.IsReactiveUsable("Aquatic Form")
    end,

    noswimming = function(conditionals)
        -- Check if "Aquatic Form" is NOT usable
        return not CleveRoids.IsReactiveUsable("Aquatic Form")
    end,

    distance = function(conditionals)
        if not CleveRoids.hasUnitXP then return false end

        return Multi(conditionals.distance, function(args)
            if type(args) ~= "table" or not args.operator or not args.amount then
                return false
            end

            local unit = conditionals.target or "target"
            if not UnitExists(unit) then return false end

            local distance = UnitXP("distanceBetween", "player", unit)
            if not distance then return false end

            return CleveRoids.comparators[args.operator](distance, args.amount)
        end, conditionals, "distance")
    end,

    nodistance = function(conditionals)
        if not CleveRoids.hasUnitXP then return false end

        return NegatedMulti(conditionals.nodistance, function(args)
            if type(args) ~= "table" or not args.operator or not args.amount then
                return false
            end

            local unit = conditionals.target or "target"
            if not UnitExists(unit) then return false end

            local distance = UnitXP("distanceBetween", "player", unit)
            if not distance then return false end

            return not CleveRoids.comparators[args.operator](distance, args.amount)
        end, conditionals, "nodistance")
    end,

    behind = function(conditionals)
        if not CleveRoids.hasUnitXP then return false end

        local unit = conditionals.target or "target"
        if not UnitExists(unit) then return false end

        return UnitXP("behind", "player", unit) == true
    end,

    nobehind = function(conditionals)
        if not CleveRoids.hasUnitXP then return false end

        local unit = conditionals.target or "target"
        if not UnitExists(unit) then return false end

        return UnitXP("behind", "player", unit) ~= true
    end,

    insight = function(conditionals)
        if not CleveRoids.hasUnitXP then return false end

        local unit = conditionals.target or "target"
        if not UnitExists(unit) then return false end

        return UnitXP("inSight", "player", unit) == true
    end,

    noinsight = function(conditionals)
        if not CleveRoids.hasUnitXP then return false end

        local unit = conditionals.target or "target"
        if not UnitExists(unit) then return false end

        return UnitXP("inSight", "player", unit) ~= true
    end,

    meleerange = function(conditionals)
        local unit = conditionals.target or "target"
        if not UnitExists(unit) then return false end

        if CleveRoids.hasUnitXP then
            local distance = UnitXP("distanceBetween", "player", unit, "meleeAutoAttack")
            return distance and distance <= 5
        else
            -- Fallback: use CheckInteractDistance (3 = melee range)
            return CheckInteractDistance(unit, 3)
        end
    end,

    nomeleerange = function(conditionals)
        local unit = conditionals.target or "target"
        if not UnitExists(unit) then return true end

        if CleveRoids.hasUnitXP then
            local distance = UnitXP("distanceBetween", "player", unit, "meleeAutoAttack")
            return not distance or distance > 5
        else
            return not CheckInteractDistance(unit, 3)
        end
    end,

    queuedspell = function(conditionals)
        if not CleveRoids.hasNampower then return false end
        if not CleveRoids.queuedSpell then return false end

        -- If no specific spell name provided, check if ANY spell is queued
        if not conditionals.queuedspell or table.getn(conditionals.queuedspell) == 0 then
            return true
        end

        -- Check if specific spell is queued
        return Or(conditionals.queuedspell, function(spellName)
            if not CleveRoids.queuedSpell.spellName then return false end
            local queuedName = string.gsub(CleveRoids.queuedSpell.spellName, "%s*%(.-%)%s*$", "")
            local checkName = string.gsub(spellName, "%s*%(.-%)%s*$", "")
            return string.lower(queuedName) == string.lower(checkName)
        end)
    end,

    noqueuedspell = function(conditionals)
        if not CleveRoids.hasNampower then return false end

        -- If no specific spell name, check if NO spell is queued
        if not conditionals.noqueuedspell or table.getn(conditionals.noqueuedspell) == 0 then
            return CleveRoids.queuedSpell == nil
        end

        -- Check if specific spell is NOT queued
        if not CleveRoids.queuedSpell or not CleveRoids.queuedSpell.spellName then
            return true
        end

        return NegatedMulti(conditionals.noqueuedspell, function(spellName)
            local queuedName = string.gsub(CleveRoids.queuedSpell.spellName, "%s*%(.-%)%s*$", "")
            local checkName = string.gsub(spellName, "%s*%(.-%)%s*$", "")
            return string.lower(queuedName) ~= string.lower(checkName)
        end, conditionals, "noqueuedspell")
    end,

    onswingpending = function(conditionals)
        if not GetCurrentCastingInfo then return false end

        local _, _, _, _, _, onswing = GetCurrentCastingInfo()
        return onswing == 1
    end,

    noonswingpending = function(conditionals)
        if not GetCurrentCastingInfo then return true end

        local _, _, _, _, _, onswing = GetCurrentCastingInfo()
        return onswing ~= 1
    end,

    mybuffcount = function(conditionals)
        return Multi(conditionals.mybuffcount,function (v) return CleveRoids.ValidatePlayerAuraCount(v.bigger, v.amount) end, conditionals, "mybuffcount")
    end,

    -- [nomybuffcount] - Negated buff count comparison
    -- Usage: [nomybuffcount:>15] = true if NOT (buffcount > 15), i.e., buffcount <= 15
    nomybuffcount = function(conditionals)
        return NegatedMulti(conditionals.nomybuffcount, function(v)
            return not CleveRoids.ValidatePlayerAuraCount(v.bigger, v.amount)
        end, conditionals, "nomybuffcount")
    end,

    -- [mhimbue] - Check main hand has temporary imbue (poison, oil, sharpening stone, etc.)
    -- [mhimbue:Name] - Check for specific imbue name
    -- [mhimbue:<300] - Check imbue time remaining < 300 seconds
    -- [mhimbue:Name<300] - Specific imbue with time check
    -- [mhimbue:>#5] - Check imbue charges > 5
    mhimbue = function(conditionals)
        local args = CleveRoids.ParseImbueArgs(conditionals.mhimbue, conditionals)
        return CleveRoids.ValidateWeaponImbue("mh", args)
    end,

    nomhimbue = function(conditionals)
        local args = CleveRoids.ParseImbueArgs(conditionals.nomhimbue, conditionals)
        return not CleveRoids.ValidateWeaponImbue("mh", args)
    end,

    -- [ohimbue] - Check off hand has temporary imbue
    -- Same syntax as mhimbue
    ohimbue = function(conditionals)
        local args = CleveRoids.ParseImbueArgs(conditionals.ohimbue, conditionals)
        return CleveRoids.ValidateWeaponImbue("oh", args)
    end,

    noohimbue = function(conditionals)
        local args = CleveRoids.ParseImbueArgs(conditionals.noohimbue, conditionals)
        return not CleveRoids.ValidateWeaponImbue("oh", args)
    end,

    immune = function(conditionals)
        -- Check if target is immune to the spell being cast or damage school
        -- Usage: [immune] SpellName  OR  [immune:SpellName]  OR  [immune:fire]
        local checkValue = nil

        -- Case 1: [immune:SpellName] or [immune:fire]
        if type(conditionals.immune) == "table" and table.getn(conditionals.immune) > 0 then
            checkValue = conditionals.immune[1]
        elseif type(conditionals.immune) == "string" then
            checkValue = conditionals.immune
        -- Case 2: [immune] SpellName (check the action being cast)
        elseif conditionals.action then
            checkValue = conditionals.action
        end

        if not checkValue then
            return false
        end

        return CleveRoids.CheckImmunity(conditionals.target or "target", checkValue)
    end,

    noimmune = function(conditionals)
        -- Check if target is NOT immune to the spell being cast or damage school
        -- Usage: [noimmune] SpellName  OR  [noimmune:SpellName]  OR  [noimmune:fire]
        local checkValue = nil

        -- Case 1: [noimmune:SpellName] or [noimmune:fire]
        if type(conditionals.noimmune) == "table" and table.getn(conditionals.noimmune) > 0 then
            checkValue = conditionals.noimmune[1]
        elseif type(conditionals.noimmune) == "string" then
            checkValue = conditionals.noimmune
        -- Case 2: [noimmune] SpellName (check the action being cast)
        elseif conditionals.action then
            checkValue = conditionals.action
        end

        if not checkValue then
            return true  -- If we can't determine spell/school, assume not immune
        end

        local isImmune = CleveRoids.CheckImmunity(conditionals.target or "target", checkValue)
        return not isImmune
    end,

    -- SP_SwingTimer integration conditionals
    -- Checks percentage of swing time that has elapsed
    -- Usage: [swingtimer:<15] = less than 15% of swing has elapsed (early in swing)
    --        [swingtimer:>80] = more than 80% of swing has elapsed (late in swing)
    swingtimer = function(conditionals)
        return Multi(conditionals.swingtimer, function(args)
            if type(args) ~= "table" then return false end

            -- Handle multi-comparison (e.g., >50&<80)
            if args.comparisons and type(args.comparisons) == "table" then
                -- Check if SP_SwingTimer is loaded
                if st_timer == nil then
                    if not CleveRoids._swingTimerErrorShown then
                        DEFAULT_CHAT_FRAME:AddMessage("|cffff0000[SuperCleveRoidMacros]|r The [swingtimer] conditional requires the SP_SwingTimer addon. Get it at: https://github.com/jrc13245/SP_SwingTimer", 1, 0.5, 0.5)
                        CleveRoids._swingTimerErrorShown = true
                    end
                    return false
                end

                local attackSpeed = UnitAttackSpeed("player")
                if not attackSpeed or attackSpeed <= 0 then return false end

                local timeElapsed = attackSpeed - st_timer
                local percentElapsed = (timeElapsed / attackSpeed) * 100

                -- ALL comparisons must pass (AND logic)
                for _, comp in ipairs(args.comparisons) do
                    if not CleveRoids.operators[comp.operator] then
                        return false
                    end
                    if not CleveRoids.comparators[comp.operator](percentElapsed, comp.amount) then
                        return false
                    end
                end
                return true
            end

            return CleveRoids.ValidateSwingTimer(args.operator, args.amount)
        end, conditionals, "swingtimer")
    end,

    -- Alias for swingtimer
    stimer = function(conditionals)
        return Multi(conditionals.stimer, function(args)
            if type(args) ~= "table" then return false end

            -- Handle multi-comparison (e.g., >50&<80)
            if args.comparisons and type(args.comparisons) == "table" then
                -- Check if SP_SwingTimer is loaded
                if st_timer == nil then
                    if not CleveRoids._swingTimerErrorShown then
                        DEFAULT_CHAT_FRAME:AddMessage("|cffff0000[SuperCleveRoidMacros]|r The [swingtimer] conditional requires the SP_SwingTimer addon. Get it at: https://github.com/jrc13245/SP_SwingTimer", 1, 0.5, 0.5)
                        CleveRoids._swingTimerErrorShown = true
                    end
                    return false
                end

                local attackSpeed = UnitAttackSpeed("player")
                if not attackSpeed or attackSpeed <= 0 then return false end

                local timeElapsed = attackSpeed - st_timer
                local percentElapsed = (timeElapsed / attackSpeed) * 100

                -- ALL comparisons must pass (AND logic)
                for _, comp in ipairs(args.comparisons) do
                    if not CleveRoids.operators[comp.operator] then
                        return false
                    end
                    if not CleveRoids.comparators[comp.operator](percentElapsed, comp.amount) then
                        return false
                    end
                end
                return true
            end

            return CleveRoids.ValidateSwingTimer(args.operator, args.amount)
        end, conditionals, "stimer")
    end,

    -- Negated swingtimer
    noswingtimer = function(conditionals)
        return NegatedMulti(conditionals.noswingtimer, function(args)
            if type(args) ~= "table" then return false end

            -- Handle multi-comparison by checking positive and negating
            if args.comparisons and type(args.comparisons) == "table" then
                -- Check if SP_SwingTimer is loaded
                if st_timer == nil then
                    if not CleveRoids._swingTimerErrorShown then
                        DEFAULT_CHAT_FRAME:AddMessage("|cffff0000[SuperCleveRoidMacros]|r The [swingtimer] conditional requires the SP_SwingTimer addon. Get it at: https://github.com/jrc13245/SP_SwingTimer", 1, 0.5, 0.5)
                        CleveRoids._swingTimerErrorShown = true
                    end
                    return true
                end

                local attackSpeed = UnitAttackSpeed("player")
                if not attackSpeed or attackSpeed <= 0 then return true end

                local timeElapsed = attackSpeed - st_timer
                local percentElapsed = (timeElapsed / attackSpeed) * 100

                -- Check if ALL comparisons pass
                for _, comp in ipairs(args.comparisons) do
                    if not CleveRoids.operators[comp.operator] then
                        return true
                    end
                    if not CleveRoids.comparators[comp.operator](percentElapsed, comp.amount) then
                        return true  -- One failed, so positive=false, negated=true
                    end
                end
                return false  -- All passed, so positive=true, negated=false
            end

            return not CleveRoids.ValidateSwingTimer(args.operator, args.amount)
        end, conditionals, "noswingtimer")
    end,

    -- Alias for noswingtimer
    nostimer = function(conditionals)
        return NegatedMulti(conditionals.nostimer, function(args)
            if type(args) ~= "table" then return false end

            -- Handle multi-comparison by checking positive and negating
            if args.comparisons and type(args.comparisons) == "table" then
                -- Check if SP_SwingTimer is loaded
                if st_timer == nil then
                    if not CleveRoids._swingTimerErrorShown then
                        DEFAULT_CHAT_FRAME:AddMessage("|cffff0000[SuperCleveRoidMacros]|r The [swingtimer] conditional requires the SP_SwingTimer addon. Get it at: https://github.com/jrc13245/SP_SwingTimer", 1, 0.5, 0.5)
                        CleveRoids._swingTimerErrorShown = true
                    end
                    return true
                end

                local attackSpeed = UnitAttackSpeed("player")
                if not attackSpeed or attackSpeed <= 0 then return true end

                local timeElapsed = attackSpeed - st_timer
                local percentElapsed = (timeElapsed / attackSpeed) * 100

                -- Check if ALL comparisons pass
                for _, comp in ipairs(args.comparisons) do
                    if not CleveRoids.operators[comp.operator] then
                        return true
                    end
                    if not CleveRoids.comparators[comp.operator](percentElapsed, comp.amount) then
                        return true  -- One failed, so positive=false, negated=true
                    end
                end
                return false  -- All passed, so positive=true, negated=false
            end

            return not CleveRoids.ValidateSwingTimer(args.operator, args.amount)
        end, conditionals, "nostimer")
    end,

    -- Threat percentage conditional (reads server data via CHAT_MSG_ADDON)
    -- Usage: [threat:>80] - true if threat is above 80%
    -- 100% = will pull aggro
    -- Note: Requires TWThreat addon to request threat data from server
    threat = function(conditionals)
        return Multi(conditionals.threat, function(args)
            if type(args) ~= "table" then return false end

            -- Handle multi-comparison (e.g., >50&<90)
            if args.comparisons and type(args.comparisons) == "table" then
                local threatpct = CleveRoids.GetPlayerThreatPercent()
                if threatpct == nil then return false end

                -- ALL comparisons must pass (AND logic)
                for _, comp in ipairs(args.comparisons) do
                    if not CleveRoids.operators[comp.operator] then
                        return false
                    end
                    if not CleveRoids.comparators[comp.operator](threatpct, comp.amount) then
                        return false
                    end
                end
                return true
            end

            return CleveRoids.ValidateThreat(args.operator, args.amount)
        end, conditionals, "threat")
    end,

    -- Negated threat conditional
    nothreat = function(conditionals)
        return NegatedMulti(conditionals.nothreat, function(args)
            if type(args) ~= "table" then return false end

            if args.comparisons and type(args.comparisons) == "table" then
                local threatpct = CleveRoids.GetPlayerThreatPercent()
                if threatpct == nil then return true end

                for _, comp in ipairs(args.comparisons) do
                    if not CleveRoids.operators[comp.operator] then
                        return true
                    end
                    if not CleveRoids.comparators[comp.operator](threatpct, comp.amount) then
                        return true
                    end
                end
                return false
            end

            return not CleveRoids.ValidateThreat(args.operator, args.amount)
        end, conditionals, "nothreat")
    end,

    -- Time-To-Kill conditional (requires TimeToKill addon)
    -- Usage: [ttk:<10] - true if target will die in less than 10 seconds
    ttk = function(conditionals)
        return Multi(conditionals.ttk, function(args)
            if type(args) ~= "table" then return false end

            -- Handle multi-comparison (e.g., >5&<15)
            if args.comparisons and type(args.comparisons) == "table" then
                if type(TimeToKill) ~= "table" or type(TimeToKill.GetTTK) ~= "function" then
                    if not CleveRoids._ttkErrorShown then
                        DEFAULT_CHAT_FRAME:AddMessage("|cffff0000[SuperCleveRoidMacros]|r The [ttk] conditional requires the TimeToKill addon.", 1, 0.5, 0.5)
                        CleveRoids._ttkErrorShown = true
                    end
                    return false
                end

                local ttk = TimeToKill.GetTTK()
                if ttk == nil then return false end

                for _, comp in ipairs(args.comparisons) do
                    if not CleveRoids.operators[comp.operator] then
                        return false
                    end
                    if not CleveRoids.comparators[comp.operator](ttk, comp.amount) then
                        return false
                    end
                end
                return true
            end

            return CleveRoids.ValidateTTK(args.operator, args.amount)
        end, conditionals, "ttk")
    end,

    -- Negated TTK conditional
    nottk = function(conditionals)
        return NegatedMulti(conditionals.nottk, function(args)
            if type(args) ~= "table" then return false end

            if args.comparisons and type(args.comparisons) == "table" then
                if type(TimeToKill) ~= "table" or type(TimeToKill.GetTTK) ~= "function" then
                    if not CleveRoids._ttkErrorShown then
                        DEFAULT_CHAT_FRAME:AddMessage("|cffff0000[SuperCleveRoidMacros]|r The [ttk] conditional requires the TimeToKill addon.", 1, 0.5, 0.5)
                        CleveRoids._ttkErrorShown = true
                    end
                    return true
                end

                local ttk = TimeToKill.GetTTK()
                if ttk == nil then return true end

                for _, comp in ipairs(args.comparisons) do
                    if not CleveRoids.operators[comp.operator] then
                        return true
                    end
                    if not CleveRoids.comparators[comp.operator](ttk, comp.amount) then
                        return true
                    end
                end
                return false
            end

            return not CleveRoids.ValidateTTK(args.operator, args.amount)
        end, conditionals, "nottk")
    end,

    -- Time-To-Execute conditional (requires TimeToKill addon)
    -- Usage: [tte:<5] - true if target will reach 20% HP in less than 5 seconds
    tte = function(conditionals)
        return Multi(conditionals.tte, function(args)
            if type(args) ~= "table" then return false end

            if args.comparisons and type(args.comparisons) == "table" then
                if type(TimeToKill) ~= "table" or type(TimeToKill.GetTTE) ~= "function" then
                    if not CleveRoids._ttkErrorShown then
                        DEFAULT_CHAT_FRAME:AddMessage("|cffff0000[SuperCleveRoidMacros]|r The [tte] conditional requires the TimeToKill addon.", 1, 0.5, 0.5)
                        CleveRoids._ttkErrorShown = true
                    end
                    return false
                end

                local tte = TimeToKill.GetTTE()
                if tte == nil then return false end

                for _, comp in ipairs(args.comparisons) do
                    if not CleveRoids.operators[comp.operator] then
                        return false
                    end
                    if not CleveRoids.comparators[comp.operator](tte, comp.amount) then
                        return false
                    end
                end
                return true
            end

            return CleveRoids.ValidateTTE(args.operator, args.amount)
        end, conditionals, "tte")
    end,

    -- Negated TTE conditional
    notte = function(conditionals)
        return NegatedMulti(conditionals.notte, function(args)
            if type(args) ~= "table" then return false end

            if args.comparisons and type(args.comparisons) == "table" then
                if type(TimeToKill) ~= "table" or type(TimeToKill.GetTTE) ~= "function" then
                    if not CleveRoids._ttkErrorShown then
                        DEFAULT_CHAT_FRAME:AddMessage("|cffff0000[SuperCleveRoidMacros]|r The [tte] conditional requires the TimeToKill addon.", 1, 0.5, 0.5)
                        CleveRoids._ttkErrorShown = true
                    end
                    return true
                end

                local tte = TimeToKill.GetTTE()
                if tte == nil then return true end

                for _, comp in ipairs(args.comparisons) do
                    if not CleveRoids.operators[comp.operator] then
                        return true
                    end
                    if not CleveRoids.comparators[comp.operator](tte, comp.amount) then
                        return true
                    end
                end
                return false
            end

            return not CleveRoids.ValidateTTE(args.operator, args.amount)
        end, conditionals, "notte")
    end,

    -- =========================================================================
    -- CURSIVE ADDON INTEGRATION
    -- =========================================================================
    -- Checks debuffs using Cursive's GUID-based tracking for accurate time remaining
    -- Supports time comparisons: [cursive:Rake>3] [cursive:Rip<5]
    -- Works with multiscan for intelligent target selection

    -- [cursive] - Check if target has ANY Cursive-tracked debuff
    -- [cursive:SpellName] - Check if target has specific debuff tracked by Cursive
    -- [cursive:SpellName>3] - Check if debuff has more than 3 seconds remaining
    -- [cursive:SpellName<5] - Check if debuff has less than 5 seconds remaining
    -- Examples: [cursive:Rake] [@focus,cursive:Rip>5] [cursive:Corruption<3]
    cursive = function(conditionals)
        -- Check if Cursive addon is available
        if not CleveRoids.RequireCursive("cursive") then
            return false
        end

        local target = conditionals.target or "target"

        -- Boolean form [cursive] - check if target has ANY tracked debuff
        if not conditionals.cursive or
           conditionals.cursive == true or
           (type(conditionals.cursive) == "table" and table.getn(conditionals.cursive) == 0) then
            return CleveRoids.HasAnyCursiveDebuff(target)
        end

        -- Spell name form with optional time comparison
        return Multi(conditionals.cursive, function(args)
            if type(args) == "string" then
                -- Simple spell name check: [cursive:Rake]
                return CleveRoids.ValidateCursiveDebuff(target, args, nil, nil)
            elseif type(args) == "table" then
                -- Time comparison: [cursive:Rake>3] or multi-comparison [cursive:Rake>3&<10]
                local spellName = args.name

                -- Handle multi-comparison (e.g., >3&<10)
                if args.comparisons and type(args.comparisons) == "table" then
                    local timeRemaining = CleveRoids.GetCursiveTimeRemaining(target, spellName)
                    -- If debuff not found, treat as 0 seconds remaining (matches [debuff] behavior)
                    if not timeRemaining then timeRemaining = 0 end

                    -- ALL comparisons must pass (AND logic)
                    for _, comp in ipairs(args.comparisons) do
                        if not CleveRoids.operators[comp.operator] then
                            return false
                        end
                        if not CleveRoids.comparators[comp.operator](timeRemaining, comp.amount) then
                            return false
                        end
                    end
                    return true
                end

                -- Single comparison: [cursive:Rake>3]
                return CleveRoids.ValidateCursiveDebuff(target, spellName, args.operator, args.amount)
            end
            return false
        end, conditionals, "cursive")
    end,

    -- [nocursive] - Check if target does NOT have any Cursive-tracked debuff
    -- [nocursive:SpellName] - Check if target does NOT have specific debuff
    -- [nocursive:SpellName>3] - Check if debuff does NOT exist with >3 seconds remaining
    --                          (true if missing OR has <=3 seconds)
    nocursive = function(conditionals)
        -- Check if Cursive addon is available (return true if missing = treat as "no debuff")
        if not CleveRoids.HasCursive() then
            return true
        end

        local target = conditionals.target or "target"

        -- Boolean form [nocursive] - check if target has NO tracked debuffs
        if not conditionals.nocursive or
           conditionals.nocursive == true or
           (type(conditionals.nocursive) == "table" and table.getn(conditionals.nocursive) == 0) then
            return not CleveRoids.HasAnyCursiveDebuff(target)
        end

        -- Negated spell name form
        return NegatedMulti(conditionals.nocursive, function(args)
            if type(args) == "string" then
                -- Simple spell name check: [nocursive:Rake] = true if Rake is missing
                return not CleveRoids.ValidateCursiveDebuff(target, args, nil, nil)
            elseif type(args) == "table" then
                local spellName = args.name

                -- Handle multi-comparison negation
                if args.comparisons and type(args.comparisons) == "table" then
                    local timeRemaining = CleveRoids.GetCursiveTimeRemaining(target, spellName)
                    -- If debuff missing, negation passes
                    if not timeRemaining then return true end

                    -- Negated: true if ANY comparison fails
                    for _, comp in ipairs(args.comparisons) do
                        if not CleveRoids.operators[comp.operator] then
                            return true
                        end
                        if not CleveRoids.comparators[comp.operator](timeRemaining, comp.amount) then
                            return true
                        end
                    end
                    return false
                end

                -- Single comparison negation
                return not CleveRoids.ValidateCursiveDebuff(target, spellName, args.operator, args.amount)
            end
            return true
        end, conditionals, "nocursive")
    end,

    -- Slam clip window conditionals for Warrior Slam rotation optimization
    -- Based on math: MaxSlamPercent = (SwingTimer - SlamCastTime) / SwingTimer * 100
    -- Requires SP_SwingTimer addon and Nampower for cast time lookup

    -- [noslamclip] - True if casting Slam NOW will NOT clip the auto-attack
    -- Usage: /cast [noslamclip] Slam
    noslamclip = function(conditionals)
        return CleveRoids.ValidateNoSlamClip()
    end,

    -- [slamclip] - True if casting Slam NOW WILL clip the auto-attack (negated)
    -- Usage: /cast [slamclip] Heroic Strike  -- Use HS instead when past slam window
    slamclip = function(conditionals)
        return not CleveRoids.ValidateNoSlamClip()
    end,

    -- [nonextslamclip] - True if casting an instant NOW will NOT cause NEXT Slam to clip
    -- Scenario: Skip Slam this swing, cast instant, then Slam next swing without clipping
    -- Formula: MaxInstantPercent = (2 * SwingTimer - SlamCastTime - GCD) / SwingTimer * 100
    -- Usage: /cast [nonextslamclip] Bloodthirst
    nonextslamclip = function(conditionals)
        return CleveRoids.ValidateNoNextSlamClip()
    end,

    -- [nextslamclip] - True if casting an instant NOW WILL cause NEXT Slam to clip (negated)
    -- Usage: Use this when you want to know you're past the instant window
    nextslamclip = function(conditionals)
        return not CleveRoids.ValidateNoNextSlamClip()
    end,

    -- Checks if the target uses a specific power type (mana, rage, energy)
    powertype = function(conditionals)
        local unit = conditionals.target or "target"
        if not UnitExists(unit) then return false end

        return Or(conditionals.powertype, function(powerTypeName)
            local powerType = UnitPowerType(unit)
            local powerTypeLower = string.lower(powerTypeName or "")

            if powerTypeLower == "mana" then
                return powerType == 0
            elseif powerTypeLower == "rage" then
                return powerType == 1
            elseif powerTypeLower == "focus" then
                return powerType == 2
            elseif powerTypeLower == "energy" then
                return powerType == 3
            end

            return false
        end)
    end,

    -- Checks if the target does NOT use a specific power type
    nopowertype = function(conditionals)
        local unit = conditionals.target or "target"
        if not UnitExists(unit) then return true end

        return NegatedMulti(conditionals.nopowertype, function(powerTypeName)
            local powerType = UnitPowerType(unit)
            local powerTypeLower = string.lower(powerTypeName or "")

            if powerTypeLower == "mana" then
                return powerType ~= 0
            elseif powerTypeLower == "rage" then
                return powerType ~= 1
            elseif powerTypeLower == "focus" then
                return powerType ~= 2
            elseif powerTypeLower == "energy" then
                return powerType ~= 3
            end

            return true
        end, conditionals, "nopowertype")
    end,

    -- ========================================================================
    -- CC (Crowd Control) Conditionals - Requires BuffLib for full functionality
    -- ========================================================================

    -- [cc:type] - Check if target has a specific CC effect
    -- Types: stun, fear, root, snare/slow, sleep, charm, polymorph, banish, horror,
    --        disarm, silence, daze, sap, freeze, knockout/incap, disorient, shackle
    -- Special: [cc] or [cc:any] checks for any loss-of-control effect
    -- Examples: [cc:stun] [@focus,cc:fear] [cc:stun/fear/root]
    cc = function(conditionals)
        local target = conditionals.target or "target"

        -- If no specific CC type, check for ANY loss-of-control
        if not conditionals.cc or (type(conditionals.cc) == "table" and table.getn(conditionals.cc) == 0) then
            return CleveRoids.ValidateUnitAnyCrowdControl(target)
        end

        -- Check for specific CC type(s) - OR logic
        return Or(conditionals.cc, function(ccType)
            return CleveRoids.ValidateUnitCC(target, ccType)
        end)
    end,

    -- [nocc:type] - Check if target does NOT have a specific CC effect
    -- Uses AND logic for negation: [nocc:stun/fear] = not stunned AND not feared
    nocc = function(conditionals)
        local target = conditionals.target or "target"

        -- If no specific CC type, check for NO loss-of-control
        if not conditionals.nocc or (type(conditionals.nocc) == "table" and table.getn(conditionals.nocc) == 0) then
            return not CleveRoids.ValidateUnitAnyCrowdControl(target)
        end

        -- Check for absence of specific CC type(s) - AND logic (must be missing ALL)
        return NegatedMulti(conditionals.nocc, function(ccType)
            return not CleveRoids.ValidateUnitCC(target, ccType)
        end, conditionals, "nocc")
    end,

    -- [mycc:type] - Check if PLAYER has a specific CC effect
    -- Same types as [cc], but always checks the player
    -- Examples: [mycc:stun] [mycc:fear/charm] [mycc] (any CC)
    mycc = function(conditionals)
        -- If no specific CC type, check for ANY loss-of-control on player
        if not conditionals.mycc or (type(conditionals.mycc) == "table" and table.getn(conditionals.mycc) == 0) then
            return CleveRoids.ValidateUnitAnyCrowdControl("player")
        end

        -- Check for specific CC type(s) - OR logic
        return Or(conditionals.mycc, function(ccType)
            return CleveRoids.ValidateUnitCC("player", ccType)
        end)
    end,

    -- [nomycc:type] - Check if PLAYER does NOT have a specific CC effect
    -- Uses AND logic for negation: [nomycc:stun/fear] = not stunned AND not feared
    nomycc = function(conditionals)
        -- If no specific CC type, check for NO loss-of-control on player
        if not conditionals.nomycc or (type(conditionals.nomycc) == "table" and table.getn(conditionals.nomycc) == 0) then
            return not CleveRoids.ValidateUnitAnyCrowdControl("player")
        end

        -- Check for absence of specific CC type(s) - AND logic
        return NegatedMulti(conditionals.nomycc, function(ccType)
            return not CleveRoids.ValidateUnitCC("player", ccType)
        end, conditionals, "nomycc")
    end,

    -- ========================================================================
    -- RESIST TRACKING CONDITIONALS
    -- ========================================================================

    -- [resisted] - Check if last spell was resisted by current target
    -- [resisted:type] - Check for specific resist type (full, partial)
    -- [resisted:full/partial] - OR logic for multiple types
    -- Examples: [resisted] [@target,resisted:full] [resisted:partial]
    resisted = function(conditionals)
        -- If no specific resist type, check for ANY resist on current target
        if not conditionals.resisted or
           conditionals.resisted == true or
           (type(conditionals.resisted) == "table" and table.getn(conditionals.resisted) == 0) then
            return CleveRoids.CheckResistState(nil)
        end

        -- Check for specific resist type(s) - OR logic
        return Multi(conditionals.resisted, function(resistType)
            return CleveRoids.CheckResistState(resistType)
        end, conditionals, "resisted")
    end,

    -- [noresisted] - Check if last spell was NOT resisted by current target
    -- [noresisted:type] - Check target does NOT have specific resist type
    -- [noresisted:full/partial] - AND logic: not full AND not partial
    noresisted = function(conditionals)
        -- If no specific resist type, check for NO resist on current target
        if not conditionals.noresisted or
           conditionals.noresisted == true or
           (type(conditionals.noresisted) == "table" and table.getn(conditionals.noresisted) == 0) then
            return not CleveRoids.CheckResistState(nil)
        end

        -- Check for absence of specific resist type(s) - AND logic
        return NegatedMulti(conditionals.noresisted, function(resistType)
            return not CleveRoids.CheckResistState(resistType)
        end, conditionals, "noresisted")
    end,

    -- ========================================================================
    -- EXACT NAME MATCHING CONDITIONALS
    -- ========================================================================

    -- [name:UnitName] - Check if target's name EXACTLY matches (case-insensitive)
    -- Unlike /target which fuzzy-matches, this requires an exact match
    -- Supports underscores for spaces: [name:Onyxia] or [name:Kor_kron_Elite]
    -- Multi-value OR: [name:Onyxia/Nefarian] = Onyxia OR Nefarian
    -- Examples: [name:Onyxia] [@focus,name:Ragnaros] [name:"Kor'kron Elite"]
    name = function(conditionals)
        local target = conditionals.target or "target"

        -- Unit must exist
        if not UnitExists(target) then
            return false
        end

        local unitName = UnitName(target)
        if not unitName then
            return false
        end

        -- Lowercase for case-insensitive comparison
        local unitNameLower = string.lower(unitName)

        -- Check for exact match with any provided name (OR logic)
        return Or(conditionals.name, function(requiredName)
            -- Normalize underscores to spaces and lowercase
            local normalizedRequired = string.lower(CleveRoids.NormalizeName(requiredName))
            return unitNameLower == normalizedRequired
        end)
    end,

    -- [noname:UnitName] - Check if target's name does NOT match (case-insensitive)
    -- Uses AND logic: [noname:Onyxia/Nefarian] = not Onyxia AND not Nefarian
    -- Examples: [noname:Onyxia] [@mouseover,noname:"Training Dummy"]
    noname = function(conditionals)
        local target = conditionals.target or "target"

        -- No unit = no name = passes the "not this name" check
        if not UnitExists(target) then
            return true
        end

        local unitName = UnitName(target)
        if not unitName then
            return true
        end

        -- Lowercase for case-insensitive comparison
        local unitNameLower = string.lower(unitName)

        -- Check that name does NOT match any provided name (AND logic - must not match ALL)
        return NegatedMulti(conditionals.noname, function(forbiddenName)
            -- Normalize underscores to spaces and lowercase
            local normalizedForbidden = string.lower(CleveRoids.NormalizeName(forbiddenName))
            return unitNameLower ~= normalizedForbidden
        end, conditionals, "noname")
    end,

    -- ========================================================================
    -- AUTO-ATTACK CONDITIONALS (Nampower v2.24+)
    -- ========================================================================
    -- Requires NP_EnableAutoAttackEvents=1 CVar

    -- [lastswing:type] - Check result of player's last melee swing
    -- Types: crit, glancing, miss, dodge, parry, blocked, offhand/oh, mainhand/mh, hit
    -- Time check: [lastswing:<2] = last swing was within 2 seconds
    -- Multi-value: [lastswing:crit/glancing] = was crit OR glancing (OR logic)
    -- Examples: [lastswing:dodge] [@target,lastswing:crit] [lastswing:offhand]
    lastswing = function(conditionals)
        -- Boolean form [lastswing] - any recent swing
        if not conditionals.lastswing or
           conditionals.lastswing == true or
           (type(conditionals.lastswing) == "table" and table.getn(conditionals.lastswing) == 0) then
            return CleveRoids.ValidateLastSwing(nil, nil, nil)
        end

        -- Check for specific swing type(s) - OR logic
        return Or(conditionals.lastswing, function(args)
            if type(args) == "string" then
                return CleveRoids.ValidateLastSwing(args, nil, nil)
            elseif type(args) == "table" then
                return CleveRoids.ValidateLastSwing(args.name, args.operator, args.amount)
            end
            return false
        end)
    end,

    -- [nolastswing:type] - Check that last swing was NOT a specific type
    -- Uses AND logic: [nolastswing:crit/glancing] = was NOT crit AND NOT glancing
    nolastswing = function(conditionals)
        -- Boolean form [nolastswing] - no recent swing
        if not conditionals.nolastswing or
           conditionals.nolastswing == true or
           (type(conditionals.nolastswing) == "table" and table.getn(conditionals.nolastswing) == 0) then
            return not CleveRoids.ValidateLastSwing(nil, nil, nil)
        end

        -- Check that swing was NOT any of the specified types - AND logic
        return NegatedMulti(conditionals.nolastswing, function(args)
            if type(args) == "string" then
                return not CleveRoids.ValidateLastSwing(args, nil, nil)
            elseif type(args) == "table" then
                return not CleveRoids.ValidateLastSwing(args.name, args.operator, args.amount)
            end
            return true
        end, conditionals, "nolastswing")
    end,

    -- [incominghit:type] - Check result of last attack received by player
    -- Types: crit, crushing, glancing, miss, dodge, parry, blocked, hit
    -- Time check: [incominghit:<1] = received hit within last 1 second
    -- Examples: [incominghit:crushing] [incominghit:crit/crushing] [incominghit:dodge]
    incominghit = function(conditionals)
        -- Boolean form [incominghit] - any recent incoming hit
        if not conditionals.incominghit or
           conditionals.incominghit == true or
           (type(conditionals.incominghit) == "table" and table.getn(conditionals.incominghit) == 0) then
            return CleveRoids.ValidateIncomingHit(nil, nil, nil)
        end

        -- Check for specific hit type(s) - OR logic
        return Or(conditionals.incominghit, function(args)
            if type(args) == "string" then
                return CleveRoids.ValidateIncomingHit(args, nil, nil)
            elseif type(args) == "table" then
                return CleveRoids.ValidateIncomingHit(args.name, args.operator, args.amount)
            end
            return false
        end)
    end,

    -- [noincominghit:type] - Check that last incoming hit was NOT a specific type
    noincominghit = function(conditionals)
        -- Boolean form [noincominghit] - no recent incoming hit
        if not conditionals.noincominghit or
           conditionals.noincominghit == true or
           (type(conditionals.noincominghit) == "table" and table.getn(conditionals.noincominghit) == 0) then
            return not CleveRoids.ValidateIncomingHit(nil, nil, nil)
        end

        -- Check that hit was NOT any of the specified types - AND logic
        return NegatedMulti(conditionals.noincominghit, function(args)
            if type(args) == "string" then
                return not CleveRoids.ValidateIncomingHit(args, nil, nil)
            elseif type(args) == "table" then
                return not CleveRoids.ValidateIncomingHit(args.name, args.operator, args.amount)
            end
            return true
        end, conditionals, "noincominghit")
    end,

    -- ========================================================================
    -- AURA CAP CONDITIONALS (Nampower v2.20+ with AURA_CAST events)
    -- ========================================================================
    -- Requires NP_EnableAuraCastEvents=1 CVar for accurate tracking
    -- Falls back to manual counting if events unavailable

    -- [mybuffcapped] - Player's buff bar is at capacity (32 buffs)
    -- Usage: [mybuffcapped] to prevent buff waste
    mybuffcapped = function(conditionals)
        return CleveRoids.IsPlayerBuffCapped()
    end,

    -- [nomybuffcapped] - Player's buff bar has room
    nomybuffcapped = function(conditionals)
        return not CleveRoids.IsPlayerBuffCapped()
    end,

    -- [mydebuffcapped] - Player's debuff bar is at capacity (16 debuffs)
    mydebuffcapped = function(conditionals)
        return CleveRoids.IsPlayerDebuffCapped()
    end,

    -- [nomydebuffcapped] - Player's debuff bar has room
    nomydebuffcapped = function(conditionals)
        return not CleveRoids.IsPlayerDebuffCapped()
    end,

    -- [debuffcapped] - Target's debuff bar is at capacity
    -- For NPCs: 16 debuff slots (+ 32 overflow into buff slots = 48 visual total)
    -- Usage: [debuffcapped] to stop DoT spam when target is capped
    debuffcapped = function(conditionals)
        local target = conditionals.target or "target"
        return CleveRoids.IsTargetDebuffCapped(target)
    end,

    -- [nodebuffcapped] - Target's debuff bar has room
    nodebuffcapped = function(conditionals)
        local target = conditionals.target or "target"
        return not CleveRoids.IsTargetDebuffCapped(target)
    end,

    -- [buffcapped] - Target's buff bar is at capacity (32 buffs)
    buffcapped = function(conditionals)
        local target = conditionals.target or "target"
        return CleveRoids.IsTargetBuffCapped(target)
    end,

    -- [nobuffcapped] - Target's buff bar has room
    nobuffcapped = function(conditionals)
        local target = conditionals.target or "target"
        return not CleveRoids.IsTargetBuffCapped(target)
    end
}

-- =============================================================================
-- MULTISCAN SYSTEM
-- =============================================================================
-- [multiscan:priority] - Scan nearby enemies and find best target matching priority
-- Requires UnitXP_SP3 for enemy enumeration
-- Uses SuperWoW for soft-casting (CastSpellByName with GUID)

-- Raid mark indices (WoW API GetRaidTargetIndex values)
CleveRoids.RAID_MARKS = {
    star = 1, circle = 2, diamond = 3, triangle = 4,
    moon = 5, square = 6, cross = 7, skull = 8,
}

-- Priority types for multiscan
-- String values = custom handling, number values = raid mark index
CleveRoids.MULTISCAN_PRIORITIES = {
    -- Distance-based (use UnitXP direct targeting where possible)
    nearest   = "nearest",
    farthest  = "farthest",
    -- Health percentage
    highesthp = "highesthp",
    lowesthp  = "lowesthp",
    -- Raw health value
    highestrawhp = "highestrawhp",
    lowestrawhp  = "lowestrawhp",
    -- Raid mark order (skull → cross → square → moon → triangle → diamond → circle → star)
    markorder = "markorder",
    -- Individual raid marks (direct unit reference via SuperWoW "mark#" tokens)
    skull    = 8, cross = 7, square = 6, moon = 5,
    triangle = 4, diamond = 3, circle = 2, star = 1,
}

-- Static conditionals that don't depend on target (checked before scanning)
CleveRoids.STATIC_CONDITIONALS = {
    group = true, nogroup = true,
    combat = true, nocombat = true,
    zone = true, nozone = true,
    stealth = true, nostealth = true,
    form = true, noform = true, stance = true, nostance = true,
    equipped = true, noequipped = true,
    mod = true, nomod = true,
    swimming = true, noswimming = true,
    resting = true, noresting = true,
}

--- Calculate score for a unit based on priority type
--- @param unit string Unit token or GUID
--- @param priority string Priority type (e.g., "nearest", "highesthp")
--- @param currentTargetGuid string|nil GUID of player's current target (exempt from combat check)
--- @param specifiedUnitGuid string|nil GUID of @unit specified in macro (also exempt from combat check)
--- @return number|nil Score (lower = better) or nil if invalid candidate
function CleveRoids.GetMultiscanScore(unit, priority, currentTargetGuid, specifiedUnitGuid)
    if not unit or not UnitExists(unit) then return nil end
    if UnitIsDeadOrGhost(unit) then return nil end

    -- Must be attackable
    if not UnitCanAttack("player", unit) then return nil end

    -- Combat check: must be in combat with player, UNLESS it's current target OR specified @unit
    local _, unitGuid = UnitExists(unit)
    local isCurrentTarget = currentTargetGuid and unitGuid == currentTargetGuid
    local isSpecifiedUnit = specifiedUnitGuid and unitGuid == specifiedUnitGuid
    if not isCurrentTarget and not isSpecifiedUnit and not UnitAffectingCombat(unit) then
        return nil
    end

    -- Calculate score based on priority
    if priority == "nearest" then
        if CleveRoids.hasUnitXP then
            local distance = UnitXP("distanceBetween", "player", unit)
            return distance or 9999
        end
        return 0  -- No distance info, treat as equal

    elseif priority == "farthest" then
        if CleveRoids.hasUnitXP then
            local distance = UnitXP("distanceBetween", "player", unit)
            return distance and -distance or -9999
        end
        return 0

    elseif priority == "highesthp" then
        local maxHp = UnitHealthMax(unit)
        if maxHp <= 0 then return nil end
        local hpPct = 100 * UnitHealth(unit) / maxHp
        return -hpPct  -- Negative so highest becomes lowest score

    elseif priority == "lowesthp" then
        local maxHp = UnitHealthMax(unit)
        if maxHp <= 0 then return nil end
        local hpPct = 100 * UnitHealth(unit) / maxHp
        return hpPct

    elseif priority == "highestrawhp" then
        local rawHp = UnitHealth(unit)
        return -rawHp  -- Negative so highest becomes lowest score

    elseif priority == "lowestrawhp" then
        local rawHp = UnitHealth(unit)
        return rawHp
    end

    return 0  -- Unknown priority, treat as equal
end

--- Check if a candidate passes all target-dependent conditionals
--- @param conditionals table The conditionals table
--- @param candidateUnit string Unit token or GUID to test
--- @return boolean True if candidate passes all conditionals
function CleveRoids.ValidateMultiscanCandidate(conditionals, candidateUnit)
    local originalTarget = conditionals.target
    conditionals.target = candidateUnit

    local passes = true
    for k, _ in pairs(conditionals) do
        -- Skip static conditionals (already checked) and metadata
        if not CleveRoids.ignoreKeywords[k] and not CleveRoids.STATIC_CONDITIONALS[k] then
            local fn = CleveRoids.Keywords[k]
            if fn and not fn(conditionals) then
                passes = false
                break
            end
        end
    end

    conditionals.target = originalTarget
    return passes
end

--- Check static conditionals before scanning
--- @param conditionals table The conditionals table
--- @return boolean True if all static conditionals pass
function CleveRoids.CheckStaticConditionals(conditionals)
    for k, _ in pairs(conditionals) do
        if CleveRoids.STATIC_CONDITIONALS[k] then
            local fn = CleveRoids.Keywords[k]
            if fn and not fn(conditionals) then
                return false
            end
        end
    end
    return true
end

--- Main multiscan resolution function
--- Scans enemies using UnitXP, finds best target matching priority and conditionals
--- @param conditionals table The conditionals table containing multiscan value
--- @param specifiedUnit string|nil The @unit specified in the macro (exempt from combat check)
--- @return string|nil GUID of best target, or nil if none found
function CleveRoids.ResolveMultiscanTarget(conditionals, specifiedUnit)
    -- Require UnitXP for enemy scanning
    if not CleveRoids.hasUnitXP then
        return nil
    end

    -- Parse priority from conditionals.multiscan
    local priority = nil
    if type(conditionals.multiscan) == "table" then
        priority = conditionals.multiscan[1]
    elseif type(conditionals.multiscan) == "string" then
        priority = conditionals.multiscan
    end

    if not priority then return nil end
    priority = string.lower(CleveRoids.Trim(priority))

    -- Validate priority type
    local priorityType = CleveRoids.MULTISCAN_PRIORITIES[priority]
    if not priorityType then
        CleveRoids.Print("|cffff0000[multiscan]|r Unknown priority: " .. priority)
        return nil
    end

    -- Check static conditionals first (group, combat, zone, etc.)
    if not CleveRoids.CheckStaticConditionals(conditionals) then
        return nil
    end

    -- Save current target for restoration and combat-check exemption
    local currentTargetGuid = nil
    if UnitExists("target") then
        local _, guid = UnitExists("target")
        currentTargetGuid = guid
    end

    -- Resolve specified @unit GUID (also exempt from combat check)
    local specifiedUnitGuid = nil
    if specifiedUnit and UnitExists(specifiedUnit) then
        local _, guid = UnitExists(specifiedUnit)
        specifiedUnitGuid = guid
    end

    -- Handle raid mark priorities (direct unit reference)
    if type(priorityType) == "number" then
        local markUnit = "mark" .. priorityType
        if UnitExists(markUnit) and UnitCanAttack("player", markUnit) then
            -- Validate against target-dependent conditionals
            if CleveRoids.ValidateMultiscanCandidate(conditionals, markUnit) then
                local _, guid = UnitExists(markUnit)
                return guid
            end
        end
        return nil  -- Raid mark not found or doesn't pass conditionals
    end

    -- Handle markorder priority (skull → cross → square → moon → triangle → diamond → circle → star)
    if priorityType == "markorder" then
        -- Iterate marks from skull (8) down to star (1) in standard kill order
        for markIndex = 8, 1, -1 do
            local markUnit = "mark" .. markIndex
            if UnitExists(markUnit) and UnitCanAttack("player", markUnit) then
                -- Validate against target-dependent conditionals
                if CleveRoids.ValidateMultiscanCandidate(conditionals, markUnit) then
                    local _, guid = UnitExists(markUnit)
                    return guid
                end
            end
        end
        return nil  -- No valid marked target found
    end

    -- Handle UnitXP direct targeting for simple priorities
    if priorityType == "nearest" then
        -- If no specified unit, use UnitXP's nearestEnemy directly for efficiency
        if not specifiedUnitGuid then
            local found = UnitXP("target", "nearestEnemy")
            if found and UnitExists("target") then
                local _, foundGuid = UnitExists("target")
                -- Restore original target
                if currentTargetGuid then
                    TargetUnit(currentTargetGuid)
                else
                    ClearTarget()
                end
                -- Validate the found target
                if CleveRoids.ValidateMultiscanCandidate(conditionals, foundGuid) then
                    return foundGuid
                end
            end
            -- Restore target if nearestEnemy failed
            if currentTargetGuid then
                TargetUnit(currentTargetGuid)
            else
                ClearTarget()
            end
            return nil
        end
        -- Fall through to custom scan if there's a specified unit to consider
    end

    if priorityType == "highesthp" then
        -- If no specified unit, try UnitXP's mostHP directly for efficiency
        if not specifiedUnitGuid then
            local found = UnitXP("target", "mostHP")
            if found and UnitExists("target") then
                local _, foundGuid = UnitExists("target")
                -- Restore original target
                if currentTargetGuid then
                    TargetUnit(currentTargetGuid)
                else
                    ClearTarget()
                end
                -- Validate the found target
                if CleveRoids.ValidateMultiscanCandidate(conditionals, foundGuid) then
                    return foundGuid
                end
            end
            -- Restore target if mostHP failed validation
            if currentTargetGuid then
                TargetUnit(currentTargetGuid)
            else
                ClearTarget()
            end
        end
        -- Fall through to custom scan if there's a specified unit or built-in didn't pass validation
    end

    -- Custom scan for complex priorities (lowesthp, highestrawhp, lowestrawhp, farthest)
    -- Also used as fallback if UnitXP direct targeting didn't pass validation
    local candidates = {}  -- { { guid = X, score = Y }, ... }
    local seenGuids = {}

    -- Helper to evaluate a candidate
    local function evaluateCandidate(unit)
        if not UnitExists(unit) then return end

        local _, guid = UnitExists(unit)
        if not guid or seenGuids[guid] then return end
        seenGuids[guid] = true

        -- Cache GUID -> name mapping for immunity checks
        -- This is needed because immune enemies may never have debuffs tracked,
        -- but we still need their name for immunity lookups
        local unitName = UnitName(unit)
        if unitName and unitName ~= "" and unitName ~= "Unknown" then
            local lib = CleveRoids.libdebuff
            if lib and lib.guidToName then
                local normalizedGuid = CleveRoids.NormalizeGUID(guid)
                if normalizedGuid then
                    lib.guidToName[normalizedGuid] = unitName
                end
            end
        end

        local score = CleveRoids.GetMultiscanScore(unit, priorityType, currentTargetGuid, specifiedUnitGuid)
        if not score then return end

        -- Validate against target-dependent conditionals
        if CleveRoids.ValidateMultiscanCandidate(conditionals, guid) then
            table.insert(candidates, { guid = guid, score = score })
        end
    end

    -- Always consider current target (exempt from combat check via GetMultiscanScore)
    if currentTargetGuid then
        evaluateCandidate("target")
    end

    -- Also consider specified @unit (exempt from combat check via GetMultiscanScore)
    if specifiedUnitGuid and specifiedUnitGuid ~= currentTargetGuid then
        evaluateCandidate(specifiedUnit)
    end

    -- Scan via UnitXP enemy iteration
    local firstGuid = nil
    local maxIterations = 50

    for i = 1, maxIterations do
        local found = UnitXP("target", "nextEnemyConsideringDistance")
        if not found then break end

        if not UnitExists("target") then break end
        local _, currentGuid = UnitExists("target")
        if not currentGuid then break end

        if firstGuid == nil then
            firstGuid = currentGuid
        elseif currentGuid == firstGuid then
            break  -- Completed full cycle
        end

        evaluateCandidate("target")
    end

    -- Restore original target
    if currentTargetGuid then
        TargetUnit(currentTargetGuid)
    else
        ClearTarget()
    end

    -- Find best candidate (lowest score wins)
    if table.getn(candidates) == 0 then
        return nil
    end

    table.sort(candidates, function(a, b) return a.score < b.score end)
    return candidates[1].guid
end
--[[
	Author: Dennis Werner Garske (DWG) / brian / Mewtiny / brian / Mewtiny
	License: MIT License
]]

-- DEBUG: Error catcher for "attempt to index a function value"
-- Remove this block once the error is identified
local _G = _G or getfenv(0)
local originalErrorHandler = geterrorhandler and geterrorhandler()
if seterrorhandler then
    seterrorhandler(function(msg)
        if msg and string.find(msg, "index a function value") then
            local trace = debugstack and debugstack(2, 20, 0) or "no stack available"
            DEFAULT_CHAT_FRAME:AddMessage("|cFFFF0000[SCRM DEBUG] index function error:|r " .. tostring(msg))
            DEFAULT_CHAT_FRAME:AddMessage("|cFFFFFF00Stack:|r " .. tostring(trace))
        end
        if originalErrorHandler then
            return originalErrorHandler(msg)
        end
    end)
end

-- Setup to wrap our stuff in a table so we don't pollute the global environment
local CleveRoids = _G.CleveRoids or {}
_G.CleveRoids = CleveRoids
CleveRoids.lastItemIndexTime = 0
CleveRoids.initializationTimer = nil
CleveRoids.isActionUpdateQueued = true
CleveRoids.lastEquipTime = CleveRoids.lastEquipTime or {}
CleveRoids.lastWeaponSwapTime = 0
CleveRoids.equipInProgress = false

-- PERFORMANCE: Event throttling to reduce spam from high-frequency events
CleveRoids.lastUnitAuraUpdate = 0
CleveRoids.lastUnitHealthUpdate = 0
CleveRoids.lastUnitPowerUpdate = 0
CleveRoids.EVENT_THROTTLE = 0.1  -- 100ms throttle for high-frequency events

-- PERFORMANCE: Spell ID cache to avoid repeated GetSpellIdForName lookups
CleveRoids.spellIdCache = {}

-- PERFORMANCE: Spell name construction cache
CleveRoids.spellNameCache = {}

-- PERFORMANCE: Upvalues for frequently called global functions (avoid global lookups)
local GetTime = GetTime
local UnitExists = UnitExists
local UnitAffectingCombat = UnitAffectingCombat
local GetContainerItemLink = GetContainerItemLink
local GetContainerItemInfo = GetContainerItemInfo
local GetContainerNumSlots = GetContainerNumSlots
local GetInventoryItemLink = GetInventoryItemLink
local GetItemInfo = GetItemInfo
local PickupContainerItem = PickupContainerItem
local PickupInventoryItem = PickupInventoryItem
local EquipCursorItem = EquipCursorItem
local CursorHasItem = CursorHasItem
local ClearCursor = ClearCursor
local TargetUnit = TargetUnit
local pcall = pcall
local pairs = pairs
local ipairs = ipairs
local type = type
local tonumber = tonumber
local tostring = tostring
local string_find = string.find
local string_lower = string.lower
local string_gsub = string.gsub
local table_insert = table.insert
local table_getn = table.getn

-- PERFORMANCE: Module-level constant for boolean conditionals (avoid per-call table creation)
local BOOLEAN_CONDITIONALS = {
    combat = true,
    nocombat = true,
    stealth = true,
    nostealth = true,
    channeled = true,
    nochanneled = true,
    checkchanneled = true,
    checkcasting = true,
    dead = true,
    alive = true,
    help = true,
    harm = true,
    exists = true,
    party = true,
    raid = true,
    resting = true,
    noresting = true,
    isplayer = true,
    isnpc = true,
    mhimbue = true,
    nomhimbue = true,
    ohimbue = true,
    noohimbue = true,
    group = true,
    nogroup = true,
}

local requirementCheckFrame = CreateFrame("Frame")
requirementCheckFrame:RegisterEvent("ADDON_LOADED")
requirementCheckFrame:SetScript("OnEvent", function()
    if arg1 ~= "SuperCleveRoidMacros" then return end

    -- Check requirements immediately when our addon loads
    local hasSuperwow = CleveRoids.hasSuperwow
    local hasNampower = (IsSpellInRange ~= nil)
    local hasUnitXP = pcall(UnitXP, "nop", "nop")

    if not hasSuperwow or not hasNampower or not hasUnitXP then
        -- Show errors
        if not hasSuperwow then
            CleveRoids.Print("|cFFFF0000SuperCleveRoidMacros|r requires |cFF00FFFFbalakethelock's SuperWoW|r:")
            CleveRoids.Print("https://github.com/balakethelock/SuperWoW")
        end
        if not hasNampower then
            CleveRoids.Print("|cFFFF0000SuperCleveRoidMacros|r requires |cFF00FFFFAvitasia's Nampower|r:")
            CleveRoids.Print("https://gitea.com/avitasia/nampower")
        end
        if not hasUnitXP then
            CleveRoids.Print("|cFFFF0000SuperCleveRoidMacros|r requires |cFF00FFFFKonaka's UnitXP_SP3|r:")
            CleveRoids.Print("https://codeberg.org/konaka/UnitXP_SP3")
        end

        -- Disable immediately
        CleveRoids.DisableAddon("Missing Requirements")

        -- Unregister this check frame
        this:UnregisterAllEvents()
        return
    end

    -- Requirements met - allow normal initialization
    CleveRoids.Print("|cFF4477FFSuperCleveR|r|cFFFFFFFFoid Macros|r |cFF00FF00Loaded|r - See the README.")

    -- Unregister this check frame
    this:UnregisterAllEvents()
end)

local SLOT_TO_INVID = {
    ["MainHandSlot"] = 16,
    ["SecondaryHandSlot"] = 17,
    ["RangedSlot"] = 18,
    ["HeadSlot"] = 1,
    ["NeckSlot"] = 2,
    ["ShoulderSlot"] = 3,
    ["ChestSlot"] = 5,
    ["WaistSlot"] = 6,
    ["LegsSlot"] = 7,
    ["FeetSlot"] = 8,
    ["WristSlot"] = 9,
    ["HandsSlot"] = 10,
    ["Finger0Slot"] = 11,
    ["Finger1Slot"] = 12,
    ["Trinket0Slot"] = 13,
    ["Trinket1Slot"] = 14,
    ["BackSlot"] = 15,
    ["ShirtSlot"] = 4,
    ["TabardSlot"] = 19,
}

local function GetInventoryIdFromSlot(slotName)
    return SLOT_TO_INVID[slotName] or GetInventorySlotInfo(slotName)
end

-- Check if slot 18 is a relic (no GCD) for current player class
local function IsRelicSlot(slot)
    if slot ~= 18 then return false end
    local playerClass = CleveRoids.playerClass
    return playerClass == "PALADIN" or playerClass == "DRUID" or playerClass == "SHAMAN"
end

-- PERFORMANCE: Cache GetTime() result for cooldown checks within same frame
-- Slot 18 (relic/idol/libram/totem) has no GCD for Paladin/Druid/Shaman
local function IsSlotOnCooldown(slot, now)
    -- Relics have no GCD - skip cooldown check entirely
    if IsRelicSlot(slot) then
        return false
    end

    now = now or GetTime()
    local slotTime = CleveRoids.lastEquipTime[slot] or 0
    local globalTime = CleveRoids.lastGlobalEquipTime or 0

    return (now - slotTime) < CleveRoids.EQUIP_COOLDOWN or
           (now - globalTime) < CleveRoids.EQUIP_GLOBAL_COOLDOWN
end

-- PERFORMANCE: Consolidated cursor handling, fewer CursorHasItem() calls
local function PerformEquipSwap(item, inventoryId, useQueueScript)
    if not item or not inventoryId then return false end

    -- Check if in combat and swapping weapons
    -- Slot 18 (ranged) is only a weapon for Hunter/Warrior/Rogue/Mage/Warlock/Priest
    -- For Druid/Paladin/Shaman, slot 18 is idol/libram/totem - can swap freely
    local isWeapon = (inventoryId == 16 or inventoryId == 17)
    if inventoryId == 18 then
        -- Use cached playerClass for performance
        local playerClass = CleveRoids.playerClass
        -- Only treat slot 18 as weapon for classes that use ranged weapons
        isWeapon = (playerClass == "HUNTER" or playerClass == "WARRIOR" or
                    playerClass == "ROGUE" or playerClass == "MAGE" or
                    playerClass == "WARLOCK" or playerClass == "PRIEST")
    end

    if isWeapon and UnitAffectingCombat("player") then
        -- Don't swap while casting
        if CleveRoids.CurrentSpell.type ~= "" then
            return false
        end

        -- Check for on-swing spells if available (Nampower)
        if GetCurrentCastingInfo then
            local castId, _, _, casting, channeling, onswing = GetCurrentCastingInfo()

            if onswing == 1 then
                return false
            end

            -- If casting/channeling and QueueScript available, queue the swap for after cast
            if (casting == 1 or channeling == 1) and QueueScript and useQueueScript and item.name then
                local script = string.format('EquipItemByName("%s",%d)', item.name, inventoryId)
                QueueScript(script, 3)  -- Priority 3 = after queued spells
                return true
            end
        end
    end

    -- PERFORMANCE: Try EquipItemByName first if available (handles everything internally)
    if item.name and EquipItemByName then
        local ok = pcall(EquipItemByName, item.name, inventoryId)
        if ok then return true end
    end

    -- Fallback: Manual pickup and equip
    if item.bagID and item.slot then
        PickupContainerItem(item.bagID, item.slot)
    elseif item.inventoryID then
        PickupInventoryItem(item.inventoryID)
    else
        return false
    end

    -- Single cursor check after pickup attempt
    if not CursorHasItem() then
        return false
    end

    EquipCursorItem(inventoryId)
    local success = not CursorHasItem()
    ClearCursor()
    return success
end

-- PERFORMANCE: Get a queue entry from pool or create new
local function GetQueueEntry()
    local pool = CleveRoids.queueEntryPool
    local n = pool and table_getn(pool) or 0
    if n > 0 then
        local entry = pool[n]
        pool[n] = nil
        return entry
    end
    return {}
end

-- PERFORMANCE: Return entry to pool for reuse
local function ReleaseQueueEntry(entry)
    if not entry then return end
    -- Clear the entry (set to nil, don't create new table)
    entry.item = nil
    entry.slotName = nil
    entry.inventoryId = nil
    entry.queueTime = nil
    entry.retries = nil
    entry.maxRetries = nil
    entry.itemId = nil
    -- Add to pool (max 10 pooled entries)
    local pool = CleveRoids.queueEntryPool
    if table_getn(pool) < 10 then
        table_insert(pool, entry)
    end
end

-- PERFORMANCE: Swap-and-pop removal (O(1) instead of O(n))
local function RemoveQueueEntry(i)
    local queue = CleveRoids.equipmentQueue
    local n = CleveRoids.equipmentQueueLen
    local entry = queue[i]

    if i < n then
        queue[i] = queue[n]
    end
    queue[n] = nil
    CleveRoids.equipmentQueueLen = n - 1

    ReleaseQueueEntry(entry)
end

-- Queue equipment swap function
function CleveRoids.QueueEquipItem(item, slotName)
    if not item or not slotName then return false end

    local inventoryId = GetInventoryIdFromSlot(slotName)
    if not inventoryId then return false end

    local now = GetTime()
    local itemId = item.id

    -- PERFORMANCE: Check for duplicate queue entries before adding
    local queue = CleveRoids.equipmentQueue
    local queueLen = CleveRoids.equipmentQueueLen
    for i = 1, queueLen do
        local q = queue[i]
        if q and q.inventoryId == inventoryId and q.itemId == itemId then
            return false  -- Already queued
        end
    end

    -- Try immediate equip if not on cooldown (use QueueScript for smoother mid-cast swaps)
    if not IsSlotOnCooldown(inventoryId, now) then
        local success = PerformEquipSwap(item, inventoryId, true)

        if success then
            -- Don't set cooldowns for relic slots (no GCD)
            if not IsRelicSlot(inventoryId) then
                CleveRoids.lastEquipTime[inventoryId] = now
                CleveRoids.lastGlobalEquipTime = now
            end
            return true
        end
    end

    -- Queue for later using pooled entry
    local entry = GetQueueEntry()
    entry.item = item
    entry.slotName = slotName
    entry.inventoryId = inventoryId
    entry.queueTime = now
    entry.retries = 0
    entry.maxRetries = 5
    entry.itemId = itemId

    CleveRoids.equipmentQueueLen = queueLen + 1
    queue[CleveRoids.equipmentQueueLen] = entry

    -- PERFORMANCE: Start the queue processing frame
    if CleveRoids.equipQueueFrame then
        CleveRoids.equipQueueFrame:Show()
    end

    return false
end

-- PERFORMANCE: Process equipment queue (called from self-disabling frame)
function CleveRoids.ProcessEquipmentQueue()
    local queueLen = CleveRoids.equipmentQueueLen
    if queueLen == 0 then return end

    local now = GetTime()
    local queue = CleveRoids.equipmentQueue
    local i = 1

    while i <= CleveRoids.equipmentQueueLen do
        local queued = queue[i]

        -- Remove expired entries first (>10 seconds old)
        if (now - queued.queueTime) > 10 then
            RemoveQueueEntry(i)
            -- Don't increment i, we swapped in the last element
        elseif not IsSlotOnCooldown(queued.inventoryId, now) then
            -- Try to equip (use QueueScript for smoother mid-cast swaps)
            local success = PerformEquipSwap(queued.item, queued.inventoryId, true)

            if success then
                -- Don't set cooldowns for relic slots (no GCD)
                if not IsRelicSlot(queued.inventoryId) then
                    CleveRoids.lastEquipTime[queued.inventoryId] = now
                    CleveRoids.lastGlobalEquipTime = now
                end
                RemoveQueueEntry(i)
            else
                queued.retries = queued.retries + 1
                if queued.retries >= queued.maxRetries then
                    RemoveQueueEntry(i)
                else
                    i = i + 1
                end
            end
        else
            i = i + 1
        end
    end
end

-- PERFORMANCE: Self-disabling frame for queue processing with throttling
-- Only processes every EQUIP_QUEUE_INTERVAL instead of every frame
CleveRoids.EQUIP_QUEUE_INTERVAL = 0.1  -- 100ms between queue checks (was 50ms)
CleveRoids.equipQueueLastUpdate = 0
CleveRoids.equipQueueFrame = CreateFrame("Frame")
CleveRoids.equipQueueFrame:Hide()

-- PERFORMANCE: Upvalue for faster access in OnUpdate
local equipQueueFrame = CleveRoids.equipQueueFrame
local equipQueueInterval = CleveRoids.EQUIP_QUEUE_INTERVAL

equipQueueFrame:SetScript("OnUpdate", function()
    -- PERFORMANCE: Use arg1 (elapsed time) if available, otherwise GetTime()
    local elapsed = arg1
    if elapsed then
        CleveRoids.equipQueueLastUpdate = (CleveRoids.equipQueueLastUpdate or 0) + elapsed
        if CleveRoids.equipQueueLastUpdate < equipQueueInterval then
            return  -- Throttle: skip this frame
        end
        CleveRoids.equipQueueLastUpdate = 0
    else
        local now = GetTime()
        if (now - (CleveRoids.equipQueueLastUpdate or 0)) < equipQueueInterval then
            return
        end
        CleveRoids.equipQueueLastUpdate = now
    end

    CleveRoids.ProcessEquipmentQueue()
    if CleveRoids.equipmentQueueLen == 0 then
        this:Hide()
    end
end)

-- Improved DisableAddon function
function CleveRoids.DisableAddon(reason)
    -- Prevent multiple disable calls
    if CleveRoids.disabled then return end

    -- Mark state
    CleveRoids.disabled = true

    -- Stop main frame activity
    if CleveRoids.Frame then
        if CleveRoids.Frame.UnregisterAllEvents then
            CleveRoids.Frame:UnregisterAllEvents()
        end
        if CleveRoids.Frame.SetScript then
            CleveRoids.Frame:SetScript("OnEvent", nil)
            CleveRoids.Frame:SetScript("OnUpdate", nil)
        end
    end

    -- Neuter all slash commands
    if SlashCmdList then
        local disabledMsg = function()
            CleveRoids.Print("|cffff0000SuperCleveRoidMacros is disabled|r" ..
                (reason and (": " .. tostring(reason)) or ""))
        end

        SlashCmdList.CLEVEROID = disabledMsg
        SlashCmdList.CAST = disabledMsg
        SlashCmdList.USE = disabledMsg
        SlashCmdList.EQUIP = disabledMsg
        SlashCmdList.EQUIPMH = disabledMsg
        SlashCmdList.EQUIPOH = disabledMsg
    end

    -- Try to disable for next login
    local addonName = "SuperCleveRoidMacros"
    if type(DisableAddOn) == "function" then
        pcall(DisableAddOn, addonName)
    end

    -- Final notice
    CleveRoids.Print("|cffff0000Disabled|r - " .. (reason or "Unknown reason"))
    CleveRoids.Print("Please install required dependencies and /reload")
end

local frame = CreateFrame("Frame")
frame:RegisterEvent("VARIABLES_LOADED")
frame:SetScript("OnEvent", function()
    if not CleveRoidMacros then CleveRoidMacros = {} end

    if type(CleveRoidMacros.realtime) ~= "number" then
        CleveRoidMacros.realtime = 0
    end

    if type(CleveRoidMacros.refresh) ~= "number" then
        CleveRoidMacros.refresh = 5
    end
end)

-- Queues a full update of all action bars.
-- This is called by game event handlers to avoid running heavy logic inside the event itself.
function CleveRoids.QueueActionUpdate()
    if CleveRoidMacros.realtime == 0 then
        CleveRoids.isActionUpdateQueued = true
        if CleveRoids.debug then
            DEFAULT_CHAT_FRAME:AddMessage(
                string.format("|cffff00ff[QueueActionUpdate]|r Queued, isActionUpdateQueued = %s",
                    tostring(CleveRoids.isActionUpdateQueued))
            )
        end
    end
end

local function _StripColor(s)
  if not s then return s end
  if string.sub(s,1,2) == "|c" then return string.sub(s,11,-3) end
  return s
end

local _ReagentBySpell = {
  ["Vanish"] = "Flash Powder",    -- 5140
  ["Blind"]  = "Blinding Powder", -- 5530
}

-- Expose for use in Generic.lua (IndexSpells fallback)
CleveRoids.ReagentBySpell = _ReagentBySpell

-- Minimal map for rogue reagents; extend as needed
local _ReagentIdByName = {
    ["Flash Powder"]   = 5140, -- Vanish
    ["Blinding Powder"] = 5530, -- Blind
}

-- Lazy bag-scan tooltip (only if we need to scan a bag slot by name)
local function CRM_GetBagScanTip()
  local tip = _G.CleveRoidsBagScanTip
  if tip then return tip end
  local ok, created = pcall(CreateFrame, "GameTooltip", "CleveRoidsBagScanTip", UIParent, "GameTooltipTemplate")
  if ok and created then
    tip = created
  else
    tip = CreateFrame("GameTooltip", "CleveRoidsBagScanTip", UIParent)
    local L1 = tip:CreateFontString("$parentTextLeft1",  nil, "GameTooltipText")
    local R1 = tip:CreateFontString("$parentTextRight1", nil, "GameTooltipText")
    tip:AddFontStrings(L1, R1)
    for i=2,10 do
      tip:CreateFontString("$parentTextLeft"..i,  nil, "GameTooltipText")
      tip:CreateFontString("$parentTextRight"..i, nil, "GameTooltipText")
    end
  end
  tip:SetOwner(WorldFrame, "ANCHOR_NONE")
  _G.CleveRoidsBagScanTip = tip
  return tip
end

-- Return total in *bags only* (not bank), by id when possible; fallback to name
-- PERFORMANCE: Uses CleveRoids.Items cache for O(1) lookup when available
function CleveRoids.GetReagentCount(reagentName)
  if not reagentName or reagentName == "" then return 0 end

  -- Fast path: check cache first
  local Items = CleveRoids.Items
  if Items then
    local wantId = _ReagentIdByName[reagentName]

    -- Try by ID first if we have a mapping
    if wantId then
      local itemName = Items[wantId]
      if itemName then
        local itemData = Items[itemName]
        if itemData and itemData.count and not itemData.inventoryID then
          -- Item is in bags (not equipped), return cached count
          return itemData.count
        end
      end
    end

    -- Try by name
    local itemData = Items[reagentName]
    if type(itemData) == "string" then
      itemData = Items[itemData]  -- Resolve indirection
    end
    if itemData and type(itemData) == "table" and itemData.count and not itemData.inventoryID then
      return itemData.count
    end

    -- Try lowercase
    local lowerName = string.lower(reagentName)
    local resolved = Items[lowerName]
    if type(resolved) == "string" then
      itemData = Items[resolved]
    elseif type(resolved) == "table" then
      itemData = resolved
    end
    if itemData and type(itemData) == "table" and itemData.count and not itemData.inventoryID then
      return itemData.count
    end
  end

  -- Slow path fallback: full bag scan (only when cache miss)
  local wantId = _ReagentIdByName[reagentName]
  local total = 0

  for bag = 0, 4 do
    local slots = GetContainerNumSlots(bag) or 0
    for slot = 1, slots do
      local _, count = GetContainerItemInfo(bag, slot)
      count = count or 0
      local link = GetContainerItemLink and GetContainerItemLink(bag, slot)
      if link then
        local _, _, idstr = string.find(link, "item:(%d+)")
        local id = idstr and tonumber(idstr) or nil
        if (wantId and id == wantId) or (not wantId and string.find(link, "%["..reagentName.."%]")) then
          total = total + count
        end
      else
        -- Fallback: scan bag slot tooltip for the name (expensive, only when no link)
        local tip = CRM_GetBagScanTip()
        tip:ClearLines()
        tip:SetBagItem(bag, slot)
        local left1 = _G[tip:GetName().."TextLeft1"]
        local name = left1 and left1:GetText()
        if name and name == reagentName then
          total = total + count
        end
      end
    end
  end

  return total
end

function CleveRoids.GetSpellCost(spellSlot, bookType)
  -- Fast path: existing fixed-slot read
  CleveRoids.Frame:SetOwner(WorldFrame, "ANCHOR_NONE")
  CleveRoids.Frame:SetSpell(spellSlot, bookType)

  local cost, reagent
  local costText = CleveRoids.Frame.costFontString:GetText()
  if costText then
      _, _, cost = string.find(costText, "^(%d+)%s+[^yYsS]")
  end

  local reagentText = CleveRoids.Frame.reagentFontString:GetText()
  if reagentText then
      _, _, reagent = string.find(reagentText, "^Reagents?%s*:%s*(.*)")
  end
  reagent = _StripColor(reagent)

  -- Fallback: scan all lines on a named tooltip (handles Vanish layout)
  if not reagent or not cost then
    local tip = CleveRoidsTooltipScan
    if not tip then
      -- belt & suspenders: create if somehow missing
      local ok,_ = pcall(CreateFrame, "GameTooltip", "CleveRoidsTooltipScan", UIParent, "GameTooltipTemplate")
      if not ok or not CleveRoidsTooltipScan then
        CleveRoidsTooltipScan = CreateFrame("GameTooltip", "CleveRoidsTooltipScan", UIParent)
        local L1 = CleveRoidsTooltipScan:CreateFontString("$parentTextLeft1",  nil, "GameTooltipText")
        local R1 = CleveRoidsTooltipScan:CreateFontString("$parentTextRight1", nil, "GameTooltipText")
        CleveRoidsTooltipScan:AddFontStrings(L1, R1)
        for i=2,32 do
          CleveRoidsTooltipScan:CreateFontString("$parentTextLeft"..i,  nil, "GameTooltipText")
          CleveRoidsTooltipScan:CreateFontString("$parentTextRight"..i, nil, "GameTooltipText")
        end
      end
      CleveRoidsTooltipScan:SetOwner(WorldFrame, "ANCHOR_NONE")
      tip = CleveRoidsTooltipScan
    end

    tip:ClearLines()
    tip:SetOwner(WorldFrame, "ANCHOR_NONE")
    tip:SetSpell(spellSlot, bookType)

    local base = tip:GetName() or "CleveRoidsTooltipScan"
    local maxLines = (tip.NumLines and tip:NumLines()) or 32

    for i = 1, maxLines do
      local L = _G[base.."TextLeft"..i]
      local R = _G[base.."TextRight"..i]
      local lt = L and L:GetText() or ""
      local rt = R and R:GetText() or ""

      if not reagent then
        if string.find(lt, "^[Rr]eagents?%s*:") then
          reagent = _StripColor((rt ~= "" and rt) or (string.gsub(lt, "^[Rr]eagents?%s*:%s*", "")))
        elseif string.find(rt, "^[Rr]eagents?%s*:") then
          reagent = _StripColor((lt ~= "" and lt) or (string.gsub(rt, "^[Rr]eagents?%s*:%s*", "")))
        end
      end

      if not cost and rt ~= "" then
          local _, _, num = string.find(rt, "^(%d+)%s+(Mana|Energy|Rage|Focus)")
          if num then cost = tonumber(num) end
      end

      if reagent and cost then break end
    end
  end

  if not reagent then
    local name = GetSpellName(spellSlot, bookType)
    if name then
        name = string.gsub(name, "%s*%(%s*Rank%s+%d+%s*%)%s*$", "")  -- strip "(Rank X)" only
        reagent = _ReagentBySpell[name]
    end
  end

  return (cost and tonumber(cost) or 0), (reagent and tostring(reagent) or nil)
end

function CleveRoids.GetProxyActionSlot(slot)
    if not slot then return end
    return CleveRoids.actionSlots[slot] or CleveRoids.actionSlots[slot.."()"]
end

-- Resolves nested macro references for #showtooltip propagation
-- If an action is a {MacroName} reference and that macro has #showtooltip,
-- returns the inner macro's active action; otherwise returns nil
-- depth parameter prevents infinite recursion
function CleveRoids.ResolveNestedMacroActive(action, depth)
    if not action or not action.action then return nil end
    depth = depth or 0
    if depth > 5 then return nil end  -- prevent infinite recursion

    -- Check if this action is a macro reference {MacroName}
    local macroName = CleveRoids.GetMacroNameFromAction(action.action)
    if not macroName then return nil end

    -- Get or parse the inner macro
    local innerMacro = CleveRoids.GetMacro(macroName)
    if not innerMacro then
        innerMacro = CleveRoids.ParseMacro(macroName)
    end
    if not innerMacro or not innerMacro.actions then return nil end

    -- Check if inner macro has #showtooltip (indicated by having a tooltip or action list)
    if not innerMacro.actions.tooltip and table.getn(innerMacro.actions.list or {}) == 0 then
        return nil
    end

    -- Run TestForActiveAction on inner macro to get its current active
    CleveRoids.TestForActiveAction(innerMacro.actions)

    -- If inner macro has an active action, check if it's also a nested macro
    if innerMacro.actions.active then
        local deeperActive = CleveRoids.ResolveNestedMacroActive(innerMacro.actions.active, depth + 1)
        if deeperActive then
            return deeperActive
        end
        return innerMacro.actions.active
    end

    return nil
end

function CleveRoids.TestForActiveAction(actions)
    if not actions then return end
    local currentActive = actions.active
    local currentSequence = actions.sequence
    local hasActive = false
    local newActiveAction = nil
    local newSequence = nil
    local firstUnconditional = nil

    if actions.tooltip and table.getn(actions.list) == 0 then
        if CleveRoids.TestAction(actions.cmd or "", actions.args or "") then
            hasActive = true
            newActiveAction = actions.tooltip
            -- Resolve nested macro references for #showtooltip propagation
            local macroName = CleveRoids.GetMacroNameFromAction(actions.tooltip.action)
            if macroName then
                local resolved = CleveRoids.ResolveNestedMacroActive(actions.tooltip, 0)
                if resolved then
                    newActiveAction = resolved
                else
                    -- Inner macro didn't resolve - no active action
                    hasActive = false
                    newActiveAction = nil
                end
            end
        end
    else
        -- First pass: find first action with conditionals that passes
        for _, action in ipairs(actions.list) do
            local result = CleveRoids.TestAction(action.cmd, action.args)

            -- Check if action has conditionals
            local _, conditionals = CleveRoids.GetParsedMsg(action.args)

            -- Skip this action for icon display if it has the '?' prefix
            -- Note: CleveRoids._ignoretooltip is a side-effect flag set by GetParsedMsg
            local shouldSkipForIcon = CleveRoids._ignoretooltip == 1

            -- break on first action that passes tests (unless it should be skipped for icon)
            if result and not shouldSkipForIcon then
                hasActive = true
                if action.sequence then
                    newSequence = action.sequence
                    newActiveAction = CleveRoids.GetCurrentSequenceAction(newSequence)
                    if not newActiveAction then hasActive = false end
                else
                    newActiveAction = action
                    -- Resolve nested macro references for #showtooltip propagation
                    -- If inner macro doesn't resolve, continue to next action
                    local macroName = CleveRoids.GetMacroNameFromAction(action.action)
                    if macroName then
                        local resolved = CleveRoids.ResolveNestedMacroActive(action, 0)
                        if resolved then
                            newActiveAction = resolved
                        else
                            -- Inner macro didn't resolve - try next action
                            hasActive = false
                            newActiveAction = nil
                        end
                    end
                end
                if hasActive then break end
            end

            -- Track first unconditional non-macro action as fallback
            if not conditionals and not firstUnconditional and not shouldSkipForIcon then
                -- Don't use unresolvable macro refs as fallback
                local macroName = CleveRoids.GetMacroNameFromAction(action.action)
                if not macroName then
                    firstUnconditional = action
                end
            end
        end

        -- If no conditional action passed, use first unconditional action
        if not hasActive and firstUnconditional then
            hasActive = true
            newActiveAction = firstUnconditional
        end
    end

    local changed = false
    if currentActive ~= newActiveAction or currentSequence ~= newSequence then
        actions.active = newActiveAction
        actions.sequence = newSequence
        changed = true
    end

    if not hasActive then
        if actions.active ~= nil or actions.sequence ~= nil then
             actions.active = nil
             actions.sequence = nil
             changed = true
        end
        return changed
    end

    if actions.active then
        local previousUsable = actions.active.usable
        local previousOom = actions.active.oom
        local previousInRange = actions.active.inRange

        if actions.active.spell then
            -- Default to -1 (unknown) so we fall through to proxy slot or original function
            -- Only set to 1/0 when we have a definitive answer from IsSpellInRange
            actions.active.inRange = -1

            -- Enhanced nampower range check with spell ID support
			if IsSpellInRange then
                local unit = actions.active.conditionals and actions.active.conditionals.target or "target"
				if unit == "focus" and pfUI and pfUI.uf and pfUI.uf.focus and pfUI.uf.focus.label and pfUI.uf.focus.id then
					unit = pfUI.uf.focus.label .. pfUI.uf.focus.id
				end

				-- PERFORMANCE: Cache spell name construction using two-level cache (no string concat for lookup)
				local castName = actions.active.action
				if actions.active.spell and actions.active.spell.name then
					local spellName = actions.active.spell.name
					local rank = actions.active.spell.rank
								 or (actions.active.spell.highest and actions.active.spell.highest.rank)
					if rank and rank ~= "" then
						-- Two-level cache: spellNameCache[spellName][rank] = "SpellName(Rank X)"
						local nameCache = CleveRoids.spellNameCache[spellName]
						if not nameCache then
							nameCache = {}
							CleveRoids.spellNameCache[spellName] = nameCache
						end
						castName = nameCache[rank]
						if not castName then
							castName = spellName .. "(" .. rank .. ")"
							nameCache[rank] = castName
						end
					end
				end

				-- PERFORMANCE: Try to get spell ID with caching
				local spellId = nil
				if GetSpellIdForName then
					-- Check cache first
					local cachedId = CleveRoids.spellIdCache[castName]
					if cachedId then
						spellId = cachedId
					else
						spellId = GetSpellIdForName(castName)
						if spellId and spellId > 0 then
							CleveRoids.spellIdCache[castName] = spellId
						end
					end
				end

				-- Check range using API wrapper (handles all cases properly)
				local API = CleveRoids.NampowerAPI
				local checkValue = spellId and spellId > 0 and spellId or castName

				if UnitExists(unit) then
					-- We have a target - use API wrapper for proper range checking
					-- API.IsSpellInRange handles: native check, -1 for self-cast, UnitXP fallback
					if API then
						local r = API.IsSpellInRange(checkValue, unit)
						if r ~= nil then
							actions.active.inRange = r
						end
					elseif IsSpellInRange then
						-- No API, use native directly
						local nativeResult = IsSpellInRange(checkValue, unit)
						if nativeResult == 0 or nativeResult == 1 then
							actions.active.inRange = nativeResult
						elseif nativeResult == -1 then
							-- Self-cast/ground-targeted spell, always in range
							actions.active.inRange = 1
						end
					end
				end
				-- No target: don't set inRange, let proxy slot / original behavior handle it
			end

            -- Check if spell is usable first (handles forms, stances, and power type correctly)
            local isUsableBySpell, notEnoughPower = nil, nil
            if IsSpellUsable then
                -- pcall to handle spells not in spellbook (Nampower throws error)
                local ok, usable, oom = pcall(IsSpellUsable, actions.active.action)
                if ok then
                    isUsableBySpell, notEnoughPower = usable, oom
                end
            end

            -- For OOM check, use proper mana source
            if notEnoughPower ~= nil then
                -- Prefer IsSpellUsable result if available (Nampower)
                actions.active.oom = (notEnoughPower == 1)
            else
                -- SuperWoW: UnitMana returns (current power, caster mana) for druids
                local currentPower, casterMana = UnitMana("player")

                -- For druids with SuperWoW, use caster mana for spell cost checks
                local manaToCheck = currentPower
                if CleveRoids.playerClass == "DRUID" and type(casterMana) == "number" then
                    manaToCheck = casterMana
                end

                actions.active.oom = (manaToCheck < actions.active.spell.cost)
            end

            local start, duration = GetSpellCooldown(actions.active.spell.spellSlot, actions.active.spell.bookType)
            local onCooldown = (start > 0 and duration > 0)

            if actions.active.isReactive then
                -- For Overpower, Revenge, Riposte: ONLY use combat log tracking
                local spellName = actions.active.action
                local useCombatLogOnly = (spellName == "Overpower" or spellName == "Revenge" or spellName == "Riposte")

                if useCombatLogOnly then
                    -- Only trust HasReactiveProc for these spells
                    local hasProc = CleveRoids.HasReactiveProc and CleveRoids.HasReactiveProc(spellName)
                    if CleveRoids.debug then
                        DEFAULT_CHAT_FRAME:AddMessage(
                            string.format("|cff00ff00[UPDATE USABLE]|r %s: hasProc=%s, previousUsable=%s, inRange=%s, oom=%s",
                                spellName, tostring(hasProc), tostring(previousUsable), tostring(actions.active.inRange), tostring(actions.active.oom))
                        )
                    end
                    if hasProc then
                        -- Proc is active, show as usable if in range and have enough rage/mana
                        if actions.active.inRange ~= 0 and not actions.active.oom then
                            actions.active.usable = 1
                        elseif pfUI and pfUI.bars and actions.active.oom then
                            actions.active.usable = 2  -- pfUI: out of mana/rage
                        else
                            actions.active.usable = nil
                        end
                        if CleveRoids.debug then
                            DEFAULT_CHAT_FRAME:AddMessage(
                                string.format("|cff00ff00[UPDATE USABLE]|r %s: SET usable=%s (proc active)",
                                    spellName, tostring(actions.active.usable))
                            )
                        end
                    else
                        -- No proc = not usable
                        actions.active.usable = nil
                        if CleveRoids.debug then
                            DEFAULT_CHAT_FRAME:AddMessage(
                                string.format("|cff00ff00[UPDATE USABLE]|r %s: SET usable=nil (no proc)", spellName)
                            )
                        end
                    end
                else
                    -- For other reactive spells, use the original fallback logic
                    -- Check combat log-based proc tracking first (stance-independent)
                    if CleveRoids.HasReactiveProc and CleveRoids.HasReactiveProc(actions.active.action) then
                        -- Proc is active, show as usable if in range and have enough rage/mana
                        if actions.active.inRange ~= 0 and not actions.active.oom then
                            actions.active.usable = 1
                        elseif pfUI and pfUI.bars and actions.active.oom then
                            actions.active.usable = 2  -- pfUI: out of mana/rage
                        else
                            actions.active.usable = nil
                        end
                    -- Use Nampower's IsSpellUsable if available (stance-aware fallback)
                    elseif IsSpellUsable then
                        -- pcall to handle spells not in spellbook (Nampower throws error)
                        local ok, usable, oom = pcall(IsSpellUsable, actions.active.action)
                        if ok and usable == 1 and oom ~= 1 then
                            actions.active.usable = (pfUI and pfUI.bars) and nil or 1
                        else
                            actions.active.usable = nil
                        end
                        actions.active.oom = false
                    elseif not CleveRoids.IsReactiveUsable(actions.active.action) then
                        actions.active.oom = false
                        actions.active.usable = nil
                    else
                        actions.active.usable = (pfUI and pfUI.bars) and nil or 1
                    end
                end
            elseif isUsableBySpell == 1 and actions.active.inRange ~= 0 then
                -- Use IsUsableSpell result if available (handles forms/stances correctly)
                actions.active.usable = 1
            elseif isUsableBySpell == 0 then
                -- IsSpellUsable returned 0 = wrong stance/form, not enough power type, etc.
                actions.active.usable = nil
            elseif actions.active.inRange ~= 0 and not actions.active.oom then
                -- Fallback to mana check ONLY if IsSpellUsable not available
                actions.active.usable = 1

            -- pfUI:actionbar.lua -- update usable [out-of-range = 1, oom = 2, not-usable = 3, default = 0]
            elseif pfUI and pfUI.bars and actions.active.oom then
                actions.active.usable = 2
            else
                actions.active.usable = nil
            end

            -- Check if this is a toggled buff ability (Prowl, Shadowmeld) and darken if buff is active
            -- This must come AFTER all other usability checks to have final say
            -- PERFORMANCE: Cache normalized spell name on the action object to avoid gsub per-frame
            local spellName = actions.active._normalizedName
            if not spellName then
                spellName = string.gsub(actions.active.action, "%s*%(.-%)%s*$", "")
                spellName = string.gsub(spellName, "_", " ")
                actions.active._normalizedName = spellName
            end

            -- PERFORMANCE: Use cached lookup instead of creating table per-call
            if CleveRoids.IsToggledBuffAbility(spellName) then
                if CleveRoids.ValidatePlayerBuff(spellName) then
                    -- Buff is active, darken the icon like "wrong stance" (grayed out, not red)
                    actions.active.usable = nil
                    actions.active.oom = false  -- Make sure we don't show red tint
                end
            end
        else
            actions.active.inRange = 1
            actions.active.usable = 1
        end
        if actions.active.usable ~= previousUsable or
           actions.active.oom ~= previousOom or
           actions.active.inRange ~= previousInRange then
            changed = true
            if CleveRoids.debug and actions.active.isReactive then
                DEFAULT_CHAT_FRAME:AddMessage(
                    string.format("|cffff00ff[STATE CHANGED]|r %s: usable %s->%s, will send ACTIONBAR_SLOT_CHANGED",
                        actions.active.action, tostring(previousUsable), tostring(actions.active.usable))
                )
            end
        end
    end
    return changed
end

-- PERFORMANCE: Static buffer references for hot path
local _actionsToSlotsBuffer = CleveRoids._actionsToSlotsBuffer
local _slotsBuffer = CleveRoids._slotsBuffer
local _actionsListBuffer = CleveRoids._actionsListBuffer

function CleveRoids.TestForAllActiveActions()
    -- PERFORMANCE: Reuse static buffers instead of creating new tables each call
    -- Group slots by their actions object to handle shared macro references
    local actionsToSlots = _actionsToSlotsBuffer
    local actionsList = _actionsListBuffer
    local actionsCount = 0

    -- PERFORMANCE: Use next() directly instead of pairs() to avoid iterator allocation
    local Actions = CleveRoids.Actions
    local slot, actions = next(Actions)
    while slot do
        if not actionsToSlots[actions] then
            -- Reuse or create slots array from pool
            local slots = _slotsBuffer[actions]
            if not slots then
                slots = {}
                _slotsBuffer[actions] = slots
            end
            slots[1] = slot
            slots._count = 1
            actionsToSlots[actions] = slots
            actionsCount = actionsCount + 1
            actionsList[actionsCount] = actions
        else
            local slots = actionsToSlots[actions]
            local count = slots._count + 1
            slots[count] = slot
            slots._count = count
        end
        slot, actions = next(Actions, slot)
    end

    -- Test each unique actions object once and send events to ALL slots that share it
    for i = 1, actionsCount do
        local actions = actionsList[i]
        local slots = actionsToSlots[actions]
        local stateChanged = CleveRoids.TestForActiveAction(actions)
        if stateChanged then
            -- Send event to ALL slots that use this macro
            local count = slots._count
            for j = 1, count do
                CleveRoids.SendEventForAction(slots[j], "ACTIONBAR_SLOT_CHANGED", slots[j])
            end
        end
        -- Clear for reuse (reset count and clear buffer reference)
        for j = 1, slots._count do
            slots[j] = nil
        end
        slots._count = 0
        actionsToSlots[actions] = nil
        actionsList[i] = nil  -- Clear actionsList entry for reuse
    end
end

function CleveRoids.ClearAction(slot)
    if not CleveRoids.Actions[slot] then return end
    CleveRoids.Actions[slot].active = nil
    CleveRoids.Actions[slot] = nil
end

function CleveRoids.GetAction(slot)
    if not slot or not CleveRoids.ready then return end

    local actions = CleveRoids.Actions[slot]
    if actions then return actions end

    local text = GetActionText(slot)

    if text then
        local macro = CleveRoids.GetMacro(text)
        if macro then
            actions = macro.actions

            CleveRoids.TestForActiveAction(actions)
            CleveRoids.Actions[slot] = actions
            CleveRoids.SendEventForAction(slot, "ACTIONBAR_SLOT_CHANGED", slot)
            return actions
        end
    end
end

function CleveRoids.GetActiveAction(slot)
    local action = CleveRoids.GetAction(slot)
    return action and action.active
end

-- PERFORMANCE: Static buffer for arg backup
local _originalArgsBuffer = CleveRoids._originalArgsBuffer

function CleveRoids.SendEventForAction(slot, event, ...)
    local old_this = this

    -- PERFORMANCE: Reuse static buffer instead of creating table each call
    local original_global_args = _originalArgsBuffer
    for i = 1, 10 do
        original_global_args[i] = _G["arg" .. i]
    end

    if type(arg) == "table" then

        local n_varargs_from_arg_table = arg.n or 0
        for i = 1, 10 do
            if i <= n_varargs_from_arg_table then
                _G["arg" .. i] = arg[i]
            else
                _G["arg" .. i] = nil
            end
        end
    else
        for i = 1, 10 do
            _G["arg" .. i] = nil
        end
    end

    local button_to_call_event_on
    local page = floor((slot - 1) / NUM_ACTIONBAR_BUTTONS) + 1
    local pageSlot = slot - (page - 1) * NUM_ACTIONBAR_BUTTONS

    if slot >= 73 then
        button_to_call_event_on = _G["BonusActionButton" .. pageSlot]
    elseif slot >= 61 then
        button_to_call_event_on = _G["MultiBarBottomLeftButton" .. pageSlot]
    elseif slot >= 49 then
        button_to_call_event_on = _G["MultiBarBottomRightButton" .. pageSlot]
    elseif slot >= 37 then
        button_to_call_event_on = _G["MultiBarLeftButton" .. pageSlot]
    elseif slot >= 25 then
        button_to_call_event_on = _G["MultiBarRightButton" .. pageSlot]
    end

    if button_to_call_event_on then
        this = button_to_call_event_on
        ActionButton_OnEvent(event)
    end

    if page == CURRENT_ACTIONBAR_PAGE then
        local main_bar_button = _G["ActionButton" .. pageSlot]
        if main_bar_button and main_bar_button ~= button_to_call_event_on then
            this = main_bar_button
            ActionButton_OnEvent(event)
        elseif not button_to_call_event_on and main_bar_button then
             this = main_bar_button
             ActionButton_OnEvent(event)
        end
    end

    this = old_this

    for i = 1, 10 do
        _G["arg" .. i] = original_global_args[i]
    end

    if type(arg) == "table" and arg.n then

        if arg.n == 0 then
            for _, fn_h in ipairs(CleveRoids.actionEventHandlers) do fn_h(slot, event) end
        elseif arg.n == 1 then
            for _, fn_h in ipairs(CleveRoids.actionEventHandlers) do fn_h(slot, event, arg[1]) end
        elseif arg.n == 2 then
            for _, fn_h in ipairs(CleveRoids.actionEventHandlers) do fn_h(slot, event, arg[1], arg[2]) end
        elseif arg.n == 3 then
            for _, fn_h in ipairs(CleveRoids.actionEventHandlers) do fn_h(slot, event, arg[1], arg[2], arg[3]) end
        elseif arg.n == 4 then
            for _, fn_h in ipairs(CleveRoids.actionEventHandlers) do fn_h(slot, event, arg[1], arg[2], arg[3], arg[4]) end
        elseif arg.n == 5 then
            for _, fn_h in ipairs(CleveRoids.actionEventHandlers) do fn_h(slot, event, arg[1], arg[2], arg[3], arg[4], arg[5]) end
        elseif arg.n == 6 then
            for _, fn_h in ipairs(CleveRoids.actionEventHandlers) do fn_h(slot, event, arg[1], arg[2], arg[3], arg[4], arg[5], arg[6]) end
        else
            for _, fn_h in ipairs(CleveRoids.actionEventHandlers) do fn_h(slot, event, arg[1], arg[2], arg[3], arg[4], arg[5], arg[6], arg[7]) end
        end
    else

        for _, fn_h in ipairs(CleveRoids.actionEventHandlers) do
            fn_h(slot, event)
        end
    end
end

-- Executes the given Macro's body
-- body: The Macro's body
-- Note on macro flags:
--   stopMacroFlag: Stops ALL remaining lines (propagates to parent macros)
--   skipMacroFlag: Stops only current macro (cleared on return, parent continues)
function CleveRoids.ExecuteMacroBody(body,inline)
    local lines = CleveRoids.splitString(body, "\n")
    if inline then lines = CleveRoids.splitString(body, "\\n"); end

    -- Save parent's stopMacroFlag state (in case we need to preserve it)
    local parentStopFlag = CleveRoids.stopMacroFlag

    -- Clear flags at start of this macro execution
    -- Note: We DON'T clear if parent already set stopMacroFlag (shouldn't execute at all)
    if not parentStopFlag then
        CleveRoids.stopMacroFlag = false
    end
    CleveRoids.skipMacroFlag = false  -- Always start fresh for skipmacro

    if CleveRoids.macroRefDebug then
        CleveRoids.Print("|cff00ffff[MacroRef]|r ExecuteMacroBody called with " .. table.getn(lines) .. " lines")
    end

    for k,v in pairs(lines) do
        local trimmed = CleveRoids.Trim(v)
        local cmdHandled = false

        -- IMPORTANT: Check for /nofirstaction BEFORE the stop flag check
        -- This allows /nofirstaction to clear the stopMacroFlag set by /firstaction
        local _, _, nofirstactionArgs = string.find(trimmed, "^/nofirstaction%s*(.*)")
        if nofirstactionArgs then
            CleveRoids.DoNoFirstAction(nofirstactionArgs)
            -- Also clear stopMacroFlag if it was set by firstaction mechanism
            -- (but NOT if it was set by explicit /stopmacro)
            if CleveRoids.stopOnCastFlag == false and CleveRoids.stopMacroFlag then
                -- stopOnCastFlag is false (just cleared by DoNoFirstAction), stopMacroFlag is true
                -- This means stopMacroFlag was set by the firstaction mechanism, clear it
                CleveRoids.stopMacroFlag = false
                if CleveRoids.macroRefDebug then
                    CleveRoids.Print("|cff00ff00[MacroRef]|r /nofirstaction cleared stopMacroFlag - resuming macro")
                end
            end
            if CleveRoids.macroRefDebug then
                CleveRoids.Print("|cff88ff88[MacroRef]|r Executing line " .. k .. ": " .. string.sub(v, 1, 60))
            end
            cmdHandled = true
        end

        -- Check both macro stop flags before each line (but skip if we just handled /nofirstaction)
        -- stopMacroFlag: stop this AND parent macros
        -- skipMacroFlag: stop only this macro (parent continues)
        if not cmdHandled and (CleveRoids.stopMacroFlag or CleveRoids.skipMacroFlag) then
            if CleveRoids.macroRefDebug then
                local reason = CleveRoids.stopMacroFlag and "/stopmacro" or "/skipmacro"
                CleveRoids.Print("|cffff8800[MacroRef]|r Stopped at line " .. k .. " due to " .. reason)
            end
            break
        end

        if not cmdHandled then
            if CleveRoids.macroRefDebug then
                CleveRoids.Print("|cff88ff88[MacroRef]|r Executing line " .. k .. ": " .. string.sub(v, 1, 60))
            end

            -- IMPORTANT: Handle macro control commands directly to bypass Blizzard's built-in /stopmacro
            -- Blizzard intercepts bare /stopmacro before it reaches our SlashCmdList handler

            -- Check for /stopmacro (with or without conditionals)
            local _, _, stopmacroArgs = string.find(trimmed, "^/stopmacro%s*(.*)")
            if stopmacroArgs then
                CleveRoids.DoStopMacro(stopmacroArgs)
                cmdHandled = true
            end

            -- Check for /skipmacro (with or without conditionals)
            if not cmdHandled then
                local _, _, skipmacroArgs = string.find(trimmed, "^/skipmacro%s*(.*)")
                if skipmacroArgs then
                    CleveRoids.DoSkipMacro(skipmacroArgs)
                    cmdHandled = true
                end
            end

            -- Check for /firstaction (with or without conditionals)
            if not cmdHandled then
                local _, _, firstactionArgs = string.find(trimmed, "^/firstaction%s*(.*)")
                if firstactionArgs then
                    CleveRoids.DoFirstAction(firstactionArgs)
                    cmdHandled = true
                end
            end
        end

        -- For all other commands, use ChatEdit_SendText
        if not cmdHandled then
            ChatFrameEditBox:SetText(v)
            ChatEdit_SendText(ChatFrameEditBox)
        end
    end

    -- Clear skipMacroFlag after this macro completes (don't propagate to parent)
    -- stopMacroFlag is intentionally LEFT SET so it propagates up
    CleveRoids.skipMacroFlag = false

    return true
end

-- Gets the body of the Macro with the given name
-- name: The name of the Macro
-- returns: The body of the macro
function CleveRoids.GetMacroBody(name)
    local macro = CleveRoids.GetMacro(name)
    return macro and macro.body
end

-- Attempts to execute a macro by the given name or index (Blizzard or Super tab)
-- Returns: true if something was executed, false otherwise
-- Supports: macro name (string), macro index (number or numeric string like "19")
-- Uses CleveRoids' own ExecuteMacroBody for processing (supports enhanced syntax)
function CleveRoids.ExecuteMacroByName(name)
    if not name or name == "" then
        if CleveRoids.macroRefDebug then
            CleveRoids.Print("|cffff0000[MacroRef]|r ExecuteMacroByName called with empty name")
        end
        return false
    end

    if CleveRoids.macroRefDebug then
        CleveRoids.Print("|cff00ffff[MacroRef]|r ExecuteMacroByName called with: '" .. name .. "'")
    end

    local body
    local source = nil

    -- Check if input is a numeric index (e.g., "19" or 19)
    local numericIndex = tonumber(name)

    -- 1) Try Blizzard macro (by index or name)
    if numericIndex then
        -- Numeric index - get body directly (supports character macros 19-36)
        local _n, _tex, b = GetMacroInfo(numericIndex)
        if b and b ~= "" then
            body = b
            source = "Blizzard (index " .. numericIndex .. ")"
        end
    else
        -- String name - look up by name
        local id = GetMacroIndexByName(name)
        if CleveRoids.macroRefDebug then
            CleveRoids.Print("|cff888888[MacroRef]|r GetMacroIndexByName('" .. name .. "') = " .. tostring(id))
        end
        if id and id ~= 0 then
            local _n, _tex, b = GetMacroInfo(id)
            if b and b ~= "" then
                body = b
                source = "Blizzard (slot " .. id .. ")"
            end
        end
    end

    -- 2) SuperMacro's Super macros (by name only, not index)
    -- These are the 7000-char extended macros stored in SM_SUPER
    if not body and not numericIndex then
        if type(GetSuperMacroInfo) == "function" then
            local _n2, _t2, b2 = GetSuperMacroInfo(name)
            if b2 and b2 ~= "" then
                body = b2
                source = "SuperMacro"
            end
        end
    end

    -- 3) CRM cache fallback (by name only)
    if not body and not numericIndex then
        if type(CleveRoids.GetMacro) == "function" then
            local m = CleveRoids.GetMacro(name)
            if m and m.body and m.body ~= "" then
                body = m.body
                source = "CRM cache"
            end
        end
    end

    if not body or body == "" then
        if CleveRoids.macroRefDebug then
            CleveRoids.Print("|cffff0000[MacroRef]|r Macro '" .. name .. "' not found in any source")
        end
        return false
    end

    if CleveRoids.macroRefDebug then
        CleveRoids.Print("|cff00ff00[MacroRef]|r Found macro '" .. name .. "' from " .. source)
    end

    -- Execute using CleveRoids' processor (supports conditionals, extended syntax)
    return CleveRoids.ExecuteMacroBody(body)
end

function CleveRoids.SetHelp(conditionals)
    if conditionals.harm then
        conditionals.help = false
    end
end

function CleveRoids.FixEmptyTarget(conditionals)
    if not conditionals.target then
        if UnitExists("target") then
            conditionals.target = "target"
        elseif GetCVar("autoSelfCast") == "1" and not conditionals.target == "help" then
            conditionals.target = "player"
        end
    end
    return false
end

-- Fixes the conditionals' target by targeting the target with the given name
-- conditionals: The conditionals containing the current target
-- name: The name of the player to target
-- hook: The target hook
-- returns: Whether or not we've changed the player's current target
function CleveRoids.FixEmptyTargetSetTarget(conditionals, name, hook)
    if not conditionals.target then
        hook(name)
        conditionals.target = "target"
        return true
    end
    return false
end

-- Returns the name of the focus target or nil
function CleveRoids.GetFocusName()
    -- 1. Add specific compatibility for pfUI.
    -- pfUI stores its focus unit information in a table.
    if pfUI and pfUI.uf and pfUI.uf.focus and pfUI.uf.focus.unitname then
        return pfUI.uf.focus.unitname
    end

    -- Fallback for other focus addons
    if ClassicFocus_CurrentFocus then
        return ClassicFocus_CurrentFocus
    elseif CURR_FOCUS_TARGET then
        return CURR_FOCUS_TARGET
    end

    return nil
end

-- Attempts to target the focus target.
-- returns: Whether or not it succeeded
function CleveRoids.TryTargetFocus()
    local name = CleveRoids.GetFocusName()

    if not name then
        return false
    end

    TargetByName(name, true)

    if not UnitExists("target") or (string.lower(UnitName("target")) ~= name) then
        -- The target switch failed (out of range, LoS, etc.)
        return false
    end

    return true
end

function CleveRoids.GetMacroNameFromAction(text)
    if string.sub(text, 1, 1) == "{" and string.sub(text, -1) == "}" then
        local name
        if string.sub(text, 2, 2) == "\"" and string.sub(text, -2, -2) == "\"" then
            return string.sub(text, 3, -3)
        else
            return string.sub(text, 2, -2)
        end
    end
end

function CleveRoids.CreateActionInfo(action, conditionals)
    local _, _, text = string.find(action, "!?%??~?(.*)")
    local spell = CleveRoids.GetSpell(text)
    local petSpell  -- Add this line
    local item, macroName, macro, macroTooltip, actionType, texture

    -- NEW: Check if the action is a slot number
    local slotId = tonumber(text)
    if slotId and slotId >= 1 and slotId <= 19 then
        actionType = "item"
        local itemTexture = GetInventoryItemTexture("player", slotId)
        if itemTexture then
            texture = itemTexture
        else
            texture = CleveRoids.unknownTexture
        end
    else
        -- Original logic for named items and spells
        if not spell then
            petSpell = CleveRoids.GetPetSpell(text)  -- Add this line
        end
        if not spell and not petSpell then  -- Modify this line
            item = CleveRoids.GetItem(text)
        end
        if not item and not petSpell then  -- Modify this line
            macroName = CleveRoids.GetMacroNameFromAction(text)
            macro = CleveRoids.GetMacro(macroName)
            macroTooltip = (macro and macro.actions) and macro.actions.tooltip
        end

        if spell then
            actionType = "spell"
            texture = spell.texture or CleveRoids.unknownTexture
        elseif petSpell then  -- Add this block
            actionType = "petspell"
            texture = petSpell.texture or CleveRoids.unknownTexture
        elseif item then
            actionType = "item"
            texture = (item and item.texture) or CleveRoids.unknownTexture
        elseif macro then
            actionType = "macro"
            texture = (macro.actions and macro.actions.tooltip and macro.actions.tooltip.texture)
                        or (macro and macro.texture)
                        or CleveRoids.unknownTexture
        end
    end

    local info = {
        action = text,
        item = item,
        spell = spell,
        petSpell = petSpell,  -- Add this line
        macro = macroTooltip,
        type = actionType,
        texture = texture,
        conditionals = conditionals,
    }

    return info
end

function CleveRoids.SplitCommandAndArgs(text)
    local _, _, cmd, args = string.find(text, "(/%w+%s?)(.*)")
    if cmd and args then
        cmd = CleveRoids.Trim(cmd)
        text = CleveRoids.Trim(args)
    end
    return cmd, args
end

function CleveRoids.ParseSequence(text)
    if not text or text == "" then return end

    -- normalize commas
    local args = string.gsub(text, "(%s*,%s*)", ",")

    -- optional [conditionals] block
    local _, condEnd, condBlock = string.find(args, "(%[.*%])")

    -- accept reset= anywhere; no trailing space required; strip it out once
    local _, _, resetVal = string.find(args, "[Rr][Ee][Ss][Ee][Tt]=([%w/]+)")
    if resetVal then
      args = string.gsub(args, "%s*[Rr][Ee][Ss][Ee][Tt]=[%w/]+%s*", " ", 1)
    end

    -- actions are what's left after any ] (if present)
    local actionSeq = CleveRoids.Trim((condEnd and string.sub(args, condEnd + 1)) or args)
    args = (condBlock or "") .. actionSeq
    if actionSeq == "" then return end

    local sequence = {
        index      = 1,
        reset      = {},
        status     = 0,
        lastUpdate = 0,
        args       = args,
        list       = {},
    }

    -- fill reset rules: seconds or flags (target/combat/alt/ctrl/shift)
    if resetVal then
        for _, rule in pairs(CleveRoids.Split(resetVal, "/")) do
            rule = string.lower(CleveRoids.Trim(rule))
            local secs = tonumber(rule)
            if secs and secs > 0 then
                sequence.reset.secs = secs
            else
                sequence.reset[rule] = true
            end
        end
    end

    -- build steps
    for _, a in ipairs(CleveRoids.Split(actionSeq, ",")) do
        local sa = CleveRoids.CreateActionInfo(CleveRoids.GetParsedMsg(a))
        table.insert(sequence.list, sa)
    end

    CleveRoids.Sequences[text] = sequence
    return sequence
end

function CleveRoids.ParseMacro(name)
    if not name then return end

    local macroID = GetMacroIndexByName(name)

    local _, texture, body
    if macroID and macroID ~= 0 then
        _, texture, body = GetMacroInfo(macroID)
    end

    if (not body) and GetSuperMacroInfo then
        _, texture, body = GetSuperMacroInfo(name)
    end

    if not texture or not body then return end

    local macro = {
        id      = macroID,
        name    = name,
        texture = texture,
        body    = body,
        actions = {},
    }
    macro.actions.list = {}

    -- build a list of testable actions for the macro
    local hasShowTooltip = false
    local showTooltipHasArg = false

    for i, line in ipairs(CleveRoids.splitString(body, "\n")) do
        line = CleveRoids.Trim(line)
        local cmd, args = CleveRoids.SplitCommandAndArgs(line)

        -- check for #showtooltip
        if i == 1 then
            local _, _, st, _, tt = string.find(line, "(#showtooltip)(%s?(.*))")

            -- if no #showtooltip, nothing to keep track of
            if not st then
                break
            end

            hasShowTooltip = true
            tt = CleveRoids.Trim(tt)

            -- #showtooltip and item/spell/macro specified, only use this tooltip
            if st and tt ~= "" then
                showTooltipHasArg = true
                for _, arg in ipairs(CleveRoids.splitStringIgnoringQuotes(tt)) do
                    -- Parse the arg to extract the spell name from any conditionals
                    local parsedArg = CleveRoids.GetParsedMsg(arg)
                    macro.actions.tooltip = CleveRoids.CreateActionInfo(parsedArg)
                    local action = CleveRoids.CreateActionInfo(parsedArg)
                    action.cmd = "/cast"
                    action.args = arg
                    action.isReactive = CleveRoids.reactiveSpells[action.action]
                    table.insert(macro.actions.list, action)
                end
                break
            end
        else
            -- make sure we have a testable action
            if line ~= "" and args ~= "" and CleveRoids.dynamicCmds[cmd] then
                for _, arg in ipairs(CleveRoids.splitStringIgnoringQuotes(args)) do
                    local action = CleveRoids.CreateActionInfo(CleveRoids.GetParsedMsg(arg))

                    if cmd == "/castsequence" then
                        local sequence = CleveRoids.GetSequence(args)
                        if sequence then
                            action.sequence = sequence
                        end
                    end
                    action.cmd = cmd
                    action.args = arg
                    action.isReactive = CleveRoids.reactiveSpells[action.action]
                    table.insert(macro.actions.list, action)
                end
            end
        end
    end

    -- If #showtooltip was present but had no argument, use the first action as the tooltip
    if hasShowTooltip and not showTooltipHasArg and table.getn(macro.actions.list) > 0 then
        macro.actions.tooltip = macro.actions.list[1]
    end

    -- Store whether #showtooltip had an explicit argument (for icon fallback logic)
    macro.actions.explicitTooltip = showTooltipHasArg

    CleveRoids.Macros[name] = macro
    return macro
end

function CleveRoids.ParseMsg(msg)
    if not msg then return end
    local conditionals = {}

    -- reset side flag for this parse
    CleveRoids._ignoretooltip = 0

    -- strip optional leading '?' and remember how many we stripped
    local ignorecount
    msg, ignorecount = string.gsub(CleveRoids.Trim(msg), "^%?", "")
    conditionals.ignoretooltip = ignorecount
    CleveRoids._ignoretooltip  = ignorecount

    -- capture a single [...] conditional block if present
    local _, cbEnd, conditionBlock = string.find(msg, "%[(.+)%]")

    -- split off flags/action after the condition block (or from start if none)
    local _, _, noSpam, cancelAura, action = string.find(
        string.sub(msg, (cbEnd or 0) + 1),
        "^%s*(!?)(~?)([^!~]+.*)"
    )
    action = CleveRoids.Trim(action or "")

    -- store the raw action for callers and strip trailing "(Rank X)" for comparisons
    conditionals.action = action
    action = string.gsub(action, "%s*%(%s*Rank%s+%d+%s*%)%s*$", "")

    -- IMPORTANT: if there's NO conditional block, return nil conditionals so
    -- DoWithConditionals will hit the {macroName} execution branch.
    if not conditionBlock then
        local hasFlag = (noSpam and noSpam ~= "") or (cancelAura and cancelAura ~= "")
        if hasFlag and action ~= "" then
            if noSpam ~= "" then
                local spamCond = CleveRoids.GetSpammableConditional(action)
                if spamCond then
                    conditionals[spamCond] = { action }
                    -- Also create _groups entry for consistency with Multi()
                    if not conditionals._groups then
                        conditionals._groups = {}
                    end
                    conditionals._groups[spamCond] = { { values = { action }, operator = "OR" } }
                end
            end
            if cancelAura ~= "" then
                conditionals.cancelaura = action
            end
            return conditionals.action, conditionals
        end
        return conditionals.action, nil
    end

    -- With a condition block present, build out the conditionals table

    -- optional spam/cancel flags (apply only when we actually have a [] block)
    if noSpam and noSpam ~= "" then
        local spamCond = CleveRoids.GetSpammableConditional(action)
        if spamCond then
            conditionals[spamCond] = { action }
            -- Also create _groups entry so Multi() finds it when combined with explicit conditionals
            if not conditionals._groups then
                conditionals._groups = {}
            end
            conditionals._groups[spamCond] = { { values = { action }, operator = "OR" } }
        end
    end
    if cancelAura and cancelAura ~= "" then
        conditionals.cancelaura = action
    end

    -- Set the action's target to @unitid if found (e.g., @mouseover)
    local _, _, target = string.find(conditionBlock, "(@[^%s,]+)")
    if target then
        conditionBlock = CleveRoids.Trim(string.gsub(conditionBlock, target, ""))
        conditionals.target = string.sub(target, 2)
    end

    if conditionBlock and conditionals.action then
        -- Split the conditional block by comma or space
        for _, conditionGroups in CleveRoids.splitStringIgnoringQuotes(conditionBlock, {",", " "}) do
            if conditionGroups ~= "" then
                -- Split conditional groups by colon
                local conditionGroup = CleveRoids.splitStringIgnoringQuotes(conditionGroups, ":")
                local condition, args = conditionGroup[1], conditionGroup[2]

                -- No args → the action is the implicit argument
                if not args or args == "" then
                    if not conditionals[condition] then
                        -- PERFORMANCE: Use module-level constant instead of creating table per-call
                        if BOOLEAN_CONDITIONALS[condition] then
                            conditionals[condition] = true
                        else
                            conditionals[condition] = conditionals.action
                            -- Create first group for non-boolean conditionals
                            if not conditionals._groups then
                                conditionals._groups = {}
                            end
                            conditionals._groups[condition] = { { values = { conditionals.action }, operator = "OR" } }
                        end
                    else
                        -- existing code for when conditionals[condition] already exists
                        if type(conditionals[condition]) ~= "table" then
                            conditionals[condition] = { conditionals[condition] }
                        end
                        table.insert(conditionals[condition], conditionals.action)

                        -- Multiple instances of same conditional = AND logic
                        if not conditionals._operators then
                            conditionals._operators = {}
                        end
                        conditionals._operators[condition] = "AND"

                        -- Add new group for this instance
                        if not conditionals._groups then
                            conditionals._groups = {}
                        end
                        if not conditionals._groups[condition] then
                            conditionals._groups[condition] = {}
                        end
                        table.insert(conditionals._groups[condition], { values = { conditionals.action }, operator = "OR" })
                    end
                else
                    -- Has args. Ensure the key's value is a table and add new arguments.
                    -- Track if this conditional already existed (repeated via comma)
                    local conditionAlreadyExists = conditionals[condition] ~= nil

                    if not conditionals[condition] then
                        conditionals[condition] = {}
                    elseif type(conditionals[condition]) ~= "table" then
                        conditionals[condition] = { conditionals[condition] }
                    end

                    -- Detect which separator is used: / (OR) or & (AND)
                    -- Initialize metadata tables if needed
                    if not conditionals._operators then
                        conditionals._operators = {}
                    end
                    if not conditionals._groups then
                        conditionals._groups = {}
                    end

                    -- Check which separator is present in the CURRENT args
                    local hasSlash = string.find(args, "/")
                    local hasAmpersand = string.find(args, "&")

                    -- Detect if & is part of a multi-comparison pattern (e.g., >0&<10)
                    -- Pattern: operator+number followed by & (with optional whitespace) followed by operator
                    -- IMPORTANT: Only whitespace allowed around &, NOT letters (to distinguish from Rip>3&Rake>3)
                    local isMultiComparison = hasAmpersand and string.find(args, "[>~=<]+%d+%.?%d*%s*&%s*[>~=<]")

                    local separator = "/"
                    local operatorType = "OR"

                    if hasAmpersand and not hasSlash and not isMultiComparison then
                        separator = "&"
                        operatorType = "AND"
                    elseif hasAmpersand and hasSlash then
                        -- Both separators present - default to / (OR) and warn
                        -- Could add a warning here in the future
                        separator = "/"
                        operatorType = "OR"
                    end

                    -- Store the operator type for this conditional (for backwards compat)
                    -- Note: when groups exist, Multi/NegatedMulti will use per-group operators
                    conditionals._operators[condition] = operatorType

                    -- Create a new group for this conditional instance
                    -- Structure: { values = { ... }, operator = "OR" or "AND" }
                    if not conditionals._groups[condition] then
                        conditionals._groups[condition] = {}
                    end
                    local currentGroup = { values = {}, operator = operatorType }
                    table.insert(conditionals._groups[condition], currentGroup)

                    -- Split args by the determined separator
                    for _, arg_item in CleveRoids.splitString(args, separator) do
                        local processed_arg = CleveRoids.Trim(arg_item)

                        processed_arg = string.gsub(processed_arg, '"', "")
                        processed_arg = string.gsub(processed_arg, "_", " ")
                        processed_arg = CleveRoids.Trim(processed_arg)

                        -- normalize "name#N" → "name=#N" and "#N" → "=#N"
                        local arg_for_find = processed_arg
                        arg_for_find = string.gsub(arg_for_find, "^#(%d+)$", "=#%1")
                        arg_for_find = string.gsub(arg_for_find, "([^>~=<]+)#(%d+)", "%1=#%2")

                        -- accept decimals too; capture name/op/amount
                        local _, _, name, operator, amount = string.find(arg_for_find, "([^>~=<]*)([>~=<]+)(#?%d*%.?%d+)")

                        if not operator or not amount then
                            -- No operator found, treat as simple string argument
                            table.insert(conditionals[condition], processed_arg)
                            table.insert(currentGroup.values, processed_arg)
                        else
                            local name_to_use = (name and name ~= "") and name or conditionals.action
                            local final_amount_str, num_replacements = string.gsub(amount, "#", "")
                            local should_check_stacks = (num_replacements == 1)

                            -- SPECIAL HANDLING FOR CONDITIONALS WITH MULTIPLE COMPARISONS
                            -- Detect if this conditional has multiple operators
                            -- Example: "ap>1800/<2200" or "Recently_Bandaged>0&<10" or "health>50&<80"
                            -- Works with ANY conditional that supports numeric operators
                            -- Pattern: only whitespace or separators allowed between comparisons, NOT letters
                            if string.find(processed_arg, "[>~=<]+%d+%.?%d*%s*[/&]%s*[>~=<]") then
                                -- This arg has multiple comparisons, parse them all
                                local stat_name = name_to_use
                                local comparisons = {}

                                -- Extract all operator+number pairs
                                -- Pattern matches operator followed by optional decimal number
                                local gfind_func = string.gfind or string.gmatch
                                for op, num in gfind_func(processed_arg, "([>~=<]+)(#?%d*%.?%d+)") do
                                    local clean_num = string.gsub(num, "#", "")
                                    local check_stacks = (string.find(num, "#") ~= nil)
                                    table.insert(comparisons, {
                                        operator = op,
                                        amount = tonumber(clean_num),
                                        checkStacks = check_stacks
                                    })
                                end

                                if table.getn(comparisons) > 0 then
                                    local entry = {
                                        name = CleveRoids.Trim(stat_name),
                                        comparisons = comparisons  -- Store all comparisons
                                    }
                                    table.insert(conditionals[condition], entry)
                                    table.insert(currentGroup.values, entry)
                                else
                                    -- Fallback to single comparison if parsing failed
                                    local entry = {
                                        name = CleveRoids.Trim(name_to_use),
                                        operator = operator,
                                        amount = tonumber(final_amount_str),
                                        checkStacks = should_check_stacks
                                    }
                                    table.insert(conditionals[condition], entry)
                                    table.insert(currentGroup.values, entry)
                                end
                            else
                                -- Normal single-comparison conditional (existing behavior)
                                local entry = {
                                    name = CleveRoids.Trim(name_to_use),
                                    operator = operator,
                                    amount = tonumber(final_amount_str),
                                    checkStacks = should_check_stacks
                                }
                                table.insert(conditionals[condition], entry)
                                table.insert(currentGroup.values, entry)
                            end
                        end
                    end
                end
            end
        end
        return conditionals.action, conditionals
    end
end


-- Get previously parsed or parse, store and return
function CleveRoids.GetParsedMsg(msg)
    if not msg then return end

    -- PERFORMANCE: Check cache first before doing string operations
    local cached = CleveRoids.ParsedMsg[msg]
    if cached then
        -- Use cached ignoretooltip value (already computed during first parse)
        CleveRoids._ignoretooltip = cached.ignoretooltip or 0
        return cached.action, cached.conditionals
    end

    -- Only compute ignoretooltip for new messages (not cache hits)
    -- PERFORMANCE: Use string.sub for simple prefix check instead of gsub
    local trimmed = CleveRoids.Trim(msg)
    local ignorecount = (string.sub(trimmed, 1, 1) == "?") and 1 or 0
    CleveRoids._ignoretooltip = ignorecount

    local action, conditionals = CleveRoids.ParseMsg(msg)
    CleveRoids.ParsedMsg[msg] = {
        action         = action,
        conditionals   = conditionals,
        ignoretooltip  = ignorecount,
    }
    return action, conditionals
end


function CleveRoids.GetMacro(name)
    return CleveRoids.Macros[name] or CleveRoids.ParseMacro(name)
end

function CleveRoids.GetSequence(args)
    return CleveRoids.Sequences[args] or CleveRoids.ParseSequence(args)
end

function CleveRoids.GetCurrentSequenceAction(sequence)
    return sequence.list[sequence.index]
end

function CleveRoids.ResetSequence(sequence)
    sequence.index = 1
end

function CleveRoids.AdvanceSequence(sequence)
    if sequence.index < table.getn(sequence.list) then
        -- Not at the end yet, just advance normally
        sequence.index = sequence.index + 1
    else
        -- At the end of sequence - check if we should auto-reset or stay at last step
        local hasNonModifierReset = false

        if sequence.reset then
            -- Check if there are any reset conditions besides modifier keys
            for k, _ in pairs(sequence.reset) do
                -- target, combat, secs are non-modifier resets
                if k ~= "alt" and k ~= "ctrl" and k ~= "shift" then
                    hasNonModifierReset = true
                    break
                end
            end
        end

        -- Only auto-reset if:
        -- 1. No reset table exists at all, OR
        -- 2. Reset table only contains modifier keys (alt/ctrl/shift)
        -- Otherwise, stay on the last step and keep casting it until reset fires
        if not hasNonModifierReset then
            CleveRoids.ResetSequence(sequence)
        end
        -- If hasNonModifierReset is true, sequence.index stays at max,
        -- so GetCurrentSequenceAction will keep returning the last spell
    end
end

function CleveRoids.TestAction(cmd, args)
    local msg, conditionals = CleveRoids.GetParsedMsg(args)

    -- Nil-safe guards
    local hasShowTooltip = (type(msg) == "string") and string.find(msg, "#showtooltip")
    local ignoreTooltip  = ((type(conditionals) == "table") and (conditionals.ignoretooltip == 1))
                           or (CleveRoids._ignoretooltip == 1)

    -- If the line is explicitly ignored for tooltip (via '?'),
    -- or it is a '#showtooltip' token, do not contribute icon/tooltip.
    if hasShowTooltip or ignoreTooltip then
        CleveRoids._ignoretooltip = 0 -- clear for next parse
        return
    end

    -- No [] block → return a testable token so the UI can pick a texture
    if not conditionals then
        if not msg or msg == "" then
            return
        else
            return CleveRoids.GetMacroNameFromAction(msg) or msg
        end
    end

    local origTarget = conditionals.target
    if cmd == "" or not CleveRoids.dynamicCmds[cmd] then
        return
    end

    if conditionals.target == "focus" then
        local focusUnitId = nil
        if pfUI and pfUI.uf and pfUI.uf.focus and pfUI.uf.focus.label and pfUI.uf.focus.id
           and UnitExists(pfUI.uf.focus.label .. pfUI.uf.focus.id) then
            focusUnitId = pfUI.uf.focus.label .. pfUI.uf.focus.id
        end
        if focusUnitId then
            conditionals.target = focusUnitId
        else
            if not CleveRoids.GetFocusName() then
                return
            end
            conditionals.target = "target"
        end
    end

    if conditionals.target == "mouseover" then
        if not CleveRoids.IsValidTarget("mouseover", conditionals.help) then
            return false
        end
    end

    CleveRoids.FixEmptyTarget(conditionals)

    -- PERFORMANCE: Use next() directly instead of pairs() to avoid iterator allocation
    local k, v = next(conditionals)
    while k do
        if not CleveRoids.ignoreKeywords[k] then
            if not CleveRoids.Keywords[k] or not CleveRoids.Keywords[k](conditionals) then
                conditionals.target = origTarget
                return
            end
        end
        k, v = next(conditionals, k)
    end

    conditionals.target = origTarget
    return CleveRoids.GetMacroNameFromAction(msg) or msg
end

function CleveRoids.DoWithConditionals(msg, hook, fixEmptyTargetFunc, targetBeforeAction, action)
    -- Check macro stop flags (skip non-control commands when flag is set)
    -- This enables /stopmacro, /skipmacro, /firstaction, /nofirstaction to work without SuperMacro for vanilla macros
    if (CleveRoids.stopMacroFlag or CleveRoids.skipMacroFlag) and action ~= "STOPMACRO" and action ~= "SKIPMACRO" and action ~= "FIRSTACTION" and action ~= "NOFIRSTACTION" then
        return false
    end

    local msg, conditionals = CleveRoids.GetParsedMsg(msg)

    -- Debug: Log parsed msg and action type
    if CleveRoids.equipDebugLog and action and action ~= CastSpellByName then
        CleveRoids.Print("|cff888888[EquipLog] DoWithConditionals: parsed msg='" .. tostring(msg) .. "' action=" .. tostring(action) .. "|r")
    end

    -- No conditionals. Just exit.
    if not conditionals then
        if not msg then -- if not even an empty string
            return false
        else
            if string.sub(msg, 1, 1) == "{" and string.sub(msg, -1) == "}" then
                if string.sub(msg, 2, 2) == "\"" and string.sub(msg, -2, -2) == "\"" then
                    return CleveRoids.ExecuteMacroBody(string.sub(msg, 3, -3), true)
                else
                    return CleveRoids.ExecuteMacroByName(string.sub(msg, 2, -2))
                end
            end

            -- Handle STOPMACRO/SKIPMACRO/FIRSTACTION/NOFIRSTACTION without conditionals (bare command)
            if action == "STOPMACRO" then
                CleveRoids.stopMacroFlag = true
                return true
            elseif action == "SKIPMACRO" then
                CleveRoids.skipMacroFlag = true
                return true
            elseif action == "FIRSTACTION" then
                CleveRoids.stopOnCastFlag = true
                return true
            elseif action == "NOFIRSTACTION" then
                CleveRoids.stopOnCastFlag = false
                return true
            end

            if hook then
                hook(msg)
            end
            return true
        end
    end

    if conditionals.cancelaura then
        if CleveRoids.CancelAura(conditionals.cancelaura) then
            return true
        end
    end

    local origTarget = conditionals.target
    if conditionals.target == "mouseover" then
        if UnitExists("mouseover") then
            conditionals.target = "mouseover"
        elseif CleveRoids.mouseoverUnit and UnitExists(CleveRoids.mouseoverUnit) then
            conditionals.target = CleveRoids.mouseoverUnit
        else
            conditionals.target = "mouseover"
        end
    end

    local needRetarget = false
    if fixEmptyTargetFunc then
        needRetarget = fixEmptyTargetFunc(conditionals, msg, hook)
    end

    -- CleveRoids.SetHelp(conditionals)

    if conditionals.target == "focus" then
        local focusUnitId = nil

        -- Attempt to get the direct UnitID from pfUI's focus frame data. This is more reliable.
        if pfUI and pfUI.uf and pfUI.uf.focus and pfUI.uf.focus.label and pfUI.uf.focus.id and UnitExists(pfUI.uf.focus.label .. pfUI.uf.focus.id) then
            focusUnitId = pfUI.uf.focus.label .. pfUI.uf.focus.id
        end

        if focusUnitId then
                -- If we found a valid UnitID, we will use it for all subsequent checks and the final cast.
                -- This avoids changing the player's actual target.
            conditionals.target = focusUnitId
            needRetarget = false
        else
            -- return false if pfUI is installed and no focus is set instead of "invalid target"
            if pfUI and (pfUI.uf.focus.label == nil or pfUI.uf.focus.label == "") then return false end
            -- If the direct UnitID isn't found, fall back to the original (but likely failing) method of targeting by name.
            if not CleveRoids.TryTargetFocus() then
                UIErrorsFrame:AddMessage(SPELL_FAILED_BAD_TARGETS, 1.0, 0.0, 0.0, 1.0)
                conditionals.target = origTarget
                return false
            end
            conditionals.target = "target"
            needRetarget = true
        end
    end

    -- Handle [multiscan:priority] - scan enemies and find best target
    -- Must be processed BEFORE the Keywords loop since it sets conditionals.target
    -- Pass origTarget so @unit syntax makes that unit exempt from combat check
    if conditionals.multiscan then
        local scanResult = CleveRoids.ResolveMultiscanTarget(conditionals, origTarget)
        if not scanResult then
            -- No valid target found - fail this conditional line (try next)
            conditionals.target = origTarget
            return false
        end
        -- Set target to the found GUID for soft-casting via SuperWoW
        conditionals.target = scanResult
        -- Don't need to retarget since we're using GUID directly
        needRetarget = false
    end

    for k, v in pairs(conditionals) do
        if not CleveRoids.ignoreKeywords[k] then
            local result = CleveRoids.Keywords[k] and CleveRoids.Keywords[k](conditionals)
            -- Debug logging for equipped conditional when equipDebugLog is enabled
            if CleveRoids.equipDebugLog and (k == "equipped" or k == "noequipped") then
                local valStr = type(v) == "table" and table.concat(v, ", ") or tostring(v)
                CleveRoids.Print("|cff888888[EquipLog] Conditional [" .. k .. ":" .. valStr .. "] = " ..
                    (result and "|cff00ff00PASS|r" or "|cffff0000FAIL|r") .. "|r")
            end
            -- Debug logging for macro reference debug
            if CleveRoids.macroRefDebug then
                local valStr = (v == true) and "" or (type(v) == "table" and table.concat(v, ", ") or tostring(v))
                CleveRoids.Print("|cff888888[MacroRef]|r [" .. k .. (valStr ~= "" and (":" .. valStr) or "") .. "] = " ..
                    (result and "|cff00ff00PASS|r" or "|cffff0000FAIL|r"))
            end
            if not result then
                if needRetarget then
                    TargetLastTarget()
                    needRetarget = false
                end
                conditionals.target = origTarget
                return false
            end
        end
    end

    if conditionals.target ~= nil and targetBeforeAction and not (CleveRoids.hasSuperwow and action == CastSpellByName) then
        if not UnitIsUnit("target", conditionals.target) then
            if SpellIsTargeting() then
                SpellStopCasting()
            end
            TargetUnit(conditionals.target)
            needRetarget = true
        else
             if needRetarget then needRetarget = false end
        end
    elseif needRetarget then
        TargetLastTarget()
        needRetarget = false
    end

    if action == "STOPMACRO" then
        -- Set flag to stop subsequent lines in current macro AND parent macros
        CleveRoids.stopMacroFlag = true
        return true
    elseif action == "SKIPMACRO" then
        -- Set flag to skip remaining lines in current submacro only
        CleveRoids.skipMacroFlag = true
        return true
    elseif action == "FIRSTACTION" then
        -- Set flag to stop on first successful cast/use
        CleveRoids.stopOnCastFlag = true
        return true
    elseif action == "NOFIRSTACTION" then
        -- Clear flag to re-enable multi-queue behavior
        CleveRoids.stopOnCastFlag = false
        return true
    end

    local result = true
    if string.sub(msg, 1, 1) == "{" and string.sub(msg, -1) == "}" then
        if CleveRoids.macroRefDebug then
            CleveRoids.Print("|cff00ffff[MacroRef]|r Detected macro reference: " .. msg)
        end
        if string.sub(msg, 2, 2) == "\"" and string.sub(msg, -2,-2) == "\"" then
            result = CleveRoids.ExecuteMacroBody(string.sub(msg, 3, -3), true)
        else
            result = CleveRoids.ExecuteMacroByName(string.sub(msg, 2, -2))
        end
    elseif msg == "" or msg == nil then
        -- Empty action (conditionals passed but no spell to cast)
        -- For non-spell actions (pet commands, etc.), still execute the action
        if CleveRoids.equipDebugLog and action and action ~= CastSpellByName then
            CleveRoids.Print("|cffff8800[EquipLog] Empty msg branch - calling action() with no args|r")
        end
        if action and action ~= CastSpellByName then
            action()
            result = true
        else
            result = false
        end
    else
        local castMsg = msg
        -- FLEXIBLY check for any rank text like "(Rank 9)" before adding the highest rank
        -- Use specific "(Rank" check instead of any parentheses, so spells like
        -- "Faerie Fire (Feral)" still get their rank appended automatically
        if action == CastSpellByName and not string.find(msg, "%(Rank") then
            local sp = CleveRoids.GetSpell(msg)
            local rank = sp and (sp.rank or (sp.highest and sp.highest.rank))
            if rank and rank ~= "" then
                castMsg = msg .. "(" .. rank .. ")"
            end
        end
        if action == CastSpellByName then
            -- Let Nampower DLL handle queuing natively via its CastSpellByName hook
            if CleveRoids.hasSuperwow and conditionals.target then
                CastSpellByName(castMsg, conditionals.target)
            else
                CastSpellByName(castMsg)
            end
        else
            -- For other actions like UseContainerItem etc.
            if CleveRoids.equipDebugLog then
                CleveRoids.Print("|cff00ff00[EquipLog] Calling action('" .. tostring(msg) .. "')|r")
            end
            action(msg)
        end
    end

    if needRetarget then
        TargetLastTarget()
    end

    conditionals.target = origTarget
    return result
end

function CleveRoids.DoCast(msg)
    if CleveRoids.ChannelTimeDebug then
        if msg and string.find(msg, "Arcane") then
            DEFAULT_CHAT_FRAME:AddMessage("|cffff00ff[/cast BUTTON PRESS]|r " .. msg)
        end
    end

    -- PERFORMANCE: Use numeric iteration to avoid pairs() iterator allocation
    local parts = CleveRoids.splitStringIgnoringQuotes(msg)
    for i = 1, table.getn(parts) do
        local v = parts[i]
        if CleveRoids.DoWithConditionals(v, CleveRoids.Hooks.CAST_SlashCmd, CleveRoids.FixEmptyTarget, not CleveRoids.hasSuperwow, CastSpellByName) then
            -- If /firstaction was used, stop macro evaluation after first successful cast
            if CleveRoids.stopOnCastFlag then
                CleveRoids.stopMacroFlag = true
            end
            return true
        end
    end
    return false
end

-- PERFORMANCE: Module-level pet cast action to avoid closure allocation per call
local function _petCastAction(spellName)
    local petSpell = CleveRoids.GetPetSpell(spellName)
    if petSpell and petSpell.slot then
        CastPetAction(petSpell.slot)
        return true
    end
    return false
end

function CleveRoids.DoCastPet(msg)
    -- PERFORMANCE: Use numeric iteration to avoid pairs() iterator allocation
    local parts = CleveRoids.splitStringIgnoringQuotes(msg)
    for i = 1, table.getn(parts) do
        local v = parts[i]
        if CleveRoids.DoWithConditionals(v, _petCastAction, CleveRoids.FixEmptyTarget, false, _petCastAction) then
            return true
        end
    end
    return false
end

function CleveRoids.DoTarget(msg)
    -- Check macro stop flags
    if CleveRoids.stopMacroFlag or CleveRoids.skipMacroFlag then
        return false
    end

    local action, conditionals = CleveRoids.GetParsedMsg(msg)

    if action ~= "" or type(conditionals) ~= "table" or not next(conditionals) then
        CleveRoids.Hooks.TARGET_SlashCmd(msg)
        return true
    end

    local function IsGuidValid(unitTok, conds)
        if not unitTok or not UnitExists(unitTok) or UnitIsDeadOrGhost(unitTok) then
            return false
        end
        local orig = conds.target
        conds.target = unitTok
        local ok = true
        for k, _ in pairs(conds) do
            if not CleveRoids.ignoreKeywords[k] then
                local fn = CleveRoids.Keywords[k]
                if not fn or not fn(conds) then ok = false; break end
            end
        end
        conds.target = orig
        return ok
    end

    -- Save original target GUID for potential restoration (SuperWoW returns GUID as 2nd value)
    local _, originalTargetGuid = UnitExists("target")

    -- Track if an explicit target was specified via @unit syntax
    local explicitTarget = conditionals.target

    do
        local unitTok = conditionals.target

        if unitTok == "mouseover" then
            if UnitExists("mouseover") then
                unitTok = "mouseover"
            elseif CleveRoids.mouseoverUnit and UnitExists(CleveRoids.mouseoverUnit) then
                unitTok = CleveRoids.mouseoverUnit
            elseif pfUI and pfUI.uf and pfUI.uf.mouseover and pfUI.uf.mouseover.unit
               and UnitExists(pfUI.uf.mouseover.unit) then
                unitTok = pfUI.uf.mouseover.unit
            else
                unitTok = nil
            end
        end

        if unitTok == "focus" and pfUI and pfUI.uf and pfUI.uf.focus
           and pfUI.uf.focus.label and pfUI.uf.focus.id then
            local fTok = pfUI.uf.focus.label .. pfUI.uf.focus.id
            if UnitExists(fTok) then unitTok = fTok else unitTok = nil end
        end

        if unitTok and UnitExists(unitTok) and IsGuidValid(unitTok, conditionals) then
            TargetUnit(unitTok)
            return true
        end

        -- If an explicit target was specified via @unit syntax but doesn't exist or isn't valid,
        -- return false instead of falling through to candidate search.
        -- This ensures "/target [@mouseover,harm,alive]" does nothing when mouse is over empty ground.
        if explicitTarget then
            return false
        end
    end

    if UnitExists("target") and IsGuidValid("target", conditionals) then
        return true
    end

    local candidates = {}
    local wantsHelp = conditionals.help
    local wantsHarm = conditionals.harm

    local function addCandidate(unitId)
        if not UnitExists(unitId) then return end

        if wantsHelp and not UnitCanAssist("player", unitId) then return end

        if wantsHarm and not UnitCanAttack("player", unitId) then return end

        table.insert(candidates, { unitId = unitId })
    end

    addCandidate("mouseover")

    addCandidate("target")

    if not wantsHarm then
        table.insert(candidates, { unitId = "player" })
    end

    addCandidate("pet")

    for i = 1, 4 do
        addCandidate("party"..i)
        addCandidate("partypet"..i)
        addCandidate("party"..i.."target")
    end

    for i = 1, 40 do
        addCandidate("raid"..i)
        addCandidate("raidpet"..i)
        addCandidate("raid"..i.."target")
    end

    addCandidate("targettarget")
    addCandidate("targettargettarget")

    addCandidate("pettarget")

    if pfUI and pfUI.uf and pfUI.uf.focus and pfUI.uf.focus.label and pfUI.uf.focus.id then
        local focusTok = pfUI.uf.focus.label .. pfUI.uf.focus.id
        addCandidate(focusTok)
    end

    if CleveRoids.hasSuperwow then
        local numChildren = WorldFrame:GetNumChildren()
        local children = { WorldFrame:GetChildren() }

        for i = 1, numChildren do
            local frame = children[i]
            if frame and frame:IsVisible() then
                local success, guid = pcall(frame.GetName, frame, 1)
                if success and guid and type(guid) == "string" and string.len(guid) > 0 then
                    if UnitExists(guid) then
                        addCandidate(guid)
                    end
                end
            end
        end
    end

    for _, c in ipairs(candidates) do
        if IsGuidValid(c.unitId, conditionals) then
            TargetUnit(c.unitId)
            return true
        end
    end

    -- UnitXP 3D enemy scanning: cycles through enemies in world space (no nameplate required)
    -- This is the most powerful scan - finds enemies by line of sight and distance
    -- Always enabled unless explicitly looking for friendlies only ([help] without [harm])
    -- UnitXP only finds enemies, so this is safe for any /target with conditionals
    local wantsFriendlyOnly = wantsHelp and not wantsHarm
    if not wantsFriendlyOnly and CleveRoids.hasUnitXP then
        -- Try nearestEnemy first - most common case and most efficient
        local found = UnitXP("target", "nearestEnemy")
        if found and UnitExists("target") and IsGuidValid("target", conditionals) then
            return true
        end

        -- Determine scan mode: use distance-priority for melee conditionals
        local wantsMelee = conditionals.meleerange or conditionals.nomeleerange
        local scanMode = wantsMelee and "nextEnemyConsideringDistance" or "nextEnemyInCycle"

        local seenGuids = {}
        local firstGuid = nil
        local maxIterations = 50  -- Safety limit

        for i = 1, maxIterations do
            found = UnitXP("target", scanMode)
            if not found then break end

            local _, currentGuid = UnitExists("target")
            if not currentGuid then break end

            -- Check if we've cycled back to start
            if firstGuid == nil then
                firstGuid = currentGuid
            elseif currentGuid == firstGuid then
                break  -- Completed full cycle
            end

            -- Skip already-seen targets
            if not seenGuids[currentGuid] then
                seenGuids[currentGuid] = true

                -- Test this target against all conditionals
                if IsGuidValid("target", conditionals) then
                    return true  -- Found matching target
                end
            end
        end

        -- No match found via UnitXP scan - restore original target if we had one
        if originalTargetGuid and UnitExists(originalTargetGuid) then
            TargetUnit(originalTargetGuid)
        elseif not originalTargetGuid then
            ClearTarget()
        end
    end

    return true
end

-- Attempts to attack a unit by a set of conditionals
-- msg: The raw message intercepted from a /petattack command
function CleveRoids.DoPetAction(action, msg)
    -- PERFORMANCE: Use numeric iteration to avoid pairs() iterator allocation
    local parts = CleveRoids.splitStringIgnoringQuotes(msg)
    for i = 1, table.getn(parts) do
        if CleveRoids.DoWithConditionals(parts[i], action, CleveRoids.FixEmptyTarget, true, action) then
            return true
        end
    end
    return false
end

-- PERFORMANCE: Module-level action to avoid closure allocation per call
local function _startAttackAction()
    if not UnitExists("target") or UnitIsDead("target") then TargetNearestEnemy() end
    if not CleveRoids.CurrentSpell.autoAttack and not CleveRoids.CurrentSpell.autoAttackLock and UnitExists("target") and UnitCanAttack("player", "target") then
        CleveRoids.CurrentSpell.autoAttackLock = true
        CleveRoids.autoAttackLockElapsed = GetTime()
        AttackTarget()
    end
end

-- Attempts to conditionally start an attack. Returns false if no conditionals are found.
function CleveRoids.DoConditionalStartAttack(msg)
    if not string.find(msg, "%[") then return false end

    -- PERFORMANCE: Use numeric iteration to avoid pairs() iterator allocation
    local parts = CleveRoids.splitStringIgnoringQuotes(msg)
    for i = 1, table.getn(parts) do
        -- We pass 'nil' for the hook, so DoWithConditionals does nothing if it fails to parse conditionals.
        if CleveRoids.DoWithConditionals(parts[i], nil, CleveRoids.FixEmptyTarget, false, _startAttackAction) then
            return true
        end
    end
    return false
end

-- PERFORMANCE: Module-level actions to avoid closure allocation per call
local function _stopAttackAction()
    if CleveRoids.CurrentSpell.autoAttack and UnitExists("target") then
        AttackTarget()
        CleveRoids.CurrentSpell.autoAttack = false
    end
end

local function _stopCastingAction()
    SpellStopCasting()
end

local function _clearTargetAction()
    ClearTarget()
end

-- Attempts to conditionally stop an attack. Returns false if no conditionals are found.
function CleveRoids.DoConditionalStopAttack(msg)
    if not string.find(msg, "%[") then return false end

    -- PERFORMANCE: Use numeric iteration to avoid pairs() iterator allocation
    local parts = CleveRoids.splitStringIgnoringQuotes(msg)
    for i = 1, table.getn(parts) do
        if CleveRoids.DoWithConditionals(parts[i], nil, CleveRoids.FixEmptyTarget, false, _stopAttackAction) then
            return true
        end
    end
    return false
end

-- Attempts to conditionally stop casting. Returns false if no conditionals are found.
function CleveRoids.DoConditionalStopCasting(msg)
    if not string.find(msg, "%[") then return false end

    -- PERFORMANCE: Use numeric iteration to avoid pairs() iterator allocation
    local parts = CleveRoids.splitStringIgnoringQuotes(msg)
    for i = 1, table.getn(parts) do
        if CleveRoids.DoWithConditionals(parts[i], nil, CleveRoids.FixEmptyTarget, false, _stopCastingAction) then
            return true
        end
    end
    return false
end

-- Attempts to conditionally clear target. Returns false if no conditionals are found.
function CleveRoids.DoConditionalClearTarget(msg)
    if not string.find(msg, "%[") then return false end

    -- PERFORMANCE: Use numeric iteration to avoid pairs() iterator allocation
    local parts = CleveRoids.splitStringIgnoringQuotes(msg)
    for i = 1, table.getn(parts) do
        if CleveRoids.DoWithConditionals(parts[i], nil, CleveRoids.FixEmptyTarget, false, _clearTargetAction) then
            return true
        end
    end
    return false
end


-- Attempts to use or equip an item by a set of conditionals
-- Also checks if a condition is a spell so that you can mix item and spell use
-- msg: The raw message intercepted from a /use or /equip command
function CleveRoids.DoUse(msg)
    -- Check macro stop flags
    if CleveRoids.stopMacroFlag or CleveRoids.skipMacroFlag then
        return false
    end

    local handled = false

    local action = function(msg)
        -- Defensive: make sure we are not in "split stack" mode and nothing is on the cursor
        if type(CloseStackSplitFrame) == "function" then CloseStackSplitFrame() end
        if CursorHasItem and CursorHasItem() then ClearCursor() end

        -- Try to interpret the message as a direct inventory slot ID first.
        local slotId = tonumber(msg)
        if slotId and slotId >= 1 and slotId <= 19 then -- Character slots are 1-19
            ClearCursor() -- extra safety before using equipped items
            UseInventoryItem(slotId)
            return
        end

        -- Try to interpret as item ID (numbers > 19)
        -- v2.18+: Use FindPlayerItemSlot directly for item IDs (no name resolution needed)
        if slotId and slotId > 19 then
            local API = CleveRoids.NampowerAPI
            -- v2.18+: Native lookup can find item directly by ID
            if API and API.features and API.features.hasFindPlayerItemSlot then
                local itemInfo = API.FindItemFast(slotId)
                if itemInfo then
                    ClearCursor()
                    if itemInfo.inventoryID then
                        if CleveRoids.equipDebugLog then
                            CleveRoids.Print("|cff888888[UseLog] /use " .. slotId .. " via UseInventoryItem(" .. itemInfo.inventoryID .. ") [v2.18 ID lookup]|r")
                        end
                        UseInventoryItem(itemInfo.inventoryID)
                        return
                    elseif itemInfo.bagID and itemInfo.slot then
                        if CleveRoids.equipDebugLog then
                            CleveRoids.Print("|cff888888[UseLog] /use " .. slotId .. " via UseContainerItem(" .. itemInfo.bagID .. "," .. itemInfo.slot .. ") [v2.18 ID lookup]|r")
                        end
                        UseContainerItem(itemInfo.bagID, itemInfo.slot)
                        return
                    end
                end
                -- Item not found by ID - fail
                if CleveRoids.equipDebugLog then
                    CleveRoids.Print("|cffff8800[UseLog] Item ID " .. slotId .. " not found in inventory [v2.18]|r")
                end
                return
            end

            -- Fallback: Resolve item ID to name for legacy lookup
            local itemName = nil
            if API and API.GetItemName then
                itemName = API.GetItemName(slotId)
            end
            -- Fall back to GetItemInfo
            if not itemName and GetItemInfo then
                itemName = GetItemInfo(slotId)
            end
            if itemName then
                if CleveRoids.equipDebugLog then
                    CleveRoids.Print("|cff888888[UseLog] Resolved item ID " .. slotId .. " to '" .. itemName .. "'|r")
                end
                msg = itemName  -- Replace ID with name for subsequent lookups
            else
                if CleveRoids.equipDebugLog then
                    CleveRoids.Print("|cffff8800[UseLog] Could not resolve item ID " .. slotId .. " - item not in cache|r")
                end
                -- Item not in client cache - can't resolve without seeing it first
                return
            end
        end

        -- v2.18+: Use native fast lookup (much faster than Lua cache + scan)
        local API = CleveRoids.NampowerAPI
        if API and API.features and API.features.hasFindPlayerItemSlot then
            local itemInfo = API.FindItemFast(msg)
            if itemInfo then
                ClearCursor()
                if itemInfo.inventoryID then
                    if CleveRoids.equipDebugLog then
                        CleveRoids.Print("|cff888888[UseLog] /use " .. msg .. " via UseInventoryItem(" .. itemInfo.inventoryID .. ") [v2.18 native]|r")
                    end
                    UseInventoryItem(itemInfo.inventoryID)
                    return
                elseif itemInfo.bagID and itemInfo.slot then
                    if CleveRoids.equipDebugLog then
                        CleveRoids.Print("|cff888888[UseLog] /use " .. msg .. " via UseContainerItem(" .. itemInfo.bagID .. "," .. itemInfo.slot .. ") [v2.18 native]|r")
                    end
                    UseContainerItem(itemInfo.bagID, itemInfo.slot)
                    return
                end
            end
            -- v2.18 lookup didn't find item - fall through to legacy path
            -- (might be partial match or different case that native doesn't handle)
        end

        -- PERFORMANCE: Try cache lookup first (O(1) instead of O(n) scan)
        -- IMPORTANT: Validate cache hits to prevent stale data during combat
        -- (IndexItems() is skipped during combat, so cache may have old bag/slot locations)
        local location = CleveRoids.FindItemLocation(msg)
        if location then
            local cacheValid = false
            local qname = string_lower(msg)

            if location.type == "inventory" then
                -- Validate: check if this slot actually contains the item we want
                local link = GetInventoryItemLink("player", location.inventoryID)
                if link then
                    local _, _, nm = string_find(link, "|h%[(.-)%]|h")
                    if nm and string_lower(nm) == qname then
                        cacheValid = true
                    end
                end
            else
                -- Validate: check if this bag slot actually contains the item we want
                local link = GetContainerItemLink(location.bag, location.slot)
                if link then
                    local _, _, nm = string_find(link, "|h%[(.-)%]|h")
                    if nm and string_lower(nm) == qname then
                        cacheValid = true
                    end
                end
            end

            if cacheValid then
                ClearCursor()
                if location.type == "inventory" then
                    if CleveRoids.equipDebugLog then
                        CleveRoids.Print("|cff888888[UseLog] /use " .. msg .. " via UseInventoryItem(" .. location.inventoryID .. ") [cached]|r")
                    end
                    UseInventoryItem(location.inventoryID)
                else
                    if CleveRoids.equipDebugLog then
                        CleveRoids.Print("|cff888888[UseLog] /use " .. msg .. " via UseContainerItem(" .. location.bag .. "," .. location.slot .. ") [cached]|r")
                    end
                    UseContainerItem(location.bag, location.slot)
                end
                return
            elseif CleveRoids.equipDebugLog then
                CleveRoids.Print("|cff888888[UseLog] /use " .. msg .. " - cache STALE, falling back to scan|r")
            end
        end

        -- Slow path fallback: full scan for substring matches or cache miss
        local qname = string_lower(msg)

        -- Search equipped inventory slots first (for trinkets, etc.)
        for slot = 0, 19 do
            local link = GetInventoryItemLink("player", slot)
            if link then
                local _, _, nm = string_find(link, "|h%[(.-)%]|h")
                if nm and string_lower(nm) == qname then
                    if CleveRoids.equipDebugLog then
                        CleveRoids.Print("|cff888888[UseLog] /use " .. msg .. " via UseInventoryItem(" .. slot .. ")|r")
                    end
                    ClearCursor()
                    UseInventoryItem(slot)
                    return
                end
            end
        end

        -- Then search bags
        for bag = 0, 4 do
            local numSlots = GetContainerNumSlots(bag) or 0
            for bagSlot = 1, numSlots do
                local link = GetContainerItemLink(bag, bagSlot)
                if link then
                    local _, _, nm = string_find(link, "|h%[(.-)%]|h")
                    if nm and string_lower(nm) == qname then
                        if CleveRoids.equipDebugLog then
                            CleveRoids.Print("|cff888888[UseLog] /use " .. msg .. " via UseContainerItem(" .. bag .. "," .. bagSlot .. ")|r")
                        end
                        ClearCursor()
                        UseContainerItem(bag, bagSlot)
                        return
                    end
                end
            end
        end

        if CleveRoids.equipDebugLog then
            CleveRoids.Print("|cff888888[UseLog] /use " .. msg .. " - not found in equipped slots or bags|r")
        end
    end

    -- PERFORMANCE: Use numeric iteration to avoid pairs() iterator allocation
    local parts = CleveRoids.splitStringIgnoringQuotes(msg)
    for i = 1, table.getn(parts) do
        if CleveRoids.DoWithConditionals(parts[i], action, CleveRoids.FixEmptyTarget, false, action) then
            -- If /firstaction was used, stop macro evaluation after first successful use
            if CleveRoids.stopOnCastFlag then
                CleveRoids.stopMacroFlag = true
            end
            return true
        end
    end
    return false
end

function CleveRoids.EquipBagItem(msg, slotOrOffhand)
    if CleveRoids.equipDebugLog then
        CleveRoids.Print("|cff00ffff[EquipLog] EquipBagItem called: '" .. tostring(msg) .. "' slot=" .. tostring(slotOrOffhand) .. "|r")
    end

    if CleveRoids.equipInProgress then
        if CleveRoids.equipDebugLog then
            CleveRoids.Print("|cffff0000[EquipLog] Equip already in progress, skipping|r")
        end
        return false
    end

    -- Accept slot number directly, or boolean for backward compatibility (false=16/MH, true=17/OH)
    local invslot
    if type(slotOrOffhand) == "number" then
        invslot = slotOrOffhand
    else
        invslot = slotOrOffhand and 17 or 16
    end
    local API = CleveRoids.NampowerAPI

    -- v2.18+: Use native fast lookup for item ID or name
    -- Guard against API being a function instead of table (addon conflict protection)
    if type(API) == "table" and type(API.features) == "table" and API.features.hasFindPlayerItemSlot then
        local searchTerm = msg
        local itemId = tonumber(msg)

        if CleveRoids.equipDebugLog then
            CleveRoids.Print("|cff888888[EquipLog] Searching for '" .. tostring(searchTerm) .. "' (slot " .. invslot .. ")|r")
        end

        -- Check if already equipped in target slot
        if API.IsItemInSlot(searchTerm, invslot) then
            if CleveRoids.equipDebugLog then
                CleveRoids.Print("|cff00ff00[EquipLog] '" .. tostring(searchTerm) .. "' already in slot " .. invslot .. "|r")
            end
            return true
        end

        -- Find the item (works with both ID and name)
        local itemInfo = API.FindItemFast(searchTerm)
        if CleveRoids.equipDebugLog then
            if itemInfo then
                CleveRoids.Print("|cff888888[EquipLog] FindItemFast found: invID=" .. tostring(itemInfo.inventoryID) .. " bag=" .. tostring(itemInfo.bagID) .. " slot=" .. tostring(itemInfo.slot) .. "|r")
            else
                CleveRoids.Print("|cffff8800[EquipLog] FindItemFast returned nil|r")
            end
        end
        if itemInfo then
            -- Already equipped in different slot - need to swap
            if itemInfo.inventoryID then
                if itemInfo.inventoryID == invslot then
                    return true  -- Already in correct slot
                end
                -- Pick up from current slot and equip to target
                ClearCursor()
                PickupInventoryItem(itemInfo.inventoryID)
                if CursorHasItem and CursorHasItem() then
                    EquipCursorItem(invslot)
                    ClearCursor()
                    return true
                end
            elseif itemInfo.bagID and itemInfo.slot then
                -- In bag - equip to target slot
                ClearCursor()
                PickupContainerItem(itemInfo.bagID, itemInfo.slot)
                if CursorHasItem and CursorHasItem() then
                    EquipCursorItem(invslot)
                    ClearCursor()
                    if CleveRoids.equipDebugLog then
                        CleveRoids.Print("|cff00ff00[EquipLog] Equipped '" .. tostring(msg) .. "' from bag " .. itemInfo.bagID .. " slot " .. itemInfo.slot .. "|r")
                    end
                    return true
                end
            end
        end

        -- Item not found via v2.18 lookup
        if CleveRoids.equipDebugLog then
            CleveRoids.Print("|cffff8800[EquipLog] Item '" .. tostring(msg) .. "' not found via v2.18 FindPlayerItemSlot|r")
            -- Debug: Try direct FindPlayerItemSlot call
            if FindPlayerItemSlot then
                local bag, slot = FindPlayerItemSlot(msg)
                CleveRoids.Print("|cff888888[EquipLog] Direct FindPlayerItemSlot('" .. msg .. "') = bag:" .. tostring(bag) .. " slot:" .. tostring(slot) .. "|r")
            end
        end
        return false
    end

    -- Fallback for older Nampower versions
    -- Try to interpret as item ID (numbers > 19)
    local itemId = tonumber(msg)
    if itemId and itemId > 19 then
        local itemName = nil
        if API and API.GetItemName then
            itemName = API.GetItemName(itemId)
        end
        if not itemName and GetItemInfo then
            itemName = GetItemInfo(itemId)
        end
        if itemName then
            msg = itemName
        else
            if CleveRoids.equipDebugLog then
                CleveRoids.Print("|cffff8800[EquipLog] Can't resolve item ID " .. tostring(itemId) .. "|r")
            end
            return false  -- Can't resolve item ID
        end
    end

    -- PERFORMANCE: Fast check if already equipped (single function call)
    if CleveRoids.IsItemEquipped and CleveRoids.IsItemEquipped(msg, invslot) then
        return true
    end

    -- Note what's currently in the target slot so we can invalidate its cache
    local oldSlotLink = GetInventoryItemLink("player", invslot)
    local oldSlotName = nil
    if oldSlotLink then
        local _, _, name = string_find(oldSlotLink, "|h%[(.-)%]|h")
        oldSlotName = name
    end

    -- Helper to invalidate displaced item's cache
    local function InvalidateDisplacedItem()
        if oldSlotName and CleveRoids.Items then
            CleveRoids.Items[oldSlotName] = nil
            CleveRoids.Items[string_lower(oldSlotName)] = nil
        end
    end

    -- Check if item is already equipped in the paired slot (swap case)
    -- EquipItemByName doesn't handle swapping equipped items, so we must do it manually
    -- Paired slots: trinkets (13<->14), weapons (16<->17), rings (11<->12)
    local pairedSlots = {[13] = 14, [14] = 13, [16] = 17, [17] = 16, [11] = 12, [12] = 11}
    local checkSlot = pairedSlots[invslot]
    if checkSlot then
        local link = GetInventoryItemLink("player", checkSlot)
        if link then
            local _, _, slotItemName = string_find(link, "|h%[(.-)%]|h")
            if slotItemName and string_lower(slotItemName) == string_lower(msg) then
                -- Found item in paired slot - swap it manually
                if CleveRoids.equipDebugLog then
                    CleveRoids.Print("|cff00ffff[EquipLog] Swapping from slot " .. checkSlot .. " to slot " .. invslot .. "|r")
                end
                ClearCursor()
                PickupInventoryItem(checkSlot)
                if CursorHasItem and CursorHasItem() then
                    EquipCursorItem(invslot)
                    ClearCursor()
                    if CleveRoids.Items then
                        CleveRoids.Items[msg] = nil
                        CleveRoids.Items[string_lower(msg)] = nil
                    end
                    InvalidateDisplacedItem()
                    return true
                end
                ClearCursor()
            end
        end
    end

    -- PERFORMANCE: Try EquipItemByName for bag items (fast path)
    -- This is the fastest path - no item lookup, no cursor operations
    if EquipItemByName then
        local ok = pcall(EquipItemByName, msg, invslot)
        if ok then
            -- Invalidate cache entry if it exists
            if CleveRoids.Items then
                CleveRoids.Items[msg] = nil
                CleveRoids.Items[string_lower(msg)] = nil
            end
            InvalidateDisplacedItem()
            return true
        end
    end

    -- PERFORMANCE: Use fast lookup first, fall back to full scan
    -- Full scan is now optimized with GetNameFromLink() instead of GetItemInfo()
    local item = CleveRoids.GetItemFast and CleveRoids.GetItemFast(msg)
    if not item then
        -- Try quick targeted scan (stops when found)
        item = CleveRoids.FindItemQuick and CleveRoids.FindItemQuick(msg)
    end
    if not item then
        -- Full scan fallback (now optimized, safe during combat)
        item = CleveRoids.GetItem(msg)
    end

    if not item or not item.name then
        if CleveRoids.equipDebugLog then
            CleveRoids.Print("|cffff8800[EquipLog] Item '" .. tostring(msg) .. "' not found in bags or equipped|r")
        end
        return false
    end

    -- Already equipped check (by item ID from lookup)
    if item.inventoryID == invslot then
        return true
    end

    if not item.bagID and not item.inventoryID then
        return false
    end

    -- Try EquipItemByName with resolved name (in case msg was partial/different case)
    if item.name and EquipItemByName and item.name ~= msg then
        local ok = pcall(EquipItemByName, item.name, invslot)
        if ok then
            if CleveRoids.Items then
                CleveRoids.Items[item.name] = nil
                CleveRoids.Items[string_lower(item.name)] = nil
            end
            InvalidateDisplacedItem()
            return true
        end
    end

    -- Fallback: Manual pickup and equip
    CleveRoids.equipInProgress = true

    -- PERFORMANCE: Single cursor check at start
    if CursorHasItem and CursorHasItem() then
        ClearCursor()
    end

    local pickupSuccess = false
    if item.bagID and item.slot then
        PickupContainerItem(item.bagID, item.slot)
        pickupSuccess = CursorHasItem and CursorHasItem()
    elseif item.inventoryID then
        PickupInventoryItem(item.inventoryID)
        pickupSuccess = CursorHasItem and CursorHasItem()
    end

    if not pickupSuccess then
        ClearCursor()
        CleveRoids.equipInProgress = false
        return false
    end

    EquipCursorItem(invslot)
    ClearCursor()

    if CleveRoids.Items and item.name then
        CleveRoids.Items[item.name] = nil
        CleveRoids.Items[string_lower(item.name)] = nil
    end
    InvalidateDisplacedItem()
    CleveRoids.equipInProgress = false
    return true
end

-- PERFORMANCE: Module-level actions to avoid closure allocation per call
local function _equipMainhandAction(msg)
    return CleveRoids.EquipBagItem(msg, false)
end

local function _equipOffhandAction(msg)
    return CleveRoids.EquipBagItem(msg, true)
end

local function _equipTrinket1Action(msg)
    return CleveRoids.EquipBagItem(msg, 13)
end

local function _equipTrinket2Action(msg)
    return CleveRoids.EquipBagItem(msg, 14)
end

local function _equipRing1Action(msg)
    return CleveRoids.EquipBagItem(msg, 11)
end

local function _equipRing2Action(msg)
    return CleveRoids.EquipBagItem(msg, 12)
end

local function _unshiftAction()
    local currentShapeshiftIndex = CleveRoids.GetCurrentShapeshiftIndex()
    if currentShapeshiftIndex ~= 0 then
        CastShapeshiftForm(currentShapeshiftIndex)
    end
end

function CleveRoids.DoEquipMainhand(msg)
    -- PERFORMANCE: Use numeric iteration to avoid pairs() iterator allocation
    local parts = CleveRoids.splitStringIgnoringQuotes(msg)
    for i = 1, table.getn(parts) do
        local v = string.gsub(parts[i], "^%?", "")
        if CleveRoids.DoWithConditionals(v, _equipMainhandAction, CleveRoids.FixEmptyTarget, false, _equipMainhandAction) then
            return true
        end
    end
    return false
end

function CleveRoids.DoEquipOffhand(msg)
    -- PERFORMANCE: Use numeric iteration to avoid pairs() iterator allocation
    local parts = CleveRoids.splitStringIgnoringQuotes(msg)
    for i = 1, table.getn(parts) do
        local v = string.gsub(parts[i], "^%?", "")
        if CleveRoids.DoWithConditionals(v, _equipOffhandAction, CleveRoids.FixEmptyTarget, false, _equipOffhandAction) then
            return true
        end
    end
    return false
end

function CleveRoids.DoEquipTrinket1(msg)
    local parts = CleveRoids.splitStringIgnoringQuotes(msg)
    for i = 1, table.getn(parts) do
        local v = string.gsub(parts[i], "^%?", "")
        if CleveRoids.DoWithConditionals(v, _equipTrinket1Action, CleveRoids.FixEmptyTarget, false, _equipTrinket1Action) then
            return true
        end
    end
    return false
end

function CleveRoids.DoEquipTrinket2(msg)
    local parts = CleveRoids.splitStringIgnoringQuotes(msg)
    for i = 1, table.getn(parts) do
        local v = string.gsub(parts[i], "^%?", "")
        if CleveRoids.DoWithConditionals(v, _equipTrinket2Action, CleveRoids.FixEmptyTarget, false, _equipTrinket2Action) then
            return true
        end
    end
    return false
end

function CleveRoids.DoEquipRing1(msg)
    local parts = CleveRoids.splitStringIgnoringQuotes(msg)
    for i = 1, table.getn(parts) do
        local v = string.gsub(parts[i], "^%?", "")
        if CleveRoids.DoWithConditionals(v, _equipRing1Action, CleveRoids.FixEmptyTarget, false, _equipRing1Action) then
            return true
        end
    end
    return false
end

function CleveRoids.DoEquipRing2(msg)
    local parts = CleveRoids.splitStringIgnoringQuotes(msg)
    for i = 1, table.getn(parts) do
        local v = string.gsub(parts[i], "^%?", "")
        if CleveRoids.DoWithConditionals(v, _equipRing2Action, CleveRoids.FixEmptyTarget, false, _equipRing2Action) then
            return true
        end
    end
    return false
end

function CleveRoids.DoUnshift(msg)
    local handled
    -- PERFORMANCE: Use numeric iteration to avoid pairs() iterator allocation
    local parts = CleveRoids.splitStringIgnoringQuotes(msg)
    for i = 1, table.getn(parts) do
        handled = false
        if CleveRoids.DoWithConditionals(parts[i], _unshiftAction, CleveRoids.FixEmptyTarget, false, _unshiftAction) then
            handled = true
            break
        end
    end

    if handled == nil then
        _unshiftAction()
    end

    return handled
end

function CleveRoids.DoRetarget()
    if GetUnitName("target") == nil
        or UnitHealth("target") == 0
        or not UnitCanAttack("player", "target")
    then
        ClearTarget()
        TargetNearestEnemy()
    end
end

-- Attempts to stop macro (stops ALL remaining lines including parent macros)
function CleveRoids.DoStopMacro(msg)
    -- PERFORMANCE: Use numeric iteration to avoid pairs() iterator allocation
    local parts = CleveRoids.splitStringIgnoringQuotes(CleveRoids.Trim(msg))
    for i = 1, table.getn(parts) do
        if CleveRoids.DoWithConditionals(parts[i], nil, nil, not CleveRoids.hasSuperwow, "STOPMACRO") then
            return true
        end
    end
    return false
end

-- Attempts to skip remaining lines in current submacro ONLY (returns to parent)
function CleveRoids.DoSkipMacro(msg)
    -- PERFORMANCE: Use numeric iteration to avoid pairs() iterator allocation
    local parts = CleveRoids.splitStringIgnoringQuotes(CleveRoids.Trim(msg))
    for i = 1, table.getn(parts) do
        if CleveRoids.DoWithConditionals(parts[i], nil, nil, not CleveRoids.hasSuperwow, "SKIPMACRO") then
            return true
        end
    end
    return false
end

-- Enables "stop on first successful cast" mode for the rest of the macro
-- When set, successful /cast or /use commands will set stopMacroFlag automatically
-- This allows priority-based macro evaluation: first matching cast wins
-- Example usage:
--   /firstaction
--   /cast [myrawpower:>48] Shred
--   /cast [myrawpower:>40] Claw
-- In this case, if Shred casts, Claw will NOT be queued
function CleveRoids.DoFirstAction(msg)
    -- Check if there are conditionals
    if msg and CleveRoids.Trim(msg) ~= "" then
        -- Has conditionals - use DoWithConditionals to evaluate them
        local parts = CleveRoids.splitStringIgnoringQuotes(CleveRoids.Trim(msg))
        for i = 1, table.getn(parts) do
            if CleveRoids.DoWithConditionals(parts[i], nil, nil, not CleveRoids.hasSuperwow, "FIRSTACTION") then
                return true
            end
        end
        return false
    else
        -- No conditionals - just set the flag
        CleveRoids.stopOnCastFlag = true
        return true
    end
end

-- Disables "stop on first successful cast" mode, re-enabling multi-queue behavior
-- Use this to restore normal evaluation after /firstaction
-- Example usage:
--   /firstaction
--   /cast [myrawpower:>48] Shred      -- Priority section
--   /cast [myrawpower:>40] Claw
--   /nofirstaction
--   /cast Tiger's Fury                -- Can queue alongside above
--   /startattack
function CleveRoids.DoNoFirstAction(msg)
    -- Check if there are conditionals
    if msg and CleveRoids.Trim(msg) ~= "" then
        -- Has conditionals - use DoWithConditionals to evaluate them
        local parts = CleveRoids.splitStringIgnoringQuotes(CleveRoids.Trim(msg))
        for i = 1, table.getn(parts) do
            if CleveRoids.DoWithConditionals(parts[i], nil, nil, not CleveRoids.hasSuperwow, "NOFIRSTACTION") then
                return true
            end
        end
        return false
    else
        -- No conditionals - just clear the flag
        CleveRoids.stopOnCastFlag = false
        return true
    end
end

function CleveRoids.DoCastSequence(sequence)
  if not CleveRoids.hasSuperwow then
    CleveRoids.Print("|cFFFF0000/castsequence|r requires |cFF00FFFFSuperWoW|r.")
    return
  end
  if type(sequence) == "string" then
    sequence = CleveRoids.GetSequence(sequence)
    if not sequence then return end
  end

  if CleveRoids.currentSequence and not CleveRoids.CheckSpellCast("player") then
    CleveRoids.currentSequence = nil
  elseif CleveRoids.currentSequence then
    return
  end

  -- If sequence is complete, don't execute - let macro continue to next line
  if sequence.complete then
    return
  end

  if sequence.index > 1 and sequence.reset then
    for k,_ in pairs(sequence.reset) do
      if CleveRoids.kmods[k] and CleveRoids.kmods[k]() then
        CleveRoids.ResetSequence(sequence)
        break
      end
    end
  end

  local active = CleveRoids.GetCurrentSequenceAction(sequence)
  if not (active and active.action) then return end

  sequence.status     = 0
  sequence.lastUpdate = GetTime()
  sequence.expires    = 0

  local prevSeq = CleveRoids.currentSequence
  CleveRoids.currentSequence = sequence

  local actionText = (sequence.cond or "") .. active.action
  local resolvedText, conds = CleveRoids.GetParsedMsg(actionText)

  -- Check if this is a macro execution {macroname}
  local macroName = CleveRoids.GetMacroNameFromAction(active.action)
  if macroName then
    -- Execute the macro
    local success = CleveRoids.ExecuteMacroByName(macroName)
    if not success then
      CleveRoids.currentSequence = prevSeq
    end
    return
  end

  local function cast_by_name(msg)
    msg = msg or ""
    -- Check specifically for "(Rank" to allow spells like "Faerie Fire (Feral)"
    -- to still get their rank appended automatically
    if not string.find(msg, "%(Rank") then
      local sp = CleveRoids.GetSpell(msg)
      local r  = (sp and sp.rank) or (sp and sp.highest and sp.highest.rank)
      if r and r ~= "" then msg = msg .. "(" .. r .. ")" end
    end
    -- Let Nampower DLL handle queuing natively via its CastSpellByName hook
    CastSpellByName(msg)
    return true
  end

  local attempted = false
  if not conds then
    attempted = cast_by_name(resolvedText or active.action)
  else
    local final = CleveRoids.DoWithConditionals(actionText, nil, CleveRoids.FixEmptyTarget, false, CastSpellByName)
    if final then attempted = cast_by_name(final) end
  end

  if not attempted then
    CleveRoids.currentSequence = prevSeq
  end
end

CleveRoids.DoConditionalCancelAura = function(msg)
  -- Check stopmacro flag
  if CleveRoids.stopMacroFlag then return false end

  local s = CleveRoids.Trim(msg or "")
  if s == "" then return false end

  -- No conditionals? cancel immediately.
  if not string.find(s, "%[") then
    return CleveRoids.CancelAura(s)
  end

  -- Has conditionals? Let the framework evaluate them, then run CancelAura.
  return CleveRoids.DoWithConditionals(s, nil, CleveRoids.FixEmptyTarget, false, CleveRoids.CancelAura) or false
end

-- PERFORMANCE: Separate periodic cleanup timer (runs every 5 seconds instead of every frame)
CleveRoids.lastCleanupTime = 0
CleveRoids.CLEANUP_INTERVAL = 5  -- Run cleanup every 5 seconds

-- PERFORMANCE: Upvalues for OnUpdate hot path
local GetTime = GetTime
local UnitAffectingCombat = UnitAffectingCombat
local pairs = pairs

function CleveRoids.OnUpdate(self)
    -- Clear macro stop flags at the start of each frame
    -- This ensures /stopmacro and /skipmacro only affect commands in the same frame (same macro execution)
    -- Without SuperMacro, this is necessary because we can't hook into macro line execution
    if CleveRoids.stopMacroFlag then
        CleveRoids.stopMacroFlag = false
    end
    if CleveRoids.skipMacroFlag then
        CleveRoids.skipMacroFlag = false
    end
    if CleveRoids.stopOnCastFlag then
        CleveRoids.stopOnCastFlag = false
    end

    -- PERFORMANCE: Single GetTime() call per frame
    local time = GetTime()

    -- PERFORMANCE: Early exit if not ready (before any other checks)
    if not CleveRoids.ready then
        -- Handle initialization timer only when not ready
        if CleveRoids.initializationTimer and time >= CleveRoids.initializationTimer then
            CleveRoids.IndexItems()
            CleveRoids.IndexActionBars()
            CleveRoids.ready = true
            CleveRoids.initializationTimer = nil
            CleveRoids.TestForAllActiveActions()
            CleveRoids.lastUpdate = time
        end
        return
    end

    -- PERFORMANCE: Delayed WDB warmup after login (ensures GetItemInfo works after WDB clear)
    if CleveRoids.wdbWarmupTime and time >= CleveRoids.wdbWarmupTime then
        CleveRoids.wdbWarmupTime = nil
        CleveRoids.DoWDBWarmup()
    end

    -- PERFORMANCE: Cache refresh rate calculation (avoid per-frame division)
    local refreshRate = CleveRoids.cachedRefreshRate
    if not refreshRate then
        refreshRate = 1 / (CleveRoidMacros.refresh or 5)
        CleveRoids.cachedRefreshRate = refreshRate
    end

    -- PERFORMANCE: Throttle check FIRST - skip most work on non-throttled frames
    local lastUpdate = CleveRoids.lastUpdate or 0
    local bypassThrottle = CleveRoids.isActionUpdateQueued and CleveRoidMacros.realtime == 0
    local shouldUpdate = bypassThrottle or (time - lastUpdate) >= refreshRate

    if not shouldUpdate then
        return  -- Early exit for non-throttled frames
    end

    CleveRoids.lastUpdate = time

    -- Process deferred equipment index updates (for throttled UNIT_INVENTORY_CHANGED)
    -- PERFORMANCE: Skip check entirely if no pending update
    local pendingTime = CleveRoids.equipIndexPendingTime
    if pendingTime and not UnitAffectingCombat("player") then
        if (time - (CleveRoids.lastEquipIndexTime or 0)) >= 0.2 then
            CleveRoids.lastEquipIndexTime = time
            CleveRoids.equipIndexPendingTime = nil
            CleveRoids.lastItemIndexTime = time
            CleveRoids.IndexItems()
            CleveRoids.Actions = {}
            CleveRoids.Macros = {}
            CleveRoids.IndexActionBars()

            if CleveRoidMacros.realtime == 0 then
                CleveRoids.QueueActionUpdate()
            end
        end
    end

    -- PERFORMANCE: Check for expired reactive procs only if we have any
    -- Use statically allocated removal buffer to avoid per-frame allocation
    local reactiveProcs = CleveRoids.reactiveProcs
    if reactiveProcs then
        local hasExpiredProc = false
        local toRemove = CleveRoids._procRemovalBuffer
        local removeCount = 0

        -- PERFORMANCE: Use next() directly instead of pairs() to avoid iterator allocation
        local spellName, procData = next(reactiveProcs)
        while spellName do
            if procData and procData.expiry and time >= procData.expiry then
                removeCount = removeCount + 1
                toRemove[removeCount] = spellName
                hasExpiredProc = true
            end
            spellName, procData = next(reactiveProcs, spellName)
        end

        -- Remove expired procs using indexed array (no pairs() overhead)
        for i = 1, removeCount do
            reactiveProcs[toRemove[i]] = nil
            toRemove[i] = nil  -- Clear for next use
        end

        -- If any proc expired, immediately update all actions
        if hasExpiredProc then
            CleveRoids.TestForAllActiveActions()
            CleveRoids.isActionUpdateQueued = false
        end
    end
    -- PERFORMANCE: Check for modifier key state changes (no events for these in vanilla WoW)
    -- Only queue update if modifier state actually changed - avoids full TestForAllActiveActions
    local altDown = IsAltKeyDown() and true or false
    local shiftDown = IsShiftKeyDown() and true or false
    local ctrlDown = IsControlKeyDown() and true or false

    if altDown ~= CleveRoids._lastAltDown or
       shiftDown ~= CleveRoids._lastShiftDown or
       ctrlDown ~= CleveRoids._lastCtrlDown then
        CleveRoids._lastAltDown = altDown
        CleveRoids._lastShiftDown = shiftDown
        CleveRoids._lastCtrlDown = ctrlDown
        -- Modifier changed - queue update in event-driven mode, or just mark for realtime
        if CleveRoidMacros.realtime == 0 then
            CleveRoids.isActionUpdateQueued = true
        end
    end

    -- Check the saved variable to decide which update mode to use.
    if CleveRoidMacros.realtime == 1 then
        -- Realtime Mode: Force an update on every throttled tick for maximum responsiveness.
        CleveRoids.TestForAllActiveActions()
    else
        -- Event-Driven Mode (Default): Only update if a relevant game event has queued it.
        if CleveRoids.isActionUpdateQueued then
            if CleveRoids.debug then
                DEFAULT_CHAT_FRAME:AddMessage("|cffff00ff[OnUpdate]|r Processing queued action update")
            end
            CleveRoids.TestForAllActiveActions()
            CleveRoids.isActionUpdateQueued = false -- Reset the flag after updating
            if CleveRoids.debug then
                DEFAULT_CHAT_FRAME:AddMessage("|cffff00ff[OnUpdate]|r Action update complete, flag reset")
            end
        end
    end

    -- The rest of this function handles time-based logic that must always run.
    if CleveRoids.CurrentSpell.autoAttackLock and (time - CleveRoids.autoAttackLockElapsed) > refreshRate then
        CleveRoids.CurrentSpell.autoAttackLock = false
        CleveRoids.autoAttackLockElapsed = nil
    end

    -- PERFORMANCE: Use next() directly instead of pairs() to avoid iterator allocation
    local Sequences = CleveRoids.Sequences
    local seqKey, sequence = next(Sequences)
    while seqKey do
        if sequence.index > 1 and sequence.reset.secs and (time - (sequence.lastUpdate or 0)) >= sequence.reset.secs then
            CleveRoids.ResetSequence(sequence)
        end
        seqKey, sequence = next(Sequences, seqKey)
    end

    -- PERFORMANCE: Use next() directly instead of pairs() to avoid iterator allocation
    local spell_tracking = CleveRoids.spell_tracking
    local guid, cast = next(spell_tracking)
    while guid do
        local nextGuid = next(spell_tracking, guid)  -- Get next before potential removal
        if cast.expires and time > cast.expires then
            spell_tracking[guid] = nil
        end
        guid, cast = nextGuid, nextGuid and spell_tracking[nextGuid]
    end

    -- PERFORMANCE OPTIMIZATION: Run memory cleanup less frequently (every 5 seconds instead of every frame)
    -- This reduces CPU usage while maintaining effective memory management
    if (time - CleveRoids.lastCleanupTime) >= CleveRoids.CLEANUP_INTERVAL then
        CleveRoids.lastCleanupTime = time

        -- MEMORY: Clean up carnageDurationOverrides older than 30 seconds
        -- PERFORMANCE: Use next() directly instead of pairs() to avoid iterator allocation
        local carnageOverrides = CleveRoids.carnageDurationOverrides
        if carnageOverrides then
            local spellID, data = next(carnageOverrides)
            while spellID do
                local nextID = next(carnageOverrides, spellID)
                if data.timestamp and (time - data.timestamp) > 30 then
                    carnageOverrides[spellID] = nil
                end
                spellID, data = nextID, nextID and carnageOverrides[nextID]
            end
        end

        -- MEMORY: Clean up old ComboPointTracking entries (older than 60 seconds)
        -- PERFORMANCE: Use next() directly instead of pairs() to avoid iterator allocation
        local comboTracking = CleveRoids.ComboPointTracking
        if comboTracking then
            local trackName, data = next(comboTracking)
            while trackName do
                local nextName = next(comboTracking, trackName)
                if data.cast_time and (time - data.cast_time) > 60 then
                    comboTracking[trackName] = nil
                end
                trackName, data = nextName, nextName and comboTracking[nextName]
            end
        end

        -- MEMORY: Clear spell name caches every 60 seconds (12 cleanup cycles)
        CleveRoids._spellCacheCleanupCounter = (CleveRoids._spellCacheCleanupCounter or 0) + 1
        if CleveRoids._spellCacheCleanupCounter >= 12 then
            CleveRoids._spellCacheCleanupCounter = 0
            if CleveRoids.ClearSpellNameCaches then
                CleveRoids.ClearSpellNameCaches()
            end
        end
    end
end

-- Initialize the nested table for the GameTooltip hooks if it doesn't exist
if not CleveRoids.Hooks.GameTooltip then CleveRoids.Hooks.GameTooltip = {} end

-- Save the original GameTooltip.SetAction function before we override it
CleveRoids.Hooks.GameTooltip.SetAction = GameTooltip.SetAction

-- Now, define our custom version of the function
function GameTooltip.SetAction(self, slot)
    local actions = CleveRoids.GetAction(slot)

    -- If this is our macro but has no active action, show just the macro name
    if actions and not actions.active then
        local macroName = GetActionText(slot)
        if macroName then
            GameTooltip:SetText(macroName)
            GameTooltip:Show()
            return
        end
    end

    local action_to_display_info = nil
    if actions then
        -- Only show spell/item tooltip when there's an active action
        if actions.active then
            action_to_display_info = actions.active
        end
    end

    if action_to_display_info and action_to_display_info.action then
        local action_name = action_to_display_info.action

        -- NEW: Check if action is a slot ID for tooltip
        local slotId = tonumber(action_name)
        if slotId and slotId >= 1 and slotId <= 19 then
            -- Use the more specific SetInventoryItem function to prevent conflicts with other addons.
            GameTooltip:SetInventoryItem("player", slotId)
            GameTooltip:Show()
            return
        end
        -- End new logic

        local current_spell_data = CleveRoids.GetSpell(action_name)
        if current_spell_data then
            GameTooltip:SetSpell(current_spell_data.spellSlot, current_spell_data.bookType)
            local rank_info = current_spell_data.rank or (current_spell_data.highest and current_spell_data.highest.rank)
            if rank_info and rank_info ~= "" then
                GameTooltipTextRight1:SetText("|cff808080" .. rank_info .. "|r")
            else
                GameTooltipTextRight1:SetText("")
            end
            GameTooltipTextRight1:Show()
            GameTooltip:Show()
            return
        end

        local current_item_data = CleveRoids.GetItem(action_name)
        if current_item_data then
            -- Use specific functions based on where the item is located.
            if current_item_data.inventoryID then
                GameTooltip:SetInventoryItem("player", current_item_data.inventoryID)
            elseif current_item_data.bagID and current_item_data.slot then
                GameTooltip:SetBagItem(current_item_data.bagID, current_item_data.slot)
            else
                -- Fallback to the original method if location is unknown.
                GameTooltip:SetHyperlink(current_item_data.link)
            end
            GameTooltip:Show()
            return
        end

        if action_to_display_info.macro and type(action_to_display_info.macro) == "table" then
            local nested_action_info = action_to_display_info.macro
            local nested_action_name = nested_action_info.action

            current_spell_data = CleveRoids.GetSpell(nested_action_name)
            if current_spell_data then
                GameTooltip:SetSpell(current_spell_data.spellSlot, current_spell_data.bookType)
                local rank_info = current_spell_data.rank or (current_spell_data.highest and current_spell_data.highest.rank)
                if rank_info and rank_info ~= "" then
                    GameTooltipTextRight1:SetText("|cff808080" .. rank_info .. "|r")
                else
                    GameTooltipTextRight1:SetText("")
                end
                GameTooltipTextRight1:Show()
                GameTooltip:Show()
                return
            end

            current_item_data = CleveRoids.GetItem(nested_action_name)
            if current_item_data then
                 if current_item_data.inventoryID then
                    GameTooltip:SetInventoryItem("player", current_item_data.inventoryID)
                elseif current_item_data.bagID and current_item_data.slot then
                    GameTooltip:SetBagItem(current_item_data.bagID, current_item_data.slot)
                else
                    GameTooltip:SetHyperlink(current_item_data.link)
                end
                GameTooltip:Show()
                return
            end
        end
    end

    -- If none of our custom logic handled it, call the original function we saved earlier.
    CleveRoids.Hooks.GameTooltip.SetAction(self, slot)
end

CleveRoids.Hooks.PickupAction = PickupAction
function PickupAction(slot)
    if not slot then return end
    CleveRoids.ClearAction(slot)
    CleveRoids.ClearSlot(CleveRoids.actionSlots, slot)
    CleveRoids.ClearAction(CleveRoids.reactiveSlots, slot)
    return CleveRoids.Hooks.PickupAction(slot)
end

CleveRoids.Hooks.ActionHasRange = ActionHasRange
function ActionHasRange(slot)
    if not slot then return nil end
    local actions = CleveRoids.GetAction(slot)
    -- Only override for our macros with #showtooltip
    if actions and actions.tooltip and actions.active then
        if actions.active.inRange ~= -1 then
            return 1  -- Has range check with valid data
        else
            -- For channeled spells (inRange == -1), try proxy slot lookup
            local spellName = actions.active.spell and actions.active.spell.name
            local proxySlot = spellName and CleveRoids.GetProxyActionSlot(spellName)
            if proxySlot then
                return CleveRoids.Hooks.ActionHasRange(proxySlot)
            end
        end
    end
    -- Not a macro we're tracking - pass through to original
    return CleveRoids.Hooks.ActionHasRange(slot)
end

CleveRoids.Hooks.IsActionInRange = IsActionInRange
function IsActionInRange(slot, unit)
    if not slot then return nil end
    local actions = CleveRoids.GetAction(slot)
    -- Only override for our macros with #showtooltip
    if actions and actions.tooltip and actions.active and actions.active.type == "spell" then
        if actions.active.inRange ~= -1 then
            return actions.active.inRange
        else
            -- For channeled spells (inRange == -1), try proxy slot lookup
            local spellName = actions.active.spell and actions.active.spell.name
            local proxySlot = spellName and CleveRoids.GetProxyActionSlot(spellName)
            if proxySlot then
                return CleveRoids.Hooks.IsActionInRange(proxySlot, unit)
            end
        end
    end
    -- Not a macro we're tracking - pass through to original
    return CleveRoids.Hooks.IsActionInRange(slot, unit)
end

CleveRoids.Hooks.OriginalIsUsableAction = IsUsableAction
CleveRoids.Hooks.IsUsableAction = IsUsableAction
function IsUsableAction(slot, unit)
    if not slot then return nil, nil end
    local actions = CleveRoids.GetAction(slot)

    -- If this is one of our macros AND it uses #showtooltip
    if actions and actions.tooltip then
        -- IMPORTANT: Only override usability when #showtooltip is present
        -- Macros without #showtooltip should use default game behavior
        if actions.active then
            -- We have an active action - return its usable state
            return actions.active.usable, actions.active.oom
        else
            -- This is our macro but no action is active (all conditionals failed)
            -- Return nil to make the icon dark
            return nil, nil
        end
    else
        -- Not our macro OR no #showtooltip - use game's default behavior
        return CleveRoids.Hooks.IsUsableAction(slot, unit)
    end
end

CleveRoids.Hooks.IsCurrentAction = IsCurrentAction
function IsCurrentAction(slot)
    if not slot then return nil end
    local actions = CleveRoids.GetAction(slot)

    -- Use the same priority as GetActionTexture: active first, then tooltip
    local actionToCheck = (actions and actions.active) or (actions and actions.tooltip)

    if not actionToCheck then
        return CleveRoids.Hooks.IsCurrentAction(slot)
    else
        local name
        if actionToCheck.spell then
            local rank = actionToCheck.spell.rank or actionToCheck.spell.highest.rank
            name = actionToCheck.spell.name..(rank and ("("..rank..")"))

            -- Check if this spell is currently queued or being cast via Nampower
            -- Get spell ID for comparison
            local spellId = actionToCheck.spell.id
            if not spellId and GetSpellIdForName then
                spellId = GetSpellIdForName(name)
            end

            if spellId then
                -- Prefer GetCastInfo (Nampower 2.18+) for cleaner API
                if GetCastInfo then
                    local ok, info = pcall(GetCastInfo)
                    if ok and info and info.spellId == spellId then
                        -- Spell is actively being cast/channeled
                        return true
                    end
                end

                -- Also check GetCurrentCastingInfo for queued spell detection
                if GetCurrentCastingInfo then
                    local castId, visId, autoId, casting, channeling = GetCurrentCastingInfo()

                    -- Show glow if actively casting/channeling this spell
                    if (casting == 1 and castId == spellId) or (channeling == 1 and visId == spellId) then
                        return true
                    end
                    -- Show glow if this spell is queued (castId set but not yet casting)
                    if casting == 0 and channeling == 0 and castId == spellId then
                        return true
                    end
                end
            end
        elseif actionToCheck.item then
            name = actionToCheck.item.name
        end

        return CleveRoids.Hooks.IsCurrentAction(CleveRoids.GetProxyActionSlot(name) or slot)
    end
end

CleveRoids.Hooks.GetActionTexture = GetActionTexture
function GetActionTexture(slot)
    if not slot then return nil end
    local actions = CleveRoids.GetAction(slot)

    -- Check if this is one of our macros
    if actions and (actions.active or actions.tooltip) then

        -- This block handles the case where all conditionals fail and no explicit
        -- #showtooltip was set. It defaults to the macro's chosen icon.
        if not actions.active and not actions.explicitTooltip and actions.list and table.getn(actions.list) > 0 then
            -- Get the macro's own icon as fallback
            local macroTexture = nil
            local macroName = GetActionText(slot)
            if macroName then
                local macroID = GetMacroIndexByName(macroName)
                if macroID and macroID > 0 then
                    local _, texture = GetMacroInfo(macroID)
                    macroTexture = texture
                end
            end

            -- When no conditionals pass, use macro icon (not first action's icon)
            -- The actions.tooltip is just the first action which didn't pass conditionals
            if macroTexture then
                return macroTexture
            end

            -- Should never reach here, but return unknown as last resort
            return CleveRoids.unknownTexture
        end

        -- Prioritize active action, fall back to tooltip
        local a = actions.active or actions.tooltip

        -- Handle numeric slot actions (e.g., /use 13)
        local slotId = tonumber(a.action)
        if slotId and slotId >= 1 and slotId <= 19 then
            local currentTexture = GetInventoryItemTexture("player", slotId)
            if currentTexture then
                return currentTexture
            end

            -- Slot is empty, fall back to macro icon
            local macroName = GetActionText(slot)
            if macroName then
                local macroID = GetMacroIndexByName(macroName)
                if macroID and macroID > 0 then
                    local _, macroTexture = GetMacroInfo(macroID)
                    if macroTexture then
                        return macroTexture
                    end
                end
            end
            return CleveRoids.unknownTexture
        end

        -- *** THIS IS THE FIX ***
        -- If an action is active, return its texture directly.
        -- If no action is active, return the tooltip's texture.
        -- If neither has a texture, fall back to the macro's icon.
        local texture = (actions.active and actions.active.texture) or (actions.tooltip and actions.tooltip.texture)

        -- Check if this is a shapeshift form spell and use active texture if toggled on
        if a and a.spell and a.action then
            -- Strip rank info and underscores from spell name for comparison
            local spellName = string.gsub(a.action, "%s*%(.-%)%s*$", "")
            spellName = string.gsub(spellName, "_", " ")
            -- Check all shapeshift forms to see if this spell matches and is active
            for i = 1, GetNumShapeshiftForms() do
                local icon, name, isActive, isCastable = GetShapeshiftFormInfo(i)
                if name and string.lower(name) == string.lower(spellName) and isActive and icon then
                    texture = icon
                    break
                end
            end
        end

        -- Check if this is a toggled buff ability (Prowl, Shadowmeld) and swap icon based on buff state
        -- Note: Stealth is handled above by shapeshift form logic
        if a and a.spell and a.action then
            local spellName = string.gsub(a.action, "%s*%(.-%)%s*$", "")
            spellName = string.gsub(spellName, "_", " ")

            -- Check if this is one of our toggled buff abilities (not shapeshift forms)
            local toggledAbilities = {
                [CleveRoids.Localized.Spells["Prowl"]] = true,
                [CleveRoids.Localized.Spells["Shadowmeld"]] = true,
            }

            if toggledAbilities[spellName] then
                -- Check if the buff is active
                if CleveRoids.ValidatePlayerBuff(spellName) then
                    -- Buff is active, use the active texture from auraTextures
                    local activeTexture = CleveRoids.auraTextures[spellName]
                    if activeTexture then
                        texture = activeTexture
                    end
                end
            end
        end

        if texture then
            return texture
        end

        -- Final fallback: get the macro's icon
        local macroName = GetActionText(slot)
        if macroName then
            local macroID = GetMacroIndexByName(macroName)
            if macroID and macroID > 0 then
                local _, macroTexture = GetMacroInfo(macroID)
                if macroTexture then
                    return macroTexture
                end
            end
        end

        -- Should never reach here
        return CleveRoids.unknownTexture

    end

    -- Not one of our macros, use the original function
    return CleveRoids.Hooks.GetActionTexture(slot)
end

-- TODO: Look into https://github.com/Stanzilla/WoWUIBugs/issues/47 if needed
CleveRoids.Hooks.GetActionCooldown = GetActionCooldown
function GetActionCooldown(slot)
    -- Guard against nil/invalid slot
    if not slot then return 0, 0, 0 end

    local actions = CleveRoids.GetAction(slot)
    -- Check for actions.active OR actions.tooltip
    if actions and (actions.active or actions.tooltip) then
        -- Prioritize the active action, but fall back to the tooltip action
        local a = actions.active or actions.tooltip

        local slotId = tonumber(a.action)
        if slotId and slotId >= 1 and slotId <= 19 then
            return GetInventoryItemCooldown("player", slotId)
        end

        if a.spell then
            return GetSpellCooldown(a.spell.spellSlot, a.spell.bookType)
        elseif a.item then
            if a.item.bagID and a.item.slot then
                return GetContainerItemCooldown(a.item.bagID, a.item.slot)
            elseif a.item.inventoryID then
                return GetInventoryItemCooldown("player", a.item.inventoryID)
            end
        end
        return 0, 0, 0
    else
        return CleveRoids.Hooks.GetActionCooldown(slot)
    end
end

CleveRoids.Hooks.GetActionCount = GetActionCount
function GetActionCount(slot)
    -- Guard against nil/invalid slot
    if not slot then return 0 end

    local action = CleveRoids.GetAction(slot)
    local count
    -- Use the same priority as GetActionTexture: active first, then tooltip
    local actionToCheck = (action and action.active) or (action and action.tooltip)
    if actionToCheck then

        local slotId = tonumber(actionToCheck.action)
        if slotId and slotId >= 1 and slotId <= 19 then
            return GetInventoryItemCount("player", slotId)
        end

        if actionToCheck.item then
            count = actionToCheck.item.count

        elseif actionToCheck.spell then
            local reagent = actionToCheck.spell.reagent
            if not reagent then
                local ss, bt = actionToCheck.spell.spellSlot, actionToCheck.spell.bookType
                if ss and bt then
                    local _, r = CleveRoids.GetSpellCost(ss, bt)
                    reagent = r
                end
                if (not reagent) and _ReagentBySpell and actionToCheck.spell.name then
                    reagent = _ReagentBySpell[actionToCheck.spell.name]  -- e.g., Vanish → Flash Powder
                end
                actionToCheck.spell.reagent = reagent  -- cache it so we don't re-scan every frame
            end
            if reagent then
                count = CleveRoids.GetReagentCount(reagent)  -- id-first bag scan, falls back to name/tooltip
            end
        end
    end

    return count or CleveRoids.Hooks.GetActionCount(slot)
end

CleveRoids.Hooks.IsConsumableAction = IsConsumableAction
function IsConsumableAction(slot)
    -- Guard against nil/invalid slot
    if not slot then return nil end

    local action = CleveRoids.GetAction(slot)
    -- Use the same priority as GetActionTexture: active first, then tooltip
    local actionToCheck = (action and action.active) or (action and action.tooltip)
    if actionToCheck then

        local slotId = tonumber(actionToCheck.action)
        if slotId and slotId >= 1 and slotId <= 19 then
            local _, count = GetInventoryItemCount("player", slotId)
            if count and count > 0 then return 1 end
        end

        if actionToCheck.item and
            (CleveRoids.countedItemTypes[actionToCheck.item.type]
            or CleveRoids.countedItemTypes[actionToCheck.item.name])
        then
            return 1
        end


        if actionToCheck.spell and actionToCheck.spell.reagent then
            return 1
        end
    end

    return CleveRoids.Hooks.IsConsumableAction(slot)
end

-- ============================================================================
-- RunMacro Hook - Use our own macro execution system
-- ============================================================================
-- This allows /stopmacro, /skipmacro, /firstaction to work across parent/child
-- macro boundaries without requiring SuperMacro addon.
--
-- When SuperMacro is installed, its RunLine hook takes precedence for extended
-- macro features. This hook handles vanilla Blizzard macros.
-- ============================================================================
if not CleveRoids.RunMacroHooked then
    CleveRoids.Hooks.RunMacro = RunMacro

    function RunMacro(indexOrName)
        -- Skip if SuperMacro is handling macro execution (it has its own hooks)
        if CleveRoids.SM_RunLineHooked then
            return CleveRoids.Hooks.RunMacro(indexOrName)
        end

        -- Resolve macro index
        local macroIndex
        if type(indexOrName) == "number" then
            macroIndex = indexOrName
        elseif type(indexOrName) == "string" then
            -- Could be a name or a numeric string
            local num = tonumber(indexOrName)
            if num then
                macroIndex = num
            else
                macroIndex = GetMacroIndexByName(indexOrName)
            end
        end

        if not macroIndex or macroIndex == 0 then
            -- Fallback to original if we can't resolve
            return CleveRoids.Hooks.RunMacro(indexOrName)
        end

        -- Get macro body
        local name, icon, body = GetMacroInfo(macroIndex)
        if not body or body == "" then
            return CleveRoids.Hooks.RunMacro(indexOrName)
        end

        -- Clear macro flags at the start of top-level macro execution
        CleveRoids.stopMacroFlag = false
        CleveRoids.skipMacroFlag = false
        -- Note: stopOnCastFlag is intentionally NOT cleared here - it persists
        -- within a frame and is cleared by OnUpdate

        if CleveRoids.macroRefDebug then
            CleveRoids.Print("|cff00ff00[RunMacro Hook]|r Executing macro '" .. (name or macroIndex) .. "' via CleveRoids")
        end

        -- Execute through our system
        CleveRoids.ExecuteMacroBody(body)

        -- Don't call original - we've handled it
        return
    end

    CleveRoids.RunMacroHooked = true
end

-- Create a hidden tooltip frame to read buff names
if not AuraScanTooltip and not CleveRoids.hasSuperwow then
    CreateFrame("GameTooltip", "AuraScanTooltip")
    AuraScanTooltip:SetOwner(WorldFrame, "ANCHORNONE")
    AuraScanTooltip:AddFontStrings(
        AuraScanTooltip:CreateFontString("$parentTextLeft1", nil, "GameTooltipText"),
        AuraScanTooltip:CreateFontString("$parentTextRight1", nil, "GameTooltipText")
    )
end

-- Robust named tooltip for scanning spells/items
if not CleveRoidsTooltipScan then
  -- Try to create with the standard template first
  local ok, _ = pcall(CreateFrame, "GameTooltip", "CleveRoidsTooltipScan", UIParent, "GameTooltipTemplate")
  if not ok or not CleveRoidsTooltipScan then
    -- Fallback: manual tooltip with plenty of prebuilt lines
    CleveRoidsTooltipScan = CreateFrame("GameTooltip", "CleveRoidsTooltipScan", UIParent)
    local L1 = CleveRoidsTooltipScan:CreateFontString("$parentTextLeft1",  nil, "GameTooltipText")
    local R1 = CleveRoidsTooltipScan:CreateFontString("$parentTextRight1", nil, "GameTooltipText")
    CleveRoidsTooltipScan:AddFontStrings(L1, R1)
    for i = 2, 32 do
      CleveRoidsTooltipScan:CreateFontString("$parentTextLeft"..i,  nil, "GameTooltipText")
      CleveRoidsTooltipScan:CreateFontString("$parentTextRight"..i, nil, "GameTooltipText")
    end
  end
  CleveRoidsTooltipScan:SetOwner(WorldFrame, "ANCHOR_NONE")
end

-- This single dummy frame handles events AND serves as our tooltip scanner.
CleveRoids.Frame = CreateFrame("GameTooltip")

-- Create the extra font strings needed for other functions like GetSpellCost.
CleveRoids.Frame.costFontString = CleveRoids.Frame:CreateFontString()
CleveRoids.Frame.rangeFontString = CleveRoids.Frame:CreateFontString()
CleveRoids.Frame.reagentFontString = CleveRoids.Frame:CreateFontString()
CleveRoids.Frame:AddFontStrings(CleveRoids.Frame:CreateFontString(), CleveRoids.Frame:CreateFontString())
CleveRoids.Frame:AddFontStrings(CleveRoids.Frame.costFontString, CleveRoids.Frame.rangeFontString)
CleveRoids.Frame:AddFontStrings(CleveRoids.Frame:CreateFontString(), CleveRoids.Frame:CreateFontString())
CleveRoids.Frame:AddFontStrings(CleveRoids.Frame.reagentFontString, CleveRoids.Frame:CreateFontString())

CleveRoids.Frame:SetScript("OnUpdate", CleveRoids.OnUpdate)
CleveRoids.Frame:SetScript("OnEvent", function(...)
    CleveRoids.Frame[event](this,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10)
end)

-- == CORE EVENT REGISTRATION ==
CleveRoids.Frame:RegisterEvent("PLAYER_LOGIN")
CleveRoids.Frame:RegisterEvent("ADDON_LOADED")
CleveRoids.Frame:RegisterEvent("UPDATE_MACROS")
CleveRoids.Frame:RegisterEvent("SPELLS_CHANGED")
CleveRoids.Frame:RegisterEvent("ACTIONBAR_SLOT_CHANGED")
CleveRoids.Frame:RegisterEvent("BAG_UPDATE")
CleveRoids.Frame:RegisterEvent("UNIT_INVENTORY_CHANGED")
CleveRoids.Frame:RegisterEvent("UNIT_PET")

-- == STATE CHANGE EVENT REGISTRATION (for performance) ==
CleveRoids.Frame:RegisterEvent("PLAYER_TARGET_CHANGED")
CleveRoids.Frame:RegisterEvent("PLAYER_FOCUS_CHANGED") -- For focus addons
CleveRoids.Frame:RegisterEvent("PLAYER_ENTER_COMBAT")  -- Auto-attack started
CleveRoids.Frame:RegisterEvent("PLAYER_LEAVE_COMBAT")  -- Auto-attack stopped
CleveRoids.Frame:RegisterEvent("PLAYER_REGEN_DISABLED") -- Entered actual combat (has threat)
CleveRoids.Frame:RegisterEvent("PLAYER_REGEN_ENABLED")  -- Left actual combat (no threat)
CleveRoids.Frame:RegisterEvent("UPDATE_SHAPESHIFT_FORM")
CleveRoids.Frame:RegisterEvent("SPELL_UPDATE_COOLDOWN")
CleveRoids.Frame:RegisterEvent("UNIT_AURA")
CleveRoids.Frame:RegisterEvent("UNIT_HEALTH")
CleveRoids.Frame:RegisterEvent("UNIT_POWER")
if CleveRoids.hasSuperwow then
  CleveRoids.Frame:RegisterEvent("UNIT_CASTEVENT")
end
if QueueSpellByName then
    CleveRoids.Frame:RegisterEvent("SPELL_QUEUE_EVENT")
    CleveRoids.Frame:RegisterEvent("SPELL_CAST_EVENT")
end
CleveRoids.Frame:RegisterEvent("START_AUTOREPEAT_SPELL")
CleveRoids.Frame:RegisterEvent("STOP_AUTOREPEAT_SPELL")
CleveRoids.Frame:RegisterEvent("SPELLCAST_CHANNEL_START")
CleveRoids.Frame:RegisterEvent("SPELLCAST_CHANNEL_STOP")
CleveRoids.Frame:RegisterEvent("SPELLCAST_START")
CleveRoids.Frame:RegisterEvent("SPELLCAST_STOP")
CleveRoids.Frame:RegisterEvent("SPELLCAST_FAILED")
CleveRoids.Frame:RegisterEvent("SPELLCAST_INTERRUPTED")

-- Nampower SPELL_CAST_EVENT for reliable channel tracking
if GetCurrentCastingInfo then
    CleveRoids.Frame:RegisterEvent("SPELL_CAST_EVENT")
end


-- NOTE: SuperMacro hook installation is handled by Compatibility/SuperMacro.lua
-- which has the complete implementation including the INTERCEPT path for all commands

function CleveRoids.Frame:UNIT_PET()
    if arg1 == "player" then
        CleveRoids.IndexPetSpells()
        if CleveRoidMacros.realtime == 0 then
            CleveRoids.QueueActionUpdate()
        end
    end
end

-- Simplified PLAYER_LOGIN - requirements already checked
function CleveRoids.Frame:PLAYER_LOGIN()
    -- Skip if already disabled
    if CleveRoids.disabled then return end

    _, CleveRoids.playerClass = UnitClass("player")
    _, CleveRoids.playerGuid = UnitExists("player")
    CleveRoids.IndexSpells()
    CleveRoids.IndexPetSpells()
    CleveRoids.initializationTimer = GetTime() + 1.5

    -- PERFORMANCE: Initialize event-driven cache states
    CleveRoids._cachedPlayerInCombat = UnitAffectingCombat("player") and true or false

    -- Schedule delayed WDB warmup (loads items into client cache via tooltip scan)
    -- This ensures GetItemInfo() works for all inventory items after a WDB clear
    CleveRoids.wdbWarmupTime = GetTime() + 3.0  -- 3 second delay after login
end

-- PERFORMANCE: WDB warmup - tooltip scan all bag items to ensure they're cached
-- This prevents GetItemInfo() returning nil for items after a WDB clear
function CleveRoids.DoWDBWarmup()
    if CleveRoids.wdbWarmupDone then return end
    CleveRoids.wdbWarmupDone = true

    -- Create a hidden tooltip for scanning if it doesn't exist
    local tip = CleveRoidsWDBTip
    if not tip then
        tip = CreateFrame("GameTooltip", "CleveRoidsWDBTip", UIParent, "GameTooltipTemplate")
        tip:SetOwner(WorldFrame, "ANCHOR_NONE")
    end

    local scanned = 0

    -- Scan all bag slots
    for bag = 0, 4 do
        local slots = GetContainerNumSlots(bag) or 0
        for slot = 1, slots do
            local link = GetContainerItemLink(bag, slot)
            if link then
                -- Tooltip scan loads the item into WDB
                tip:ClearLines()
                tip:SetBagItem(bag, slot)
                scanned = scanned + 1
            end
        end
    end

    -- Scan equipped items
    for slot = 0, 19 do
        local link = GetInventoryItemLink("player", slot)
        if link then
            tip:ClearLines()
            tip:SetInventoryItem("player", slot)
            scanned = scanned + 1
        end
    end

    -- Now trigger a full item index to populate the cache with valid data
    if CleveRoids.IndexItems then
        CleveRoids.IndexItems()
    end

    if CleveRoids.debug then
        CleveRoids.Print("|cff88ff88[WDB Warmup]|r Scanned " .. scanned .. " items into cache")
    end
end

function CleveRoids.Frame:ADDON_LOADED(addon)
    -- keep your existing init for CRM:
    if addon == "CleveRoidMacros" or addon == "SuperCleveRoidMacros" then
        CleveRoids.InitializeExtensions()
    end
    -- NOTE: SuperMacro hook installation is handled by Compatibility/SuperMacro.lua
end

function CleveRoids.Frame:UNIT_CASTEVENT(caster,target,action,spell_id,cast_time)
    -- Handle melee swings for judgement refresh
    if action == "MAINHAND" or action == "OFFHAND" then
        -- Only process if this is the player's melee swing
        if caster == CleveRoids.playerGuid and CleveRoids.playerClass == "PALADIN" then
            -- Refresh judgements on the target
            -- Defensive: verify libdebuff is a table before accessing properties
            local lib = type(CleveRoids.libdebuff) == "table" and CleveRoids.libdebuff or nil
            if target and lib and lib.objects then
                local normalizedTarget = CleveRoids.NormalizeGUID(target)
                if normalizedTarget and lib.objects[normalizedTarget] then
                    -- Refresh all active Judgements on the target (pfUI-style: by name, not just ID)
                    for spellID, rec in pairs(lib.objects[normalizedTarget]) do
                        if rec.start and rec.duration then
                            local spellName = SpellInfo(spellID)
                            if spellName then
                                -- Remove rank to get base name
                                local baseName = string.gsub(spellName, "%s*%(Rank %d+%)", "")

                                -- Check if this is a judgement by name (pfUI approach)
                                if lib.judgementNames and lib.judgementNames[baseName] then
                                    -- Only refresh if the Judgement is still active and was cast by player
                                    local remaining = rec.duration + rec.start - GetTime()
                                    if remaining > 0 and rec.caster == "player" then
                                        -- Refresh the Judgement by updating the start time
                                        rec.start = GetTime()

                                        if CleveRoids.debug then
                                            DEFAULT_CHAT_FRAME:AddMessage(
                                                string.format("|cff00ffaa[Judgement Refresh]|r Refreshed %s (ID:%d) on %s hit - new duration: %ds",
                                                    baseName, spellID, action, rec.duration)
                                            )
                                        end

                                        -- Also sync to pfUI if it's loaded
                                        if pfUI and pfUI.api and pfUI.api.libdebuff then
                                            local targetName = (lib.guidToName and lib.guidToName[normalizedTarget]) or UnitName("target")
                                            local targetLevel = UnitLevel("target") or 0

                                            if targetName then
                                                -- Refresh in pfUI's tracking (by name)
                                                pfUI.api.libdebuff:AddEffect(targetName, targetLevel, baseName, rec.duration, "player")

                                                if CleveRoids.debug then
                                                    DEFAULT_CHAT_FRAME:AddMessage(
                                                        string.format("|cff00ffaa[pfUI Judgement Refresh]|r Synced %s refresh to pfUI", baseName)
                                                    )
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
        return  -- Still return early after processing melee
    end

    -- Debug channel tracking
    if CleveRoids.ChannelTimeDebug then
        local spellName = spell_id and SpellInfo and SpellInfo(spell_id) or "Unknown"
        if string.find(spellName, "Arcane") then
            DEFAULT_CHAT_FRAME:AddMessage(string.format("|cff00ff00[UNIT_CASTEVENT]|r %s: %s (ID:%s) caster=%s player=%s",
                action, spellName, tostring(spell_id), tostring(caster), tostring(CleveRoids.playerGuid)))
        end
    end

    -- handle cast spell tracking
    local cast = CleveRoids.spell_tracking[caster]
    if cast_time > 0 and action == "START" or action == "CHANNEL" then
        CleveRoids.spell_tracking[caster] = { spell_id = spell_id, expires = GetTime() + cast_time/1000, type = action }

        -- ALSO store under "player" literal for easier lookup
        if caster == CleveRoids.playerGuid then
            CleveRoids.spell_tracking["player"] = CleveRoids.spell_tracking[caster]

            -- For CHANNEL events, capture duration for checkchanneled conditional
            if action == "CHANNEL" then
                CleveRoids.channelStartTime = GetTime()
                -- Try to get accurate duration from spell tooltip (reflects haste)
                local tooltipDuration = CleveRoids.GetChannelDurationFromTooltipByID(spell_id)
                if tooltipDuration then
                    CleveRoids.channelDuration = tooltipDuration
                else
                    -- Fallback to UNIT_CASTEVENT duration (may not reflect haste)
                    CleveRoids.channelDuration = cast_time / 1000
                end
            end

            -- For START events, capture cast time for checkcasting conditional
            if action == "START" then
                CleveRoids.castStartTime = GetTime()
                -- For cast-time spells, UNIT_CASTEVENT duration is usually accurate
                -- but we could add tooltip scanning here too if needed
                CleveRoids.castDuration = cast_time / 1000
            end
        end

        if CleveRoids.ChannelTimeDebug and caster == CleveRoids.playerGuid then
            DEFAULT_CHAT_FRAME:AddMessage(string.format("|cff00ff00[Tracking]|r Set spell_tracking[%s] AND [player]: type=%s, expires=%.2f",
                tostring(caster), action, GetTime() + cast_time/1000))
        end
        -- Always show for channels if debug is on
        if CleveRoids.ChannelTimeDebug and action == "CHANNEL" then
            DEFAULT_CHAT_FRAME:AddMessage(string.format("|cff00ff00[Tracking]|r caster=%s, playerGuid=%s, match=%s",
                tostring(caster), tostring(CleveRoids.playerGuid), tostring(caster == CleveRoids.playerGuid)))
        end
    elseif cast
        and (
            (cast.spell_id == spell_id and (action == "FAIL" or action == "CAST"))
            or (GetTime() > cast.expires)
        )
    then
        if CleveRoids.ChannelTimeDebug and caster == CleveRoids.playerGuid then
            local reason = ""
            if cast.spell_id == spell_id and (action == "FAIL" or action == "CAST") then
                reason = string.format("spell_id match (%s) and action=%s", tostring(spell_id), action)
            elseif GetTime() > cast.expires then
                reason = string.format("expired (%.2f > %.2f)", GetTime(), cast.expires)
            end
            DEFAULT_CHAT_FRAME:AddMessage(string.format("|cffff0000[Tracking]|r CLEARING spell_tracking - %s", reason))
        end
        CleveRoids.spell_tracking[caster] = nil
        -- Also clear "player" literal if this is the player
        if caster == CleveRoids.playerGuid then
            CleveRoids.spell_tracking["player"] = nil
        end
    end

    -- handle cast sequence (SuperWoW)
    if CleveRoids.currentSequence and caster == CleveRoids.playerGuid then
        local active = CleveRoids.GetCurrentSequenceAction(CleveRoids.currentSequence)

        local name, rank = SpellInfo(spell_id)
        local nameRank = (rank and rank ~= "") and (name .. "(" .. rank .. ")") or nil
        local isSeqSpell = active and active.action and (
            active.action == name or
            (nameRank and active.action == nameRank)
        )

        if isSeqSpell then
            local status = CleveRoids.currentSequence.status
            if status == 0 and (action == "START" or action == "CHANNEL") and cast_time > 0 then
                -- cast_time is ms; GetTime() is seconds
                CleveRoids.currentSequence.status  = 1
                CleveRoids.currentSequence.expires = GetTime() + (cast_time / 1000) - 2
            elseif (status == 0 and action == "CAST" and cast_time == 0)
                or (status == 1 and action == "CAST" and CleveRoids.currentSequence.expires) then
                CleveRoids.currentSequence.status     = 2
                CleveRoids.currentSequence.lastUpdate = GetTime()
                CleveRoids.AdvanceSequence(CleveRoids.currentSequence)
                CleveRoids.currentSequence = nil
            elseif action == "INTERRUPTED" or action == "FAILED" then
                CleveRoids.currentSequence.status = 1
            end
        end
    end

    if CleveRoidMacros.realtime == 0 then
        CleveRoids.QueueActionUpdate()
    end
end

-- Nampower SPELL_CAST_EVENT handler for reliable channel tracking
-- This is the PRIMARY source of truth for channel state (not GetCurrentCastingInfo polling)
function CleveRoids.Frame:SPELL_CAST_EVENT(success, spellId, castType, targetGuid, itemId)
    local CHANNEL = 4

    if castType == CHANNEL and success == 1 then
        -- Channel started successfully
        CleveRoids.CurrentSpell.type = "channeled"
        CleveRoids.CurrentSpell.castingSpellId = spellId

        local spellName = SpellInfo and SpellInfo(spellId)
        if spellName then
            CleveRoids.CurrentSpell.spellName = spellName
        end

        -- Force immediate action update
        CleveRoids.TestForAllActiveActions()
    end
end

function CleveRoids.Frame:SPELLCAST_CHANNEL_START()
    -- Set channel state immediately when event fires
    -- Duration is captured by UNIT_CASTEVENT which fires earlier
    CleveRoids.CurrentSpell.type = "channeled"

    -- Try to get spell info - prefer GetCastInfo (Nampower 2.18+) for better data
    local spellId = nil
    if GetCastInfo then
        local ok, info = pcall(GetCastInfo)
        if ok and info and info.spellId and info.spellId > 0 then
            spellId = info.spellId
            -- Also capture timing data
            CleveRoids.CurrentSpell.castRemainingMs = info.castRemainingMs
            CleveRoids.CurrentSpell.castEndTime = info.castEndS
        end
    end
    -- Fallback to GetCurrentCastingInfo for older Nampower
    if not spellId and GetCurrentCastingInfo then
        local _, visId = GetCurrentCastingInfo()
        if visId and visId > 0 then
            spellId = visId
        end
    end
    -- Update spell info
    if spellId then
        CleveRoids.CurrentSpell.castingSpellId = spellId
        local spellName = SpellInfo(spellId)
        if spellName then
            CleveRoids.CurrentSpell.spellName = spellName
        end
    end

    -- Force immediate action update
    CleveRoids.TestForAllActiveActions()
end

function CleveRoids.Frame:SPELLCAST_CHANNEL_STOP()
    -- Channel ended - clear state immediately
    CleveRoids.CurrentSpell.type = ""
    CleveRoids.CurrentSpell.spellName = ""
    CleveRoids.CurrentSpell.castingSpellId = nil

    -- WARLOCK DARK HARVEST: Mark channeling as ended
    -- Credits: Avitasia / Cursive addon
    if CleveRoids.darkHarvestData and CleveRoids.darkHarvestData.isActive then
        CleveRoids.darkHarvestData.isActive = false
        CleveRoids.darkHarvestData.endTime = GetTime()

        -- Apply Dark Harvest end to all DoTs on target (finalizes reduction)
        if CleveRoids.libdebuff and CleveRoids.libdebuff.ApplyDarkHarvestEnd then
            CleveRoids.libdebuff.ApplyDarkHarvestEnd(CleveRoids.darkHarvestData.targetGUID)
        end

        if CleveRoids.debug then
            local activeTime = CleveRoids.darkHarvestData.endTime - CleveRoids.darkHarvestData.startTime
            DEFAULT_CHAT_FRAME:AddMessage(
                string.format("|cff9482c9[Dark Harvest]|r Channel ended after %.1fs (DoT acceleration stopped)",
                    activeTime)
            )
        end
    end

    -- Force immediate action update
    CleveRoids.TestForAllActiveActions()
end

function CleveRoids.Frame:SPELLCAST_START()
    -- Cast-time spell started
    -- Duration is captured by UNIT_CASTEVENT which fires earlier
    CleveRoids.CurrentSpell.type = "cast"

    -- Try to get spell info - prefer GetCastInfo (Nampower 2.18+) for better data
    local spellId = nil
    if GetCastInfo then
        local ok, info = pcall(GetCastInfo)
        if ok and info and info.spellId and info.spellId > 0 then
            spellId = info.spellId
            -- Also capture timing data
            CleveRoids.CurrentSpell.castRemainingMs = info.castRemainingMs
            CleveRoids.CurrentSpell.castEndTime = info.castEndS
            CleveRoids.CurrentSpell.gcdRemainingMs = info.gcdRemainingMs
            CleveRoids.CurrentSpell.gcdEndTime = info.gcdEndS
        end
    end
    -- Fallback to GetCurrentCastingInfo for older Nampower
    if not spellId and GetCurrentCastingInfo then
        local castId = GetCurrentCastingInfo()
        if castId and castId > 0 then
            spellId = castId
        end
    end
    -- Update spell info
    if spellId then
        CleveRoids.CurrentSpell.castingSpellId = spellId
        local spellName = SpellInfo(spellId)
        if spellName then
            CleveRoids.CurrentSpell.spellName = spellName
        end
    end

    -- Force immediate action update
    CleveRoids.TestForAllActiveActions()
end

function CleveRoids.Frame:SPELLCAST_STOP()
    -- Cast finished - clear state immediately
    if CleveRoids.CurrentSpell.type == "cast" then
        CleveRoids.CurrentSpell.type = ""
        CleveRoids.CurrentSpell.spellName = ""
        CleveRoids.CurrentSpell.castingSpellId = nil

        -- Force immediate action update
        CleveRoids.TestForAllActiveActions()
    end
end

function CleveRoids.Frame:SPELLCAST_FAILED()
    -- Cast failed - clear state immediately
    if CleveRoids.CurrentSpell.type == "cast" then
        CleveRoids.CurrentSpell.type = ""
        CleveRoids.CurrentSpell.spellName = ""
        CleveRoids.CurrentSpell.castingSpellId = nil

        -- Force immediate action update
        CleveRoids.TestForAllActiveActions()
    end
end

function CleveRoids.Frame:SPELLCAST_INTERRUPTED()
    -- Cast interrupted - clear state immediately
    if CleveRoids.CurrentSpell.type == "cast" then
        CleveRoids.CurrentSpell.type = ""
        CleveRoids.CurrentSpell.spellName = ""
        CleveRoids.CurrentSpell.castingSpellId = nil

        -- Force immediate action update
        CleveRoids.TestForAllActiveActions()
    end
end

-- PLAYER_ENTER_COMBAT/PLAYER_LEAVE_COMBAT are for AUTO-ATTACK state (not actual combat)
function CleveRoids.Frame:PLAYER_ENTER_COMBAT()
    CleveRoids.CurrentSpell.autoAttack = true
    CleveRoids.CurrentSpell.autoAttackLock = false
    if CleveRoidMacros.realtime == 0 then
        CleveRoids.QueueActionUpdate()
    end
end

function CleveRoids.Frame:PLAYER_LEAVE_COMBAT()
    CleveRoids.CurrentSpell.autoAttack = false
    CleveRoids.CurrentSpell.autoAttackLock = false

    -- Reset any sequence with reset=combat that has progressed past the first step
    for _, sequence in pairs(CleveRoids.Sequences) do
        if sequence.index > 1 and sequence.reset and sequence.reset.combat then
            CleveRoids.ResetSequence(sequence)
        end
    end

    -- Full re-index after combat to refresh any items/bags that were skipped
    -- during combat for performance. Use a slight delay to avoid spam.
    local now = GetTime()
    if (now - (CleveRoids.lastItemIndexTime or 0)) > 0.5 then
        CleveRoids.lastItemIndexTime = now
        CleveRoids.IndexItems()
        CleveRoids.Actions = {}
        CleveRoids.Macros = {}
        CleveRoids.IndexActionBars()
    end

    if CleveRoidMacros.realtime == 0 then
        CleveRoids.QueueActionUpdate()
    end
end

-- PLAYER_REGEN_DISABLED/PLAYER_REGEN_ENABLED are for ACTUAL combat state (threat/aggro)
-- These events track what UnitAffectingCombat("player") reports
function CleveRoids.Frame:PLAYER_REGEN_DISABLED()
    -- PERFORMANCE: Cache actual combat state for event-driven [combat]/[nocombat] conditionals
    CleveRoids._cachedPlayerInCombat = true
    if CleveRoidMacros.realtime == 0 then
        CleveRoids.QueueActionUpdate()
    end
end

function CleveRoids.Frame:PLAYER_REGEN_ENABLED()
    -- PERFORMANCE: Cache actual combat state for event-driven [combat]/[nocombat] conditionals
    CleveRoids._cachedPlayerInCombat = false
    if CleveRoidMacros.realtime == 0 then
        CleveRoids.QueueActionUpdate()
    end
end

function CleveRoids.Frame:PLAYER_TARGET_CHANGED()
    CleveRoids.CurrentSpell.autoAttack = false
    CleveRoids.CurrentSpell.autoAttackLock = false

    -- Clear resist state when target changes
    CleveRoids.ClearResistState()

    -- Reset any sequence with reset=target that has progressed past the first step
    for _, sequence in pairs(CleveRoids.Sequences) do
        if sequence.index > 1 and sequence.reset and sequence.reset.target then
            CleveRoids.ResetSequence(sequence)
        end
    end

    if CleveRoidMacros.realtime == 0 then
        CleveRoids.QueueActionUpdate()
    end
end

function CleveRoids.Frame:UPDATE_MACROS()
    CleveRoids.currentSequence = nil
    -- Explicitly nil tables before re-assignment
    CleveRoids.ParsedMsg = nil;
    CleveRoids.ParsedMsg = {}

    CleveRoids.Macros = nil;
    CleveRoids.Macros = {}

    CleveRoids.Actions = nil;
    CleveRoids.Actions = {}

    CleveRoids.Sequences = nil;
    CleveRoids.Sequences = {}

    CleveRoids.IndexSpells()
    CleveRoids.IndexTalents()
    CleveRoids.IndexPetSpells()
    CleveRoids.IndexActionBars()
    if CleveRoidMacros.realtime == 0 then
        CleveRoids.QueueActionUpdate()
    end
end

function CleveRoids.Frame:SPELLS_CHANGED()
    -- PERFORMANCE: Clear spell caches when spells change (learn new ranks, etc.)
    CleveRoids.spellIdCache = {}
    CleveRoids.spellNameCache = {}
    CleveRoids.Frame:UPDATE_MACROS()
end

function CleveRoids.Frame:ACTIONBAR_SLOT_CHANGED()
    CleveRoids.ClearAction(arg1)
    CleveRoids.IndexActionSlot(arg1)
    if CleveRoidMacros.realtime == 0 then
        CleveRoids.QueueActionUpdate()
    end
end

function CleveRoids.Frame:BAG_UPDATE()
    -- In combat: Skip entirely for zero lag
    if UnitAffectingCombat("player") then
        return
    end

    -- Out of combat: Full indexing with throttle
    local now = GetTime()
    if (now - (CleveRoids.lastItemIndexTime or 0)) > 1.0 then
        CleveRoids.lastItemIndexTime = now
        CleveRoids.IndexItems()

        -- Directly clear all relevant caches and force a UI refresh for all buttons.
        CleveRoids.Actions = {}
        CleveRoids.Macros = {}
        CleveRoids.IndexActionBars()
        if CleveRoidMacros.realtime == 0 then
            CleveRoids.QueueActionUpdate()
        end
    end
end

function CleveRoids.Frame:UNIT_INVENTORY_CHANGED()
    if arg1 ~= "player" then return end

    -- PERFORMANCE: Invalidate equipment cache for HasGearEquipped
    if CleveRoids.InvalidateEquipmentCache then
        CleveRoids.InvalidateEquipmentCache()
    end

    -- In combat: Skip ALL processing - EquipBagItem already handles cache invalidation
    -- This eliminates lag from IndexEquippedItems during rapid gear swapping
    if UnitAffectingCombat("player") then
        return
    end

    -- Out of combat: Full indexing with throttle
    local now = GetTime()
    if (now - (CleveRoids.lastEquipIndexTime or 0)) < 0.2 then
        CleveRoids.equipIndexPendingTime = now
        return
    end

    CleveRoids.lastEquipIndexTime = now
    CleveRoids.equipIndexPendingTime = nil
    CleveRoids.lastItemIndexTime = now
    CleveRoids.IndexItems()
    CleveRoids.Actions = {}
    CleveRoids.Macros = {}
    CleveRoids.IndexActionBars()

    if CleveRoidMacros.realtime == 0 then
        CleveRoids.QueueActionUpdate()
    end
end

function CleveRoids.Frame:START_AUTOREPEAT_SPELL()
    local _, className = UnitClass("player")
    if className == "HUNTER" then
        CleveRoids.CurrentSpell.autoShot = true
    else
        CleveRoids.CurrentSpell.wand = true
    end
    if CleveRoidMacros.realtime == 0 then
        CleveRoids.QueueActionUpdate()
    end
end

function CleveRoids.Frame:STOP_AUTOREPEAT_SPELL()
    local _, className = UnitClass("player")
    if className == "HUNTER" then
        CleveRoids.CurrentSpell.autoShot = false
    else
        CleveRoids.CurrentSpell.wand = false
    end
    if CleveRoidMacros.realtime == 0 then
        CleveRoids.QueueActionUpdate()
    end
end

-- Generic event handlers that just queue an update
function CleveRoids.Frame:PLAYER_FOCUS_CHANGED()
    if CleveRoidMacros.realtime == 0 then
        CleveRoids.QueueActionUpdate()
    end
end
function CleveRoids.Frame:UPDATE_SHAPESHIFT_FORM()
    if CleveRoidMacros.realtime == 0 then
        CleveRoids.QueueActionUpdate()
    end
end
function CleveRoids.Frame:SPELL_UPDATE_COOLDOWN()
    if CleveRoidMacros.realtime == 0 then
        CleveRoids.QueueActionUpdate()
    end

    -- COOLDOWN FIX: Explicitly update cooldowns on all managed action buttons
    -- This ensures cooldowns display correctly even when the active action hasn't changed
    CleveRoids.UpdateAllManagedCooldowns()
end

-- Helper function to update cooldowns on all CleveRoids-managed action buttons
function CleveRoids.UpdateAllManagedCooldowns()
    local Actions = CleveRoids.Actions
    if not Actions then return end

    local handlerCount = CleveRoids.actionEventHandlers and table.getn(CleveRoids.actionEventHandlers) or 0
    if CleveRoids.cooldownDebug then
        DEFAULT_CHAT_FRAME:AddMessage("|cffff8800[CD Update]|r Updating cooldowns, " .. handlerCount .. " handlers registered")
    end

    for slot, actions in pairs(Actions) do
        if actions then
            -- Get the cooldown info for this slot
            local start, duration, enable = GetActionCooldown(slot)

            -- Update Blizzard action buttons
            local page = floor((slot - 1) / NUM_ACTIONBAR_BUTTONS) + 1
            local pageSlot = slot - (page - 1) * NUM_ACTIONBAR_BUTTONS

            local button
            if slot >= 73 then
                button = _G["BonusActionButton" .. pageSlot]
            elseif slot >= 61 then
                button = _G["MultiBarBottomLeftButton" .. pageSlot]
            elseif slot >= 49 then
                button = _G["MultiBarBottomRightButton" .. pageSlot]
            elseif slot >= 37 then
                button = _G["MultiBarLeftButton" .. pageSlot]
            elseif slot >= 25 then
                button = _G["MultiBarRightButton" .. pageSlot]
            elseif page == CURRENT_ACTIONBAR_PAGE then
                button = _G["ActionButton" .. pageSlot]
            end

            if button then
                local cooldown = _G[button:GetName() .. "Cooldown"]
                if cooldown and start and duration then
                    CooldownFrame_SetTimer(cooldown, start, duration, (enable and enable > 0) and enable or 1)
                end
            end

            -- Notify action event handlers (for pfUI/Bongos) about the cooldown update
            for _, fn_h in ipairs(CleveRoids.actionEventHandlers) do
                fn_h(slot, "ACTIONBAR_UPDATE_COOLDOWN")
            end
        end
    end
end
-- PERFORMANCE OPTIMIZATION: Throttled event handlers to reduce CPU spam
-- UNIT_AURA can fire dozens of times per second during combat
-- 100ms throttle reduces calls by 90%+ while maintaining responsiveness
function CleveRoids.Frame:UNIT_AURA()
    if CleveRoidMacros.realtime == 0 then
        local now = GetTime()
        if (now - CleveRoids.lastUnitAuraUpdate) >= CleveRoids.EVENT_THROTTLE then
            CleveRoids.lastUnitAuraUpdate = now
            CleveRoids.QueueActionUpdate()
        end
    end
end
function CleveRoids.Frame:UNIT_HEALTH()
    if CleveRoidMacros.realtime == 0 then
        local now = GetTime()
        if (now - CleveRoids.lastUnitHealthUpdate) >= CleveRoids.EVENT_THROTTLE then
            CleveRoids.lastUnitHealthUpdate = now
            CleveRoids.QueueActionUpdate()
        end
    end
end
function CleveRoids.Frame:UNIT_POWER()
    if CleveRoidMacros.realtime == 0 then
        local now = GetTime()
        if (now - CleveRoids.lastUnitPowerUpdate) >= CleveRoids.EVENT_THROTTLE then
            CleveRoids.lastUnitPowerUpdate = now
            CleveRoids.QueueActionUpdate()
        end
    end
end

function CleveRoids.Frame:SPELL_QUEUE_EVENT()
    if event == "SPELL_QUEUE_EVENT" then
        local eventCode = arg1
        local spellId = arg2

        local NORMAL_QUEUED = 2
        local NON_GCD_QUEUED = 4
        local ON_SWING_QUEUED = 0
        local NORMAL_QUEUE_POPPED = 3
        local NON_GCD_QUEUE_POPPED = 5
        local ON_SWING_QUEUE_POPPED = 1

        if eventCode == NORMAL_QUEUED or eventCode == NON_GCD_QUEUED or eventCode == ON_SWING_QUEUED then
            CleveRoids.queuedSpell = {
                spellId = spellId,
                queueType = eventCode,
                queueTime = GetTime()
            }
            if SpellInfo then
                local name = SpellInfo(spellId)
                if name then
                    CleveRoids.queuedSpell.spellName = name
                end
            end
            -- BUGFIX: Update casting state when spell is queued (for [casting] conditional)
            if CleveRoids.UpdateCastingState then
                CleveRoids.UpdateCastingState()
            end
            CleveRoids.QueueActionUpdate()
        elseif eventCode == NORMAL_QUEUE_POPPED or eventCode == NON_GCD_QUEUE_POPPED or eventCode == ON_SWING_QUEUE_POPPED then
            CleveRoids.queuedSpell = nil
            -- BUGFIX: Update casting state when spell queue pops (for [casting] conditional)
            if CleveRoids.UpdateCastingState then
                CleveRoids.UpdateCastingState()
            end
            CleveRoids.QueueActionUpdate()
        end
    end
end

function CleveRoids.Frame:SPELL_CAST_EVENT()
    if event == "SPELL_CAST_EVENT" then
        local success = arg1
        local spellId = arg2

        -- BUGFIX: Update casting state on spell cast events (for [casting] conditional)
        if CleveRoids.UpdateCastingState then
            CleveRoids.UpdateCastingState()
        end

        if success == 1 then
            CleveRoids.lastCastSpell = {
                spellId = spellId,
                timestamp = GetTime()
            }
            if SpellInfo then
                local name = SpellInfo(spellId)
                if name then
                    CleveRoids.lastCastSpell.spellName = name
                end
            end
        end
    end
end


CleveRoids.Hooks.SendChatMessage = SendChatMessage
function SendChatMessage(msg, ...)
    -- Filter out #showtooltip lines
    -- pfUI's macrotweak also does this, but our pattern is more specific
    if msg and string.find(msg, "^#showtooltip") then
        return
    end
    
    -- Call the original (or pfUI's hook if it's in the chain)
    CleveRoids.Hooks.SendChatMessage(msg, unpack(arg))
end

CleveRoids.RegisterActionEventHandler = function(fn)
    if type(fn) == "function" then
        table.insert(CleveRoids.actionEventHandlers, fn)
    end
end

CleveRoids.RegisterMouseOverResolver = function(fn)
    if type(fn) == "function" then
        table.insert(CleveRoids.mouseOverResolvers, fn)
    end
end

CleverMacro = true

do
    local f = CreateFrame("Frame")
    f:SetScript("OnEvent", function(self, event, arg1)
        if event == "PLAYER_LOGIN" then
            -- This ensures we wait until the player is fully in the world and all addons are loaded.
            self:UnregisterEvent("PLAYER_LOGIN")

            -- Ensure both pfUI and its focus module are loaded before attempting to hook.
            -- This also checks that the slash command we want to modify exists.
            if pfUI and pfUI.uf and pfUI.uf.focus and SlashCmdList.PFFOCUS then

                local original_PFFOCUS_Handler = SlashCmdList.PFFOCUS
                SlashCmdList.PFFOCUS = function(msg)
                    -- First, execute the original /focus command from pfUI to set the unit name.
                    original_PFFOCUS_Handler(msg)

                -- Now, if a focus name was set, find the corresponding UnitID.
                if pfUI.uf.focus.unitname then
                    local focusName = pfUI.uf.focus.unitname
                    local found_label, found_id = nil, nil

                    -- This function iterates through all known friendly units to find a
                    -- name match and return its specific UnitID components.
                    local function findUnitID()
                        -- Check party members and their pets
                        for i = 1, GetNumPartyMembers() do
                            if strlower(UnitName("party"..i) or "") == focusName then
                                return "party", i
                            end
                            if UnitExists("partypet"..i) and strlower(UnitName("partypet"..i) or "") == focusName then
                                return "partypet", i
                            end
                        end

                        -- Check raid members and their pets
                        for i = 1, GetNumRaidMembers() do
                            if strlower(UnitName("raid"..i) or "") == focusName then
                                return "raid", i
                            end
                            if UnitExists("raidpet"..i) and strlower(UnitName("raidpet"..i) or "") == focusName then
                                return "raidpet", i
                            end
                        end

                        -- Check player and pet
                        if strlower(UnitName("player") or "") == focusName then return "player", nil end
                        if UnitExists("pet") and strlower(UnitName("pet") or "") == focusName then return "pet", nil end

                            return nil, nil
                        end

                        found_label, found_id = findUnitID()

                        -- Store the found label and ID. CleveRoids' Core.lua will use this
                        -- for a direct, reliable cast without needing to change your target.
                        pfUI.uf.focus.label = found_label
                        pfUI.uf.focus.id = found_id
                    else
                        -- Focus was cleared (e.g., via /clearfocus), so ensure our cached data is cleared too.
                        pfUI.uf.focus.label = nil
                        pfUI.uf.focus.id = nil
                    end
                end
            end
        end
    end)
    f:RegisterEvent("PLAYER_LOGIN")
end

SLASH_CLEVEROID1 = "/cleveroid"
SLASH_CLEVEROID2 = "/cleveroidmacros"
SlashCmdList["CLEVEROID"] = function(msg)
    if type(msg) ~= "string" then
        msg = ""
    end
    local cmd, val, val2
    local s, e, a, b, c = string.find(msg, "^(%S*)%s*(%S*)%s*(.*)$")
    if a then cmd = a else cmd = "" end
    if b then val = b else val = "" end
    if c then val2 = c else val2 = "" end

    -- No command: show current value and available commands
    if cmd == "" then
        CleveRoids.Print("Current Settings:")
        DEFAULT_CHAT_FRAME:AddMessage("realtime (force fast updates, CPU intensive) = " .. CleveRoidMacros.realtime .. " (Default: 0)")
        DEFAULT_CHAT_FRAME:AddMessage("refresh (updates per second) = " .. CleveRoidMacros.refresh .. " (Default: 5)")
        DEFAULT_CHAT_FRAME:AddMessage("debug (show learning messages) = " .. (CleveRoids.debug and "1" or "0") .. " (Default: 0)")
        DEFAULT_CHAT_FRAME:AddMessage(" ")
        CleveRoids.Print("Available Commands:")
        DEFAULT_CHAT_FRAME:AddMessage("/cleveroid realtime 0 or 1 - Force realtime updates")
        DEFAULT_CHAT_FRAME:AddMessage("/cleveroid refresh X - Set refresh rate (1-10 updates/sec)")
        if CleveRoids.hasSuperwow then
            DEFAULT_CHAT_FRAME:AddMessage("/cleveroid learn <spellID> <duration> - Manually set spell duration")
            DEFAULT_CHAT_FRAME:AddMessage("/cleveroid forget <spellID|all> - Forget learned duration(s)")
            DEFAULT_CHAT_FRAME:AddMessage("/cleveroid debug [0|1] - Toggle learning debug messages")
        end
        DEFAULT_CHAT_FRAME:AddMessage("/cleveroid macrodebug - Toggle macro length warning debug")
        DEFAULT_CHAT_FRAME:AddMessage("/cleveroid macrorefdebug - Toggle macro reference {Name} execution debug")
        DEFAULT_CHAT_FRAME:AddMessage("/cleveroid macrostatus - Check macro length warning status")
        DEFAULT_CHAT_FRAME:AddMessage("|cffffaa00Spell School Detection:|r")
        DEFAULT_CHAT_FRAME:AddMessage('/cleveroid schooltest <spellID or name> - Test spell school detection')
        DEFAULT_CHAT_FRAME:AddMessage('/cleveroid listschools - List all learned spell schools')
        DEFAULT_CHAT_FRAME:AddMessage('/cleveroid clearschools - Clear learned spell school data')
        DEFAULT_CHAT_FRAME:AddMessage("|cffffaa00Immunity Tracking:|r")
        DEFAULT_CHAT_FRAME:AddMessage('/cleveroid listimmune [school] - List immunity data')
        DEFAULT_CHAT_FRAME:AddMessage('/cleveroid addimmune "<NPC>" <school> [buff] - Add immunity')
        DEFAULT_CHAT_FRAME:AddMessage('/cleveroid removeimmune "<NPC>" <school> - Remove immunity')
        DEFAULT_CHAT_FRAME:AddMessage('/cleveroid clearimmune [school] - Clear immunity data')
        DEFAULT_CHAT_FRAME:AddMessage("|cffffaa00CC Immunity Tracking:|r")
        DEFAULT_CHAT_FRAME:AddMessage('/cleveroid listccimmune [type] - List CC immunity data')
        DEFAULT_CHAT_FRAME:AddMessage('/cleveroid addccimmune "<NPC>" <type> [buff] - Add CC immunity')
        DEFAULT_CHAT_FRAME:AddMessage('/cleveroid removeccimmune "<NPC>" <type> - Remove CC immunity')
        DEFAULT_CHAT_FRAME:AddMessage('/cleveroid clearccimmune [type] - Clear CC immunity data')
        DEFAULT_CHAT_FRAME:AddMessage("  CC types: stun, fear, root, silence, sleep, charm, polymorph, banish, horror, disorient, snare")
        DEFAULT_CHAT_FRAME:AddMessage("|cffffaa00Combo Point Tracking:|r")
        DEFAULT_CHAT_FRAME:AddMessage('/cleveroid combotrack - Show combo point tracking info')
        DEFAULT_CHAT_FRAME:AddMessage('/cleveroid comboclear - Clear combo tracking data')
        DEFAULT_CHAT_FRAME:AddMessage('/cleveroid combolearn - Show learned combo durations (per CP)')
        DEFAULT_CHAT_FRAME:AddMessage("|cffffaa00Talent Modifiers:|r")
        DEFAULT_CHAT_FRAME:AddMessage('/cleveroid talenttabs - Show talent tab IDs for your class')
        DEFAULT_CHAT_FRAME:AddMessage('/cleveroid listtab <tab> - List all talents in a tab with their IDs')
        DEFAULT_CHAT_FRAME:AddMessage('/cleveroid talents - Show current talent ranks')
        DEFAULT_CHAT_FRAME:AddMessage('/cleveroid testtalent <spellID> - Test talent modifier for a spell')
        DEFAULT_CHAT_FRAME:AddMessage('/cleveroid diagnosetalent <spellID> - Diagnose talent modifier issues')
        DEFAULT_CHAT_FRAME:AddMessage("|cffffaa00Equipment Modifiers:|r")
        DEFAULT_CHAT_FRAME:AddMessage('/cleveroid testequip <spellID> - Test equipment modifier for a spell')
        DEFAULT_CHAT_FRAME:AddMessage('/cleveroid equipdebug <item name> - Debug item lookup for /equip')
        DEFAULT_CHAT_FRAME:AddMessage('/cleveroid equiplog - Toggle real-time equip command logging')
        DEFAULT_CHAT_FRAME:AddMessage("|cffffaa00Reactive Proc Tracking:|r")
        DEFAULT_CHAT_FRAME:AddMessage('/cleveroid listprocs - Show active reactive ability procs')
        DEFAULT_CHAT_FRAME:AddMessage('/cleveroid setproc <spell> [duration] - Manually set proc (testing)')
        DEFAULT_CHAT_FRAME:AddMessage('/cleveroid clearproc [spell|all] - Clear reactive proc(s)')
        DEFAULT_CHAT_FRAME:AddMessage("|cffffaa00Casting Detection:|r")
        DEFAULT_CHAT_FRAME:AddMessage('/cleveroid testcasting - Test [selfcasting]/[noselfcasting] conditionals')
        DEFAULT_CHAT_FRAME:AddMessage('/cleveroid testchannel - Test [channeltime] conditional tracking')
        DEFAULT_CHAT_FRAME:AddMessage('/cleveroid channeldebug - Toggle [channeltime] conditional debug output')
        DEFAULT_CHAT_FRAME:AddMessage("|cffffaa00Action Slot Debug:|r")
        DEFAULT_CHAT_FRAME:AddMessage('/cleveroid slotdebug <slot> - Debug action slot state (tooltip/range/mana)')
        DEFAULT_CHAT_FRAME:AddMessage('/cleveroid rangedebug <spell> - Debug spell range checking (channeled spells)')
        DEFAULT_CHAT_FRAME:AddMessage("|cffffaa00Slam Rotation (Warrior):|r")
        DEFAULT_CHAT_FRAME:AddMessage('/cleveroid slamdebug - Show Slam cast time and clip window calculations')
        DEFAULT_CHAT_FRAME:AddMessage("|cffffaa00Debuff Tracking Debug:|r")
        DEFAULT_CHAT_FRAME:AddMessage('/cleveroid debuffdebug [spell] - Debug debuff tracking on target')
        return
    end

    -- realtime
    if cmd == "realtime" then
        local num = tonumber(val)
        if num == 0 or num == 1 then
            CleveRoidMacros.realtime = num
            CleveRoids.Print("realtime set to " .. num)
        else
            CleveRoids.Print("Usage: /cleveroid realtime 0 or 1 - Force realtime updates rather than event based updates (Default: 0. 1 = on, increases CPU load.)")
            CleveRoids.Print("Current realtime = " .. tostring(CleveRoidMacros.realtime))
        end
        return
    end

    -- refresh
    if cmd == "refresh" then
        local num = tonumber(val)
        if num and num >= 1 and num <= 10 then
            CleveRoidMacros.refresh = num
            CleveRoids.cachedRefreshRate = nil  -- Invalidate cached rate
            CleveRoids.Print("refresh set to " .. num .. " times per second")
        else
            CleveRoids.Print("Usage: /cleveroid refresh X - Set refresh rate. (1 to 10 updates per second. Default: 5)")
            CleveRoids.Print("Current refresh = " .. tostring(CleveRoidMacros.refresh) .. " times per second")
        end
        return
    end

    -- learn (manual set duration)
    if cmd == "learn" then
        if not CleveRoids.hasSuperwow then
            CleveRoids.Print("Learning system requires SuperWoW client!")
            return
        end
        local spellID = tonumber(val)
        local duration = tonumber(val2)
        if spellID and duration then
            local _, playerGUID = UnitExists("player")
            CleveRoids_LearnedDurations = CleveRoids_LearnedDurations or {}
            CleveRoids_LearnedDurations[spellID] = CleveRoids_LearnedDurations[spellID] or {}
            CleveRoids_LearnedDurations[spellID][playerGUID] = duration
            local spellName = SpellInfo(spellID) or "Unknown"
            CleveRoids.Print("Set " .. spellName .. " (ID:" .. spellID .. ") duration to " .. duration .. "s")
        else
            CleveRoids.Print("Usage: /cleveroid learn <spellID> <duration> - Manually set spell duration")
            CleveRoids.Print("Example: /cleveroid learn 11597 30")
        end
        return
    end

    -- forget (delete learned duration)
    if cmd == "forget" or cmd == "unlearn" then
        if not CleveRoids.hasSuperwow then
            CleveRoids.Print("Learning system requires SuperWoW client!")
            return
        end
        if val == "all" then
            CleveRoids_LearnedDurations = {}
            CleveRoids.Print("Forgot all learned spell durations")
        else
            local spellID = tonumber(val)
            if spellID and CleveRoids_LearnedDurations and CleveRoids_LearnedDurations[spellID] then
                local spellName = SpellInfo(spellID) or "Unknown"
                CleveRoids_LearnedDurations[spellID] = nil
                CleveRoids.Print("Forgot " .. spellName .. " (ID:" .. spellID .. ") duration")
            elseif spellID then
                CleveRoids.Print("No learned duration for spell ID " .. spellID)
            else
                CleveRoids.Print("Usage: /cleveroid forget <spellID> - Forget learned duration")
                CleveRoids.Print("       /cleveroid forget all - Forget all learned durations")
            end
        end
        return
    end

    -- debug (toggle learning messages)
    if cmd == "debug" then
        local num = tonumber(val)
        if num == 0 or num == 1 then
            CleveRoids.debug = (num == 1)
            CleveRoids.Print("debug set to " .. num)
        else
            CleveRoids.debug = not CleveRoids.debug
            CleveRoids.Print("debug " .. (CleveRoids.debug and "enabled" or "disabled"))
        end
        return
    end

    -- macrodebug (toggle macro length warning debug messages)
    if cmd == "macrodebug" then
        CleveRoids.MacroLengthDebug = not CleveRoids.MacroLengthDebug
        CleveRoids.Print("Macro length warning debug " .. (CleveRoids.MacroLengthDebug and "enabled" or "disabled"))
        return
    end

    -- macrorefdebug (toggle macro reference execution debug messages)
    if cmd == "macrorefdebug" or cmd == "refdebug" then
        CleveRoids.macroRefDebug = not CleveRoids.macroRefDebug
        CleveRoids.Print("Macro reference debug " .. (CleveRoids.macroRefDebug and "enabled" or "disabled"))
        CleveRoids.Print("Use /cast [cond] {MacroName} and watch for [MacroRef] messages")
        return
    end

    -- cooldowndebug (toggle cooldown update debug messages)
    if cmd == "cooldowndebug" or cmd == "cddebug" then
        CleveRoids.cooldownDebug = not CleveRoids.cooldownDebug
        CleveRoids.Print("Cooldown debug " .. (CleveRoids.cooldownDebug and "enabled" or "disabled"))
        if CleveRoids.cooldownDebug then
            CleveRoids.Print("Use /pfuicd for pfUI-specific cooldown debug")
            local handlerCount = CleveRoids.actionEventHandlers and table.getn(CleveRoids.actionEventHandlers) or 0
            CleveRoids.Print("Action event handlers registered: " .. handlerCount)
        end
        return
    end

    -- slotdebug <slot> - Debug action slot state for tooltip/range/mana issues
    if cmd == "slotdebug" then
        local slot = tonumber(val)
        if not slot then
            CleveRoids.Print("Usage: /cleveroid slotdebug <slot> - Debug action slot (1-120)")
            return
        end
        local actions = CleveRoids.GetAction(slot)
        CleveRoids.Print("|cff00ff00=== Slot " .. slot .. " Debug ===|r")
        if not actions then
            CleveRoids.Print("No actions data for slot " .. slot)
            CleveRoids.Print("GetActionText: " .. tostring(GetActionText(slot)))
            return
        end
        CleveRoids.Print("actions.tooltip: " .. tostring(actions.tooltip ~= nil))
        CleveRoids.Print("actions.explicitTooltip: " .. tostring(actions.explicitTooltip))
        CleveRoids.Print("actions.list count: " .. tostring(actions.list and table.getn(actions.list) or 0))
        if actions.active then
            CleveRoids.Print("|cff00ffffActive action:|r")
            CleveRoids.Print("  .action: " .. tostring(actions.active.action))
            CleveRoids.Print("  .type: " .. tostring(actions.active.type))
            CleveRoids.Print("  .spell: " .. tostring(actions.active.spell ~= nil))
            if actions.active.spell then
                CleveRoids.Print("    .spell.name: " .. tostring(actions.active.spell.name))
                CleveRoids.Print("    .spell.cost: " .. tostring(actions.active.spell.cost))
            end
            CleveRoids.Print("  .usable: " .. tostring(actions.active.usable))
            CleveRoids.Print("  .oom: " .. tostring(actions.active.oom))
            CleveRoids.Print("  .inRange: " .. tostring(actions.active.inRange))
            CleveRoids.Print("  .conditionals: " .. tostring(actions.active.conditionals ~= nil))
            if actions.active.conditionals then
                CleveRoids.Print("    .target: " .. tostring(actions.active.conditionals.target))
            end
        else
            CleveRoids.Print("|cffff0000No active action|r")
        end
        CleveRoids.Print("|cffaaaa00Hook conditions:|r")
        local hasTooltip = actions.tooltip ~= nil
        local hasActive = actions.active ~= nil
        local typeIsSpell = actions.active and actions.active.type == "spell"
        CleveRoids.Print("  actions.tooltip: " .. tostring(hasTooltip))
        CleveRoids.Print("  actions.active: " .. tostring(hasActive))
        CleveRoids.Print("  .type == 'spell': " .. tostring(typeIsSpell))
        CleveRoids.Print("  Range hook would: " .. (hasTooltip and hasActive and typeIsSpell and "USE CUSTOM" or "FALLBACK"))
        return
    end

    -- macrostatus (check macro length warning status)
    if cmd == "macrostatus" then
        CleveRoids.Print("|cff00ff00=== MacroLengthWarn Status ===|r")

        -- Check if file loaded
        if CleveRoids.MacroLengthWarnLoaded then
            CleveRoids.Print("File: |cff00ff00LOADED|r")
        else
            CleveRoids.Print("File: |cffff0000NOT LOADED|r - Check for Lua errors!")
        end

        -- Check if extension is registered
        local ext = CleveRoids.Extensions and CleveRoids.Extensions["MacroLengthWarn"]
        if ext then
            CleveRoids.Print("Extension: |cff00ff00REGISTERED|r")

            -- Check if OnLoad was called
            if ext.ShowMessages then
                CleveRoids.Print("OnLoad: |cff00ff00CALLED|r")

                -- Call the status function
                ext.ShowMessages()
            else
                CleveRoids.Print("OnLoad: |cffff0000NOT CALLED|r")
            end
        else
            CleveRoids.Print("Extension: |cffff0000NOT REGISTERED|r")
            CleveRoids.Print("The MacroLengthWarn extension failed to register!")
        end

        -- Check key functions
        CleveRoids.Print(" ")
        CleveRoids.Print("Function Status:")
        CleveRoids.Print("  EditMacro: " .. (EditMacro and "|cff00ff00EXISTS|r" or "|cffff0000MISSING|r"))
        CleveRoids.Print("  MacroFrame_SaveMacro: " .. (MacroFrame_SaveMacro and "|cff00ff00EXISTS|r" or "|cffffff00NOT LOADED YET|r"))

        return
    end

    -- channeldebug (toggle channeltime conditional debug)
    if cmd == "channeldebug" then
        CleveRoids.ChannelTimeDebug = not CleveRoids.ChannelTimeDebug
        CleveRoids.Print("Channel time debug " .. (CleveRoids.ChannelTimeDebug and "enabled" or "disabled"))
        if CleveRoids.ChannelTimeDebug then
            CleveRoids.Print("You will see messages every time [channeltime] is evaluated")
            CleveRoids.Print("This shows if your macro is re-evaluating during the channel")
        end
        return
    end

    -- testchannel (debug channel time detection)
    if cmd == "testchannel" or cmd == "channeltest" then
        CleveRoids.Print("|cff00ff00=== Channel Time Test ===|r")

        -- Check spell tracking
        local playerCast = CleveRoids.spell_tracking[CleveRoids.playerGuid]
        if not playerCast then
            CleveRoids.Print("|cffffff00No spell tracking data for player|r")
            CleveRoids.Print("You must be casting or channeling a spell for this to show data")
        else
            CleveRoids.Print("Spell tracking found:")
            CleveRoids.Print("  Type: " .. tostring(playerCast.type))
            CleveRoids.Print("  Spell ID: " .. tostring(playerCast.spell_id))
            if playerCast.spell_id and SpellInfo then
                local spellName = SpellInfo(playerCast.spell_id)
                CleveRoids.Print("  Spell Name: " .. tostring(spellName))
            end
            if playerCast.expires then
                local timeLeft = playerCast.expires - GetTime()
                CleveRoids.Print("  Expires at: " .. tostring(playerCast.expires))
                CleveRoids.Print("  Time left: " .. string.format("%.2f", timeLeft) .. "s")

                -- Test conditionals
                CleveRoids.Print(" ")
                CleveRoids.Print("Conditional tests:")
                CleveRoids.Print("  [channeltime:<0.5]: " .. (timeLeft < 0.5 and "|cff00ff00TRUE|r" or "|cffff0000FALSE|r"))
                CleveRoids.Print("  [channeltime:<1.0]: " .. (timeLeft < 1.0 and "|cff00ff00TRUE|r" or "|cffff0000FALSE|r"))
                CleveRoids.Print("  [channeltime:>2.0]: " .. (timeLeft > 2.0 and "|cff00ff00TRUE|r" or "|cffff0000FALSE|r"))
            else
                CleveRoids.Print("  Expires: NOT SET")
            end
        end

        CleveRoids.Print(" ")
        CleveRoids.Print("|cff00ffffInstructions:|r")
        CleveRoids.Print("1. Start channeling Arcane Missiles")
        CleveRoids.Print("2. Run /cleveroid testchannel while channeling")
        CleveRoids.Print("3. Check if spell tracking is working")

        CleveRoids.Print("|cff00ff00=== End Test ===|r")
        return
    end

    -- rangedebug <spell> - Debug range checking for a spell
    if cmd == "rangedebug" or cmd == "testrange" then
        -- Combine val and val2 for multi-word spell names
        local spellName = val
        if val2 and val2 ~= "" then
            spellName = val .. " " .. val2
        end
        if not spellName or spellName == "" then
            CleveRoids.Print("Usage: /cleveroid rangedebug <spell name>")
            CleveRoids.Print("Example: /cleveroid rangedebug Arcane Missiles")
            return
        end

        CleveRoids.Print("|cff00ff00=== Range Debug: " .. spellName .. " ===|r")

        -- Get spell ID
        local spellId = nil
        if GetSpellIdForName then
            spellId = GetSpellIdForName(spellName)
            CleveRoids.Print("Spell ID: " .. (spellId and tostring(spellId) or "|cffff0000NOT FOUND|r"))
        else
            CleveRoids.Print("GetSpellIdForName: |cffff0000NOT AVAILABLE|r")
        end

        if spellId and spellId > 0 then
            -- Check native IsSpellInRange
            if IsSpellInRange then
                local target = UnitExists("target") and "target" or nil
                if target then
                    local result = IsSpellInRange(spellId, target)
                    CleveRoids.Print("Native IsSpellInRange: " .. tostring(result))
                    if result == -1 then
                        CleveRoids.Print("  |cffffff00(-1 means non-unit-targeted spell, using fallback)|r")
                    elseif result == nil then
                        CleveRoids.Print("  |cffffff00(nil means error or unknown spell)|r")
                    end
                else
                    CleveRoids.Print("Native IsSpellInRange: |cffffff00No target selected|r")
                end
            end

            -- Check GetSpellRec fields
            local API = CleveRoids.NampowerAPI
            if API then
                -- Try rangeMax (may not exist)
                local rangeMax = API.GetSpellField(spellId, "rangeMax")
                CleveRoids.Print("rangeMax field: " .. (rangeMax and tostring(rangeMax) or "|cffffff00nil|r"))

                -- Try rangeIndex
                local rangeIndex = API.GetSpellField(spellId, "rangeIndex")
                CleveRoids.Print("rangeIndex field: " .. (rangeIndex and tostring(rangeIndex) or "|cffffff00nil|r"))

                if rangeIndex and API.SpellRangeTable then
                    local lookupRange = API.SpellRangeTable[rangeIndex]
                    CleveRoids.Print("SpellRangeTable[" .. rangeIndex .. "]: " .. (lookupRange and (tostring(lookupRange) .. " yards") or "|cffffff00not found|r"))
                end

                -- Final GetSpellRange result
                local finalRange = API.GetSpellRange(spellId)
                CleveRoids.Print("API.GetSpellRange: " .. (finalRange and (tostring(finalRange) .. " yards") or "|cffff0000nil|r"))

                -- UnitXP distance check
                if CleveRoids.hasUnitXP and UnitExists("target") then
                    local distance = UnitXP("distanceBetween", "player", "target")
                    CleveRoids.Print("Distance to target: " .. (distance and (string.format("%.1f", distance) .. " yards") or "|cffffff00nil|r"))

                    if finalRange and distance then
                        local inRange = distance <= finalRange
                        CleveRoids.Print("In range (distance <= spellRange): " .. (inRange and "|cff00ff00YES|r" or "|cffff0000NO|r"))
                    end
                elseif not CleveRoids.hasUnitXP then
                    CleveRoids.Print("UnitXP: |cffff0000NOT INSTALLED (required for fallback)|r")
                else
                    CleveRoids.Print("Distance check: |cffffff00No target selected|r")
                end

                -- Final API.IsSpellInRange result
                if UnitExists("target") then
                    local finalResult = API.IsSpellInRange(spellId, "target")
                    CleveRoids.Print("API.IsSpellInRange: " .. tostring(finalResult))
                else
                    -- Test without target
                    local finalResult = API.IsSpellInRange(spellId, "player")
                    CleveRoids.Print("API.IsSpellInRange (no target, using player): " .. tostring(finalResult))
                end

                -- Target type detection
                local targetA = API.GetSpellField(spellId, "effectImplicitTargetA")
                local targetB = API.GetSpellField(spellId, "effectImplicitTargetB")

                -- Format target data (handle tables)
                local function formatTarget(t)
                    if not t then return "|cffffff00nil|r" end
                    if type(t) == "table" then
                        local parts = {}
                        for i = 1, 3 do
                            table.insert(parts, tostring(t[i] or 0))
                        end
                        return "{" .. table.concat(parts, ", ") .. "}"
                    end
                    return tostring(t)
                end

                CleveRoids.Print("effectImplicitTargetA: " .. formatTarget(targetA))
                CleveRoids.Print("effectImplicitTargetB: " .. formatTarget(targetB))

                local isUnitTargeted = API.IsUnitTargetedSpell(spellId)
                CleveRoids.Print("Is unit-targeted spell: " .. (isUnitTargeted == true and "|cff00ff00YES|r" or isUnitTargeted == false and "|cffff0000NO|r" or "|cffffff00UNKNOWN|r"))

                -- Self-cast/ground-targeted detection summary
                local isSelfCast = (isUnitTargeted == false)
                CleveRoids.Print("Detected as self/ground-targeted: " .. (isSelfCast and "|cff00ff00YES|r" or "|cffff0000NO|r"))
            end
        end

        CleveRoids.Print("|cff00ff00=== End Range Debug ===|r")
        return
    end

    -- testcasting (debug casting state detection)
    if cmd == "testcasting" or cmd == "casttest" then
        CleveRoids.Print("|cff00ff00=== Casting State Test ===|r")

        -- Check GetCurrentCastingInfo availability
        if not GetCurrentCastingInfo then
            CleveRoids.Print("|cffff0000ERROR: GetCurrentCastingInfo not available!|r")
            CleveRoids.Print("This requires Nampower to be installed.")
            return
        end

        -- Get current casting info
        local castId, visId, autoId, casting, channeling, onswing, autoattack = GetCurrentCastingInfo()

        CleveRoids.Print("GetCurrentCastingInfo() values:")
        CleveRoids.Print("  castId: " .. tostring(castId))
        CleveRoids.Print("  visId: " .. tostring(visId))
        CleveRoids.Print("  autoId: " .. tostring(autoId))
        CleveRoids.Print("  casting: " .. tostring(casting))
        CleveRoids.Print("  channeling: " .. tostring(channeling))
        CleveRoids.Print("  onswing: " .. tostring(onswing))
        CleveRoids.Print("  autoattack: " .. tostring(autoattack))

        -- Test conditionals
        local isCasting = (casting and casting == 1) or false
        local isChanneling = (channeling and channeling == 1) or false

        CleveRoids.Print(" ")
        CleveRoids.Print("Conditional results:")
        CleveRoids.Print("  [selfcasting]: " .. tostring(isCasting or isChanneling))
        CleveRoids.Print("  [noselfcasting]: " .. tostring(not isCasting and not isChanneling))

        CleveRoids.Print(" ")
        if isCasting then
            CleveRoids.Print("|cffff00ffYou ARE currently CASTING|r")
        elseif isChanneling then
            CleveRoids.Print("|cffff00ffYou ARE currently CHANNELING|r")
        else
            CleveRoids.Print("|cff00ff00You are NOT casting or channeling|r")
        end

        CleveRoids.Print("|cff00ff00=== End Test ===|r")
        return
    end

    -- listimmune (list immunity data)
    if cmd == "listimmune" or cmd == "immunelist" then
        CleveRoids.ListImmunities(val ~= "" and val or nil)
        return
    end

    -- clearimmune (clear immunity data)
    if cmd == "clearimmune" then
        CleveRoids.ClearImmunities(val ~= "" and val or nil)
        return
    end

    -- addimmune (manually add immunity)
    if cmd == "addimmune" then
        -- Parse: /cleveroid addimmune <NPC Name> <school> [buff]
        -- Example: /cleveroid addimmune "Golemagg the Incinerator" fire
        -- Example: /cleveroid addimmune Vaelastrasz fire "Burning Adrenaline"
        local npcName, school, buffName = nil, nil, nil

        -- Try to extract quoted NPC name
        local _, _, quotedNpc, rest = string.find(msg, '^addimmune%s+"([^"]+)"%s*(.*)$')
        if quotedNpc then
            npcName = quotedNpc
            -- Parse school and optional buff from rest
            local _, _, sch, buff = string.find(rest, "^(%S+)%s*(.*)$")
            school = sch
            if buff and buff ~= "" then
                -- Check if buff is quoted
                local _, _, quotedBuff = string.find(buff, '^"([^"]+)"$')
                buffName = quotedBuff or buff
            end
        else
            -- No quoted NPC, use simple parsing
            npcName = val
            school = val2
        end

        CleveRoids.AddImmunity(npcName, school, buffName)
        return
    end

    -- removeimmune (manually remove immunity)
    if cmd == "removeimmune" then
        -- Parse: /cleveroid removeimmune <NPC Name> <school>
        local npcName, school = nil, nil

        -- Try to extract quoted NPC name
        local _, _, quotedNpc, sch = string.find(msg, '^removeimmune%s+"([^"]+)"%s*(%S*)$')
        if quotedNpc then
            npcName = quotedNpc
            school = sch
        else
            npcName = val
            school = val2
        end

        CleveRoids.RemoveImmunity(npcName, school)
        return
    end

    -- ========== CC IMMUNITY COMMANDS ==========

    -- listccimmune (list CC immunity data)
    if cmd == "listccimmune" or cmd == "ccimmunelist" then
        CleveRoids.ListCCImmunities(val ~= "" and val or nil)
        return
    end

    -- clearccimmune (clear CC immunity data)
    if cmd == "clearccimmune" then
        CleveRoids.ClearCCImmunities(val ~= "" and val or nil)
        return
    end

    -- addccimmune (manually add CC immunity)
    if cmd == "addccimmune" then
        -- Parse: /cleveroid addccimmune <NPC Name> <cctype> [buff]
        -- Example: /cleveroid addccimmune "Stone Guardian" stun
        -- Example: /cleveroid addccimmune "Boss Name" fear "Enrage"
        local npcName, ccType, buffName = nil, nil, nil

        -- Try to extract quoted NPC name
        local _, _, quotedNpc, rest = string.find(msg, '^addccimmune%s+"([^"]+)"%s*(.*)$')
        if quotedNpc then
            npcName = quotedNpc
            -- Parse ccType and optional buff from rest
            local _, _, cct, buff = string.find(rest, "^(%S+)%s*(.*)$")
            ccType = cct
            if buff and buff ~= "" then
                -- Check if buff is quoted
                local _, _, quotedBuff = string.find(buff, '^"([^"]+)"$')
                buffName = quotedBuff or buff
            end
        else
            -- No quoted NPC, use simple parsing
            npcName = val
            ccType = val2
        end

        CleveRoids.AddCCImmunity(npcName, ccType, buffName)
        return
    end

    -- removeccimmune (manually remove CC immunity)
    if cmd == "removeccimmune" then
        -- Parse: /cleveroid removeccimmune <NPC Name> <cctype>
        local npcName, ccType = nil, nil

        -- Try to extract quoted NPC name
        local _, _, quotedNpc, cct = string.find(msg, '^removeccimmune%s+"([^"]+)"%s*(%S*)$')
        if quotedNpc then
            npcName = quotedNpc
            ccType = cct
        else
            npcName = val
            ccType = val2
        end

        CleveRoids.RemoveCCImmunityCommand(npcName, ccType)
        return
    end

    -- schooltest (test spell school detection)
    if cmd == "schooltest" or cmd == "testschool" then
        local input = val
        if input == "" then
            CleveRoids.Print("Usage: /cleveroid schooltest <spellID or name>")
            CleveRoids.Print("Example: /cleveroid schooltest 133")
            CleveRoids.Print("Example: /cleveroid schooltest Fireball")
            return
        end

        local spellID = tonumber(input)
        local spellName = nil
        local school = nil

        if spellID then
            -- Input is a spell ID
            spellName = SpellInfo and SpellInfo(spellID)
            school = CleveRoids.GetSpellSchoolByID(spellID)
        else
            -- Input is a spell name
            spellName = input
            spellID = CleveRoids.GetSpellIdForName and CleveRoids.GetSpellIdForName(spellName)
            school = CleveRoids.GetSpellSchool(spellName, spellID)
        end

        CleveRoids.Print("|cff88ff88=== Spell School Test ===|r")
        CleveRoids.Print("Spell: " .. (spellName or "Unknown") .. " (ID:" .. (spellID or "Unknown") .. ")")
        CleveRoids.Print("School: " .. (school or "|cffff0000Unknown|r"))

        if spellID and CleveRoids_SpellSchools[spellID] then
            CleveRoids.Print("|cff00ff00Source:|r Learned from Nampower damage events")
        elseif school then
            CleveRoids.Print("|cffffaa00Source:|r Tooltip/pattern matching")
        end
        return
    end

    -- listschools (show learned spell schools)
    if cmd == "listschools" or cmd == "schools" then
        CleveRoids.Print("|cff88ff88=== Learned Spell Schools ===|r")
        if not CleveRoids_SpellSchools or not next(CleveRoids_SpellSchools) then
            CleveRoids.Print("No spell schools learned yet. Deal damage to enemies!")
            CleveRoids.Print("Nampower damage events will automatically track spell schools.")
        else
            local count = 0
            local bySchool = {}

            -- Group by school
            for spellID, school in pairs(CleveRoids_SpellSchools) do
                if not bySchool[school] then
                    bySchool[school] = {}
                end
                table.insert(bySchool[school], spellID)
                count = count + 1
            end

            CleveRoids.Print("Total spells tracked: " .. count)
            CleveRoids.Print(" ")

            -- Display by school
            for school, spellIDs in pairs(bySchool) do
                local schoolColor = "|cff88ff88"
                if school == "fire" then schoolColor = "|cffff4400"
                elseif school == "frost" then schoolColor = "|cff00ffff"
                elseif school == "nature" then schoolColor = "|cff00ff00"
                elseif school == "shadow" then schoolColor = "|cff8800ff"
                elseif school == "arcane" then schoolColor = "|cffff00ff"
                elseif school == "holy" then schoolColor = "|cffffff00"
                elseif school == "bleed" then schoolColor = "|cffff0000"
                end

                CleveRoids.Print(schoolColor .. string.upper(school) .. "|r (" .. table.getn(spellIDs) .. " spells):")
                for _, spellID in ipairs(spellIDs) do
                    local spellName = SpellInfo and SpellInfo(spellID) or "Unknown"
                    CleveRoids.Print("  " .. spellName .. " (ID:" .. spellID .. ")")
                end
            end
        end
        return
    end

    -- clearschools (clear learned spell schools)
    if cmd == "clearschools" then
        local count = 0
        if CleveRoids_SpellSchools then
            for _ in pairs(CleveRoids_SpellSchools) do
                count = count + 1
            end
        end
        CleveRoids_SpellSchools = {}
        CleveRoids.spellSchoolMapping = CleveRoids_SpellSchools
        CleveRoids.Print("Cleared " .. count .. " learned spell schools")
        return
    end

    -- combotrack (show combo point tracking info)
    if cmd == "combotrack" or cmd == "combo" then
        CleveRoids.ShowComboTracking()
        return
    end

    -- comboclear (clear combo tracking data)
    if cmd == "comboclear" then
        CleveRoids.ComboPointTracking = {}
        CleveRoids.ComboPointTracking.byID = {}
        CleveRoids.Print("Combo point tracking data cleared")
        return
    end

    -- combolearn (show learned combo durations)
    if cmd == "combolearn" or cmd == "combodurations" then
        CleveRoids.Print("=== Learned Combo Durations ===")
        if not CleveRoids_ComboDurations or not next(CleveRoids_ComboDurations) then
            CleveRoids.Print("No learned combo durations yet. Cast finishers and let them expire!")
        else
            for spellID, cpData in pairs(CleveRoids_ComboDurations) do
                local spellName = SpellInfo(spellID) or ("Spell " .. spellID)
                CleveRoids.Print(spellName .. " (ID:" .. spellID .. "):")
                for cp = 1, 5 do
                    if cpData[cp] then
                        CleveRoids.Print("  " .. cp .. " CP = " .. cpData[cp] .. "s")
                    end
                end
            end
        end
        return
    end

    -- talenttabs (show talent tab IDs)
    if cmd == "talenttabs" or cmd == "tabs" then
        CleveRoids.Print("=== Talent Tabs ===")
        for i = 1, GetNumTalentTabs() do
            local name, _, pointsSpent = GetTalentTabInfo(i)
            CleveRoids.Print("Tab " .. i .. ": " .. name .. " (" .. pointsSpent .. " points)")
        end
        return
    end

    -- listtab (show all talents in a specific tab with their IDs)
    if cmd == "listtab" or cmd == "tab" then
        local tabNum = tonumber(val)
        if not tabNum or tabNum < 1 or tabNum > GetNumTalentTabs() then
            CleveRoids.Print("Usage: /cleveroid listtab <tab number>")
            CleveRoids.Print("Example: /cleveroid listtab 2")
            CleveRoids.Print("Use /cleveroid talenttabs to see your tab numbers")
            return
        end

        local tabName = GetTalentTabInfo(tabNum)
        CleveRoids.Print("=== " .. tabName .. " (Tab " .. tabNum .. ") ===")

        local numTalents = GetNumTalents(tabNum)
        for i = 1, numTalents do
            local name, _, _, _, rank, maxRank = GetTalentInfo(tabNum, i)
            if name then
                local rankText = rank .. "/" .. maxRank
                CleveRoids.Print("ID " .. i .. ": " .. name .. " [" .. rankText .. "]")
            end
        end
        return
    end

    -- talents (show current talent ranks)
    if cmd == "talents" or cmd == "talent" then
        CleveRoids.Print("=== Current Talents ===")

        -- Ensure talents are indexed
        if not CleveRoids.Talents or table.getn(CleveRoids.Talents) == 0 then
            if CleveRoids.IndexTalents then
                CleveRoids.IndexTalents()
            end
        end

        local count = 0
        for name, rank in pairs(CleveRoids.Talents) do
            if type(name) == "string" and tonumber(rank) and tonumber(rank) > 0 then
                CleveRoids.Print(name .. ": Rank " .. rank)
                count = count + 1
            end
        end

        if count == 0 then
            CleveRoids.Print("No talents learned yet!")
        else
            CleveRoids.Print("Total: " .. count .. " talents")
        end
        return
    end

    -- diagnosetalent (comprehensive diagnostic for talent modifier)
    if cmd == "diagnosetalent" or cmd == "diagtalent" then
        local spellID = tonumber(val)
        if not spellID then
            CleveRoids.Print("Usage: /cleveroid diagnosetalent <spellID>")
            CleveRoids.Print("Example: /cleveroid diagnosetalent 1943  (Rupture Rank 1)")
            return
        end

        -- Inline diagnostic
        local baseDuration = 10
        DEFAULT_CHAT_FRAME:AddMessage("|cff00ff00=== Talent Modifier Diagnostic ===|r")

        local spellName = SpellInfo(spellID)
        if not spellName then
            DEFAULT_CHAT_FRAME:AddMessage("|cffff0000ERROR: Invalid spell ID " .. tostring(spellID) .. "|r")
            return
        end
        DEFAULT_CHAT_FRAME:AddMessage("Spell: " .. spellName .. " (ID: " .. spellID .. ")")

        local modifier = CleveRoids.talentModifiers and CleveRoids.talentModifiers[spellID]
        if not modifier then
            DEFAULT_CHAT_FRAME:AddMessage("|cffff0000No talent modifier registered for this spell|r")
            return
        end

        local talentDesc = modifier.talent or ("Tab " .. tostring(modifier.tab) .. " ID " .. tostring(modifier.id))
        DEFAULT_CHAT_FRAME:AddMessage("Modifier registered: " .. talentDesc)

        -- Test position-based lookup
        local talentRank = 0
        local lookupMethod = "none"

        if modifier.tab and modifier.id then
            local _, name, _, _, rank = GetTalentInfo(modifier.tab, modifier.id)
            talentRank = tonumber(rank) or 0
            lookupMethod = "position"
            DEFAULT_CHAT_FRAME:AddMessage("|cff00ff00Position lookup (Tab " .. modifier.tab .. ", ID " .. modifier.id .. "):|r")
            DEFAULT_CHAT_FRAME:AddMessage("  Talent name: " .. tostring(name))
            DEFAULT_CHAT_FRAME:AddMessage("  Rank: " .. talentRank)
        end

        if modifier.talent and CleveRoids.GetTalentRank then
            local nameRank = CleveRoids.GetTalentRank(modifier.talent)
            DEFAULT_CHAT_FRAME:AddMessage("|cffaaaa00Name lookup (" .. modifier.talent .. "):|r")
            DEFAULT_CHAT_FRAME:AddMessage("  Rank: " .. nameRank)
            if talentRank == 0 and nameRank > 0 then
                talentRank = nameRank
                lookupMethod = "name"
            end
        end

        DEFAULT_CHAT_FRAME:AddMessage("Final rank: " .. talentRank .. " (via " .. lookupMethod .. ")")

        if talentRank > 0 then
            local modifiedDuration = modifier.modifier(baseDuration, talentRank)
            DEFAULT_CHAT_FRAME:AddMessage("|cff00ff00Test calculation:|r")
            DEFAULT_CHAT_FRAME:AddMessage("  Base: " .. baseDuration .. "s")
            DEFAULT_CHAT_FRAME:AddMessage("  Modified: " .. modifiedDuration .. "s")
            DEFAULT_CHAT_FRAME:AddMessage("  Bonus: +" .. (modifiedDuration - baseDuration) .. "s")
        else
            DEFAULT_CHAT_FRAME:AddMessage("|cffff0000You don't have " .. talentDesc .. "!|r")
        end

        DEFAULT_CHAT_FRAME:AddMessage("|cff00ff00=== End Diagnostic ===|r")
        return
    end

    -- testtalent (test talent modifier for a spell)
    if cmd == "testtalent" or cmd == "talenttest" then
        local spellID = tonumber(val)
        if not spellID then
            CleveRoids.Print("Usage: /cleveroid testtalent <spellID>")
            CleveRoids.Print("Example: /cleveroid testtalent 1943  (Rupture Rank 1)")
            return
        end

        local spellName = SpellInfo(spellID) or ("Spell " .. spellID)
        local modifier = CleveRoids.talentModifiers and CleveRoids.talentModifiers[spellID]

        if not modifier then
            CleveRoids.Print(spellName .. " (ID:" .. spellID .. ") has no talent modifier configured")
            return
        end

        -- Get talent rank using position-based or name-based lookup
        local talentRank = 0
        local maxRank = 3
        local talentName = modifier.talent or ("Tab " .. tostring(modifier.tab) .. " ID " .. tostring(modifier.id))

        -- Position-based lookup (preferred)
        if modifier.tab and modifier.id then
            local _, name, _, _, rank, max = GetTalentInfo(modifier.tab, modifier.id)
            talentRank = tonumber(rank) or 0
            maxRank = tonumber(max) or 3
            if name then
                talentName = name
            end
        end

        -- Name-based fallback
        if talentRank == 0 and modifier.talent and CleveRoids.GetTalentRank then
            talentRank = CleveRoids.GetTalentRank(modifier.talent)
        end

        CleveRoids.Print("=== Talent Modifier Test ===")
        CleveRoids.Print("Spell: " .. spellName .. " (ID:" .. spellID .. ")")
        CleveRoids.Print("Talent: " .. talentName)
        CleveRoids.Print("Your Rank: " .. talentRank .. "/" .. maxRank)

        if talentRank == 0 then
            CleveRoids.Print("|cffff0000You don't have this talent!|r")
        else
            -- Test with a base duration (use 10s as example)
            local baseDur = 10
            local modDur = modifier.modifier(baseDur, talentRank)
            CleveRoids.Print("Example: 10s base -> " .. modDur .. "s modified (+" .. (modDur - baseDur) .. "s)")
        end
        return
    end

    -- testequip (test equipment modifier for a spell)
    if cmd == "testequip" or cmd == "equiptest" then
        local spellID = tonumber(val)
        if not spellID then
            CleveRoids.Print("Usage: /cleveroid testequip <spellID>")
            CleveRoids.Print("Example: /cleveroid testequip 1079  (Rip Rank 1)")
            return
        end

        local spellName = SpellInfo(spellID) or ("Spell " .. spellID)
        local modifier = CleveRoids.equipmentModifiers and CleveRoids.equipmentModifiers[spellID]

        if not modifier then
            CleveRoids.Print(spellName .. " (ID:" .. spellID .. ") has no equipment modifier configured")
            return
        end

        local itemID = CleveRoids.GetEquippedItemID and CleveRoids.GetEquippedItemID(modifier.slot)
        local itemName = "None"
        if itemID then
            local itemLink = GetInventoryItemLink("player", modifier.slot)
            if itemLink then
                itemName = string.match(itemLink, "%[(.-)%]") or ("Item " .. itemID)
            end
        end

        CleveRoids.Print("=== Equipment Modifier Test ===")
        CleveRoids.Print("Spell: " .. spellName .. " (ID:" .. spellID .. ")")
        CleveRoids.Print("Slot: " .. modifier.slot .. " (Ranged/Relic)")
        CleveRoids.Print("Equipped: " .. itemName .. (itemID and (" [" .. itemID .. "]") or ""))

        if not itemID then
            CleveRoids.Print("|cffff0000No item equipped in this slot!|r")
        else
            -- Test with a base duration (use 10s as example)
            local baseDur = 10
            local modDur = modifier.modifier(baseDur, itemID)
            if modDur ~= baseDur then
                CleveRoids.Print("Example: 10s base -> " .. modDur .. "s modified")
                if modDur < baseDur then
                    CleveRoids.Print("|cffff0000Duration reduced by " .. (baseDur - modDur) .. "s|r")
                else
                    CleveRoids.Print("|cff00ff00Duration increased by " .. (modDur - baseDur) .. "s|r")
                end
            else
                CleveRoids.Print("|cffffaa00This item has no effect on this spell|r")
            end
        end
        return
    end

    -- equiplog (toggle real-time equip logging)
    if cmd == "equiplog" then
        CleveRoids.equipDebugLog = not CleveRoids.equipDebugLog
        CleveRoids.Print("Equip command logging " .. (CleveRoids.equipDebugLog and "|cff00ff00ENABLED|r" or "|cffff0000DISABLED|r"))
        if CleveRoids.equipDebugLog then
            CleveRoids.Print("Use /equip commands to see detailed lookup info")
        end
        return
    end

    -- equipdebug (debug item lookup for /equip command)
    if cmd == "equipdebug" then
        local itemName = val
        if val2 and val2 ~= "" then
            itemName = val .. " " .. val2
        end
        if not itemName or itemName == "" then
            CleveRoids.Print("Usage: /cleveroid equipdebug <item name>")
            CleveRoids.Print('Example: /cleveroid equipdebug Idol of Ferocity')
            return
        end
        -- Strip quotes if present
        itemName = string.gsub(itemName, '"', "")
        itemName = string.gsub(itemName, "_", " ")

        CleveRoids.Print("|cff00ff00=== Equipment Debug: " .. itemName .. " ===|r")

        -- Check equipped slot 18 (relic/idol)
        local slot18Link = GetInventoryItemLink("player", 18)
        if slot18Link then
            local _, _, slot18Name = string.find(slot18Link, "|h%[(.-)%]|h")
            CleveRoids.Print("Slot 18 equipped: " .. (slot18Name or "unknown"))
        else
            CleveRoids.Print("Slot 18 equipped: (empty)")
        end

        -- Check cache
        local Items = CleveRoids.Items or {}
        local cached = Items[itemName]
        CleveRoids.Print("|cffffaa00Cache lookup:|r")
        if cached then
            if type(cached) == "table" then
                if cached.inventoryID then
                    CleveRoids.Print("  Found in cache: EQUIPPED (inventoryID=" .. cached.inventoryID .. ")")
                elseif cached.bagID then
                    CleveRoids.Print("  Found in cache: BAG (bag=" .. cached.bagID .. ", slot=" .. cached.slot .. ")")
                else
                    CleveRoids.Print("  Found in cache: (type unknown)")
                end
            elseif type(cached) == "string" then
                CleveRoids.Print("  Found in cache: -> " .. cached .. " (canonical name)")
            end
        else
            CleveRoids.Print("  Not in cache")
        end

        -- Try GetItemFast
        CleveRoids.Print("|cffffaa00GetItemFast:|r")
        local fastItem = CleveRoids.GetItemFast and CleveRoids.GetItemFast(itemName)
        if fastItem then
            if fastItem.inventoryID then
                CleveRoids.Print("  Returns: EQUIPPED (inventoryID=" .. fastItem.inventoryID .. ")")
            elseif fastItem.bagID then
                CleveRoids.Print("  Returns: BAG (bag=" .. fastItem.bagID .. ", slot=" .. fastItem.slot .. ")")
            end
        else
            CleveRoids.Print("  Returns: nil")
        end

        -- Try FindItemQuick
        CleveRoids.Print("|cffffaa00FindItemQuick (scans equipped then bags):|r")
        local quickItem = CleveRoids.FindItemQuick and CleveRoids.FindItemQuick(itemName)
        if quickItem then
            if quickItem.inventoryID then
                CleveRoids.Print("  Returns: EQUIPPED (inventoryID=" .. quickItem.inventoryID .. ")")
            elseif quickItem.bagID then
                CleveRoids.Print("  Returns: BAG (bag=" .. quickItem.bagID .. ", slot=" .. quickItem.slot .. ")")
            end
        else
            CleveRoids.Print("  Returns: nil (item not found)")
        end

        -- Check HasGearEquipped (used by [equipped] conditional)
        CleveRoids.Print("|cffffaa00HasGearEquipped (conditional check):|r")
        local hasEquipped = CleveRoids.HasGearEquipped and CleveRoids.HasGearEquipped(itemName)
        CleveRoids.Print("  [equipped:" .. itemName .. "] = " .. (hasEquipped and "|cff00ff00TRUE|r" or "|cffff0000FALSE|r"))

        -- Combat state
        CleveRoids.Print("|cffffaa00Combat state:|r")
        CleveRoids.Print("  UnitAffectingCombat: " .. (UnitAffectingCombat("player") and "IN COMBAT" or "not in combat"))
        CleveRoids.Print("  playerClass: " .. (CleveRoids.playerClass or "unknown"))

        return
    end

    -- listprocs (show active reactive procs)
    if cmd == "listprocs" or cmd == "procs" or cmd == "reactive" then
        CleveRoids.Print("=== Active Reactive Procs ===")
        local found = false
        local now = GetTime()
        local _, currentTargetGUID = UnitExists("target")

        if CleveRoids.reactiveProcs then
            for spellName, procData in pairs(CleveRoids.reactiveProcs) do
                if procData and procData.expiry and procData.expiry > now then
                    local remaining = procData.expiry - now
                    local guidInfo = ""

                    if procData.targetGUID then
                        local matches = currentTargetGUID and (currentTargetGUID == procData.targetGUID)
                        if matches then
                            guidInfo = " |cff00ff00[Current Target]|r"
                        else
                            local targetName = UnitName("target")
                            if targetName then
                                guidInfo = " |cffff0000[Wrong Target: " .. targetName .. "]|r"
                            else
                                guidInfo = " |cffff0000[No Target]|r"
                            end
                        end
                    end

                    CleveRoids.Print(spellName .. ": " .. string.format("%.1fs", remaining) .. " remaining" .. guidInfo)
                    found = true
                end
            end
        end

        if not found then
            CleveRoids.Print("|cffffaa00No active reactive procs|r")
        end
        return
    end

    -- setproc (manually set a reactive proc for testing)
    if cmd == "setproc" or cmd == "procset" then
        if val == "" then
            CleveRoids.Print("Usage: /cleveroid setproc <spell> [duration]")
            CleveRoids.Print("Example: /cleveroid setproc Overpower 5")
            CleveRoids.Print("Note: Uses current target's GUID for target-specific procs")
            return
        end

        local duration = tonumber(val2) or 5.0
        local _, targetGUID = UnitExists("target")

        if CleveRoids.SetReactiveProc then
            CleveRoids.SetReactiveProc(val, duration, targetGUID)
            local guidMsg = targetGUID and (" for target [" .. (UnitName("target") or "Unknown") .. "]") or ""
            CleveRoids.Print("Set " .. val .. " proc for " .. duration .. " seconds" .. guidMsg)
        else
            CleveRoids.Print("|cffff0000Reactive proc system not loaded!|r")
        end
        return
    end

    -- clearproc (clear a reactive proc)
    if cmd == "clearproc" or cmd == "procclear" then
        if val == "" or val == "all" then
            CleveRoids.reactiveProcs = {}
            CleveRoids.Print("Cleared all reactive procs")
        else
            if CleveRoids.ClearReactiveProc then
                CleveRoids.ClearReactiveProc(val)
                CleveRoids.Print("Cleared " .. val .. " proc")
            else
                CleveRoids.Print("|cffff0000Reactive proc system not loaded!|r")
            end
        end
        CleveRoids.QueueActionUpdate()
        return
    end

    -- slamdebug (show Slam cast time and window calculations for Warrior rotation)
    if cmd == "slamdebug" or cmd == "slam" or cmd == "slamtime" then
        CleveRoids.Print("|cff88ff88=== Slam Clip Window Debug ===|r")

        -- Get swing timer info
        local attackSpeed = UnitAttackSpeed("player")
        if not attackSpeed or attackSpeed <= 0 then
            CleveRoids.Print("|cffff0000No attack speed available!|r")
            CleveRoids.Print("You need to be in combat or have a weapon equipped.")
            return
        end

        -- Check SP_SwingTimer
        if st_timer == nil then
            CleveRoids.Print("|cffff0000SP_SwingTimer not detected!|r")
            CleveRoids.Print("The [noslamclip] conditionals require SP_SwingTimer addon.")
            CleveRoids.Print("Get it at: https://github.com/jrc13245/SP_SwingTimer")
        else
            local timeElapsed = attackSpeed - st_timer
            local percentElapsed = (timeElapsed / attackSpeed) * 100
            CleveRoids.Print("|cffffaa00SP_SwingTimer:|r st_timer=" .. string.format("%.3f", st_timer) .. "s")
            CleveRoids.Print("Swing elapsed: " .. string.format("%.2f", percentElapsed) .. "%")
        end

        CleveRoids.Print(" ")
        CleveRoids.Print("|cffffaa00Swing Timer:|r " .. string.format("%.3f", attackSpeed) .. "s")

        -- Get Slam cast time from tooltip scanning
        local slamCastTime = CleveRoids.GetSlamCastTime()
        local isDefault = (slamCastTime == 1.5)

        CleveRoids.Print("|cffffaa00Slam Cast Time:|r " .. string.format("%.3f", slamCastTime) .. "s" .. (isDefault and " (default)" or " (from tooltip)"))

        -- Show tooltip scanning diagnostic info
        if CleveRoids.GetSlamSpellSlot then
            local slot = CleveRoids.GetSlamSpellSlot()
            if slot then
                CleveRoids.Print("  Slam found in spellbook slot: " .. slot)
            else
                CleveRoids.Print("  |cffff0000Slam not found in spellbook!|r Are you a Warrior?")
            end
        end

        if isDefault then
            CleveRoids.Print("  Note: Could not read from tooltip, using default 1.5s")
        end

        -- Calculate windows
        CleveRoids.Print(" ")
        local slamWindowTime = attackSpeed - slamCastTime
        local slamWindow = 0
        if slamWindowTime > 0 then
            slamWindow = (slamWindowTime / attackSpeed) * 100
        end

        local instantWindowTime = (2 * attackSpeed) - slamCastTime - 1.5
        local instantWindow = 0
        if instantWindowTime > 0 then
            instantWindow = (instantWindowTime / attackSpeed) * 100
        end

        CleveRoids.Print("|cff00ff00=== Window Calculations ===|r")
        CleveRoids.Print("|cffffaa00Slam Window:|r " .. string.format("%.2f", slamWindow) .. "%")
        CleveRoids.Print("  Formula: (SwingTimer - SlamCast) / SwingTimer")
        CleveRoids.Print("  (" .. string.format("%.3f", attackSpeed) .. " - " .. string.format("%.3f", slamCastTime) .. ") / " .. string.format("%.3f", attackSpeed) .. " = " .. string.format("%.2f", slamWindow) .. "%")
        CleveRoids.Print("  Max time to cast Slam: " .. string.format("%.3f", slamWindowTime) .. "s into swing")

        CleveRoids.Print(" ")
        CleveRoids.Print("|cffffaa00Instant Window:|r " .. string.format("%.2f", instantWindow) .. "%")
        CleveRoids.Print("  Formula: (2×SwingTimer - SlamCast - GCD) / SwingTimer")
        CleveRoids.Print("  (2×" .. string.format("%.3f", attackSpeed) .. " - " .. string.format("%.3f", slamCastTime) .. " - 1.5) / " .. string.format("%.3f", attackSpeed) .. " = " .. string.format("%.2f", instantWindow) .. "%")
        CleveRoids.Print("  Max time to cast instant: " .. string.format("%.3f", instantWindowTime) .. "s into swing")

        -- Show current status
        if st_timer ~= nil then
            CleveRoids.Print(" ")
            CleveRoids.Print("|cff00ff00=== Current Status ===|r")
            local timeElapsed = attackSpeed - st_timer
            local percentElapsed = (timeElapsed / attackSpeed) * 100
            local inSlamWindow = percentElapsed <= slamWindow
            local inInstantWindow = percentElapsed <= instantWindow
            CleveRoids.Print("[noslamclip]: " .. (inSlamWindow and "|cff00ff00TRUE|r (safe to Slam)" or "|cffff0000FALSE|r (would clip)"))
            CleveRoids.Print("[nonextslamclip]: " .. (inInstantWindow and "|cff00ff00TRUE|r (safe to instant)" or "|cffff0000FALSE|r (would clip next Slam)"))
        end

        return
    end

    -- formdebug (debug shapeshift form detection)
    if cmd == "formdebug" or cmd == "form" or cmd == "shapeshiftdebug" then
        CleveRoids.Print("|cff88ff88=== Shapeshift Form Debug ===|r")
        CleveRoids.Print("Player class: " .. tostring(CleveRoids.playerClass))

        local numForms = GetNumShapeshiftForms()
        CleveRoids.Print("Number of forms: " .. tostring(numForms))

        local currentIndex = CleveRoids.GetCurrentShapeshiftIndex()
        CleveRoids.Print("Current form index: " .. tostring(currentIndex))

        CleveRoids.Print(" ")
        CleveRoids.Print("|cff00ff00=== Form Details ===|r")
        for i = 1, numForms do
            local icon, name, isActive, isCastable = GetShapeshiftFormInfo(i)
            local activeStr = isActive and "|cff00ff00ACTIVE|r" or "|cff888888inactive|r"
            local castableStr = isCastable and "castable" or "not castable"
            CleveRoids.Print(string.format("Form %d: %s - %s (%s)", i, tostring(name), activeStr, castableStr))
        end

        CleveRoids.Print(" ")
        CleveRoids.Print("|cff00ff00=== ValidatePlayerBuff Tests ===|r")
        local testForms = {"Cat Form", "Bear Form", "Dire Bear Form", "Travel Form", "Aquatic Form", "Moonkin Form"}
        for _, formName in ipairs(testForms) do
            local result = CleveRoids.ValidatePlayerBuff(formName)
            local resultStr = result and "|cff00ff00true|r" or "|cffff0000false|r"
            CleveRoids.Print("  ValidatePlayerBuff('" .. formName .. "') = " .. resultStr)
        end
        return
    end

    -- debuffdebug (debug debuff tracking on target)
    if cmd == "debuffdebug" or cmd == "debuff" or cmd == "trackdebug" then
        local searchName = val
        if val2 and val2 ~= "" then
            searchName = val .. " " .. val2
        end
        -- Strip underscores and quotes
        if searchName and searchName ~= "" then
            searchName = string.gsub(searchName, "_", " ")
            searchName = string.gsub(searchName, '"', "")
        end

        CleveRoids.Print("|cff88ff88=== Debuff Tracking Debug ===|r")

        local _, guid = UnitExists("target")
        if not guid then
            CleveRoids.Print("|cffff0000No target selected!|r")
            return
        end

        local targetName = UnitName("target") or "Unknown"
        guid = CleveRoids.NormalizeGUID(guid)
        CleveRoids.Print("Target: " .. targetName .. " (GUID: " .. tostring(guid) .. ")")

        -- Show tracking table for this target
        CleveRoids.Print(" ")
        CleveRoids.Print("|cff00ff00=== Tracked Debuffs (libdebuff.objects) ===|r")
        local lib = CleveRoids.libdebuff
        if lib and lib.objects and lib.objects[guid] then
            local count = 0
            for spellID, rec in pairs(lib.objects[guid]) do
                if rec and rec.start and rec.duration then
                    local timeRemaining = rec.duration + rec.start - GetTime()
                    local spellName = SpellInfo and SpellInfo(spellID) or "Unknown"
                    local caster = rec.caster or "unknown"
                    local stacks = rec.stacks or 0
                    if timeRemaining > 0 then
                        CleveRoids.Print(string.format("  |cff00ff00[%d]|r %s: %.1fs left (caster: %s, stacks: %d)",
                            spellID, spellName, timeRemaining, caster, stacks))
                        count = count + 1
                    else
                        CleveRoids.Print(string.format("  |cffff0000[%d]|r %s: EXPIRED %.1fs ago (caster: %s)",
                            spellID, spellName, -timeRemaining, caster))
                    end
                end
            end
            if count == 0 then
                CleveRoids.Print("  (no active tracked debuffs)")
            end
        else
            CleveRoids.Print("  (no tracking data for this target)")
        end

        -- Show actual debuff slots (1-16 via UnitDebuff, 17-48 via overflow)
        CleveRoids.Print(" ")
        CleveRoids.Print("|cff00ff00=== Debuff Slots (UnitDebuff 1-16) ===|r")
        local debuffCount = 0
        for i = 1, 16 do
            local texture, stacks, debuffType, spellID = UnitDebuff("target", i)
            if texture then
                local spellName = SpellInfo and SpellInfo(spellID) or "slot" .. i
                CleveRoids.Print(string.format("  Slot %d: [%d] %s (stacks: %d)",
                    i, spellID or 0, spellName, stacks or 0))
                debuffCount = debuffCount + 1
            end
        end
        if debuffCount == 0 then
            CleveRoids.Print("  (no debuffs in slots 1-16)")
        end

        -- Show overflow debuffs in buff slots (17-48)
        CleveRoids.Print(" ")
        CleveRoids.Print("|cff00ff00=== Overflow Debuffs (UnitBuff 1-32 as debuffs 17-48) ===|r")
        local overflowCount = 0
        for i = 1, 32 do
            local texture, stacks, spellID = UnitBuff("target", i)
            if texture and spellID then
                -- Check if this might be an overflow debuff by checking libdebuff durations
                local isDebuff = lib and lib.durations and lib.durations[spellID]
                if isDebuff then
                    local spellName = SpellInfo and SpellInfo(spellID) or "slot" .. i
                    CleveRoids.Print(string.format("  Buff Slot %d (=Debuff %d): [%d] %s (stacks: %d) |cffff8800OVERFLOW|r",
                        i, i + 16, spellID, spellName, stacks or 0))
                    overflowCount = overflowCount + 1
                end
            end
        end
        if overflowCount == 0 then
            CleveRoids.Print("  (no overflow debuffs detected)")
        end

        -- If a specific debuff name was provided, test the conditional
        if searchName and searchName ~= "" then
            CleveRoids.Print(" ")
            CleveRoids.Print("|cff00ff00=== Testing [debuff:\"" .. searchName .. "\"] ===|r")

            -- Test ValidateUnitDebuff
            local result = CleveRoids.ValidateUnitDebuff("target", { name = searchName })
            CleveRoids.Print("ValidateUnitDebuff(target, {name='" .. searchName .. "'}): " ..
                (result and "|cff00ff00true|r" or "|cffff0000false|r"))

            -- Test with time conditional
            local resultTime = CleveRoids.ValidateUnitDebuff("target", { name = searchName, operator = "<", amount = 99999 })
            CleveRoids.Print("ValidateUnitDebuff(target, {name='" .. searchName .. "', operator='<', amount=99999}): " ..
                (resultTime and "|cff00ff00true|r" or "|cffff0000false|r"))

            -- Look for spell IDs matching this name
            CleveRoids.Print(" ")
            CleveRoids.Print("|cff00ff00=== Spell ID Lookup for \"" .. searchName .. "\" ===|r")
            local foundIDs = {}
            -- Check Spells table
            if CleveRoids.Spells then
                for id, name in pairs(CleveRoids.Spells) do
                    if type(name) == "string" and string.lower(name) == string.lower(searchName) then
                        table.insert(foundIDs, id)
                    end
                end
            end
            -- Also check SpellInfo
            if SpellInfo then
                for id = 1, 30000 do
                    local name = SpellInfo(id)
                    if name and string.lower(name) == string.lower(searchName) then
                        local found = false
                        for _, existingID in ipairs(foundIDs) do
                            if existingID == id then found = true break end
                        end
                        if not found then
                            table.insert(foundIDs, id)
                        end
                    end
                    -- Stop early if we found some
                    if table.getn(foundIDs) > 10 then break end
                end
            end

            if table.getn(foundIDs) > 0 then
                for _, id in ipairs(foundIDs) do
                    local tracked = lib and lib.objects and lib.objects[guid] and lib.objects[guid][id]
                    local trackedStr = tracked and "|cff00ff00TRACKED|r" or "|cff888888not tracked|r"
                    CleveRoids.Print("  SpellID " .. id .. ": " .. trackedStr)
                    if tracked then
                        local remaining = tracked.duration + tracked.start - GetTime()
                        CleveRoids.Print("    -> " .. string.format("%.1fs remaining (caster: %s)", remaining, tracked.caster or "?"))
                    end
                end
            else
                CleveRoids.Print("  (no spell IDs found for this name)")
            end
        end

        return
    end

    -- tooltipdebug (debug spell tooltip scanning)
    if cmd == "tooltipdebug" or cmd == "ttdebug" or cmd == "spelltooltip" then
        local spellName = val
        if val2 and val2 ~= "" then
            spellName = val .. " " .. val2
        end
        if not spellName or spellName == "" then
            spellName = "Arcane Missiles"  -- Default to Arcane Missiles
        end
        -- Strip underscores
        spellName = string.gsub(spellName, "_", " ")

        CleveRoids.Print("|cff88ff88=== Tooltip Scan Debug: " .. spellName .. " ===|r")

        -- Find highest rank spell in spellbook (same logic as GetSpellSlotByName)
        local slot, bookType = nil, nil
        local foundRank = nil
        local i = 1
        while true do
            local name, rank = GetSpellName(i, BOOKTYPE_SPELL)
            if not name then break end
            if name == spellName then
                -- Keep updating to find the last (highest) rank
                slot = i
                bookType = BOOKTYPE_SPELL
                foundRank = rank
            end
            i = i + 1
        end

        if not slot then
            CleveRoids.Print("|cffff0000Spell not found in spellbook!|r")
            return
        end

        CleveRoids.Print("Found in spellbook slot: " .. slot .. " (rank: " .. (foundRank or "none") .. ")")

        -- Create tooltip if needed
        if not CleveRoidsDebugTooltip then
            CreateFrame("GameTooltip", "CleveRoidsDebugTooltip", nil, "GameTooltipTemplate")
            CleveRoidsDebugTooltip:SetOwner(WorldFrame, "ANCHOR_NONE")
        end

        CleveRoidsDebugTooltip:ClearLines()
        CleveRoidsDebugTooltip:SetSpell(slot, bookType)

        CleveRoids.Print("Tooltip lines (" .. CleveRoidsDebugTooltip:NumLines() .. "):")
        for lineNum = 1, CleveRoidsDebugTooltip:NumLines() do
            local leftText = getglobal("CleveRoidsDebugTooltipTextLeft" .. lineNum)
            local rightText = getglobal("CleveRoidsDebugTooltipTextRight" .. lineNum)

            local leftStr = leftText and leftText:GetText() or ""
            local rightStr = rightText and rightText:GetText() or ""

            if leftStr and leftStr ~= "" then
                CleveRoids.Print("  L" .. lineNum .. ": " .. leftStr)
                -- Check for duration pattern
                local duration = string.match(leftStr, "for (%d+%.?%d*) sec")
                if duration then
                    CleveRoids.Print("    |cff00ff00^ Found 'for X sec': " .. duration .. "s|r")
                end
                local duration2 = string.match(leftStr, "over (%d+%.?%d*) sec")
                if duration2 then
                    CleveRoids.Print("    |cff00ff00^ Found 'over X sec': " .. duration2 .. "s|r")
                end
            end
            if rightStr and rightStr ~= "" then
                CleveRoids.Print("  R" .. lineNum .. ": " .. rightStr)
            end
        end

        -- Show what GetSpellDurationFromTooltip returns
        local cachedDuration = CleveRoids.GetSpellDurationFromTooltip and CleveRoids.GetSpellDurationFromTooltip(spellName)
        CleveRoids.Print(" ")
        CleveRoids.Print("GetSpellDurationFromTooltip result: " .. (cachedDuration and (cachedDuration .. "s") or "|cffff0000nil|r"))

        return
    end

    -- Unknown command fallback
    CleveRoids.Print("Usage:")
    DEFAULT_CHAT_FRAME:AddMessage("/cleveroid - Show current settings")
    DEFAULT_CHAT_FRAME:AddMessage("/cleveroid realtime 0 or 1 - Force realtime updates (Default: 0. 1 = on, increases CPU load)")
    DEFAULT_CHAT_FRAME:AddMessage("/cleveroid refresh X - Set refresh rate (1 to 10 updates per second. Default: 5)")
    if CleveRoids.hasSuperwow then
        DEFAULT_CHAT_FRAME:AddMessage("/cleveroid learn <spellID> <duration> - Manually set spell duration")
        DEFAULT_CHAT_FRAME:AddMessage("/cleveroid forget <spellID|all> - Forget learned duration(s)")
        DEFAULT_CHAT_FRAME:AddMessage("/cleveroid debug [0|1] - Toggle learning debug messages")
    end
    DEFAULT_CHAT_FRAME:AddMessage("|cffffaa00Immunity Tracking:|r")
    DEFAULT_CHAT_FRAME:AddMessage('/cleveroid listimmune [school] - List immunity data')
    DEFAULT_CHAT_FRAME:AddMessage('/cleveroid addimmune "<NPC>" <school> [buff] - Add immunity')
    DEFAULT_CHAT_FRAME:AddMessage('/cleveroid removeimmune "<NPC>" <school> - Remove immunity')
    DEFAULT_CHAT_FRAME:AddMessage('/cleveroid clearimmune [school] - Clear immunity data')
    DEFAULT_CHAT_FRAME:AddMessage("|cffffaa00CC Immunity Tracking:|r")
    DEFAULT_CHAT_FRAME:AddMessage('/cleveroid listccimmune [type] - List CC immunity data')
    DEFAULT_CHAT_FRAME:AddMessage('/cleveroid addccimmune "<NPC>" <type> [buff] - Add CC immunity')
    DEFAULT_CHAT_FRAME:AddMessage('/cleveroid removeccimmune "<NPC>" <type> - Remove CC immunity')
    DEFAULT_CHAT_FRAME:AddMessage('/cleveroid clearccimmune [type] - Clear CC immunity data')
    DEFAULT_CHAT_FRAME:AddMessage("|cffffaa00Combo Point Tracking:|r")
    DEFAULT_CHAT_FRAME:AddMessage('/cleveroid combotrack - Show combo point tracking info')
    DEFAULT_CHAT_FRAME:AddMessage('/cleveroid comboclear - Clear combo tracking data')
    DEFAULT_CHAT_FRAME:AddMessage('/cleveroid combolearn - Show learned combo durations (per CP)')
end

SLASH_CLEAREQUIPQUEUE1 = "/clearequipqueue"
SlashCmdList.CLEAREQUIPQUEUE = function()
    -- Release all entries back to pool
    for i = 1, CleveRoids.equipmentQueueLen do
        local entry = CleveRoids.equipmentQueue[i]
        if entry then
            CleveRoids.equipmentQueue[i] = nil
            -- Return to pool if space available
            if table.getn(CleveRoids.queueEntryPool) < 10 then
                entry.item = nil
                entry.slotName = nil
                entry.inventoryId = nil
                table.insert(CleveRoids.queueEntryPool, entry)
            end
        end
    end
    CleveRoids.equipmentQueueLen = 0
    if CleveRoids.equipQueueFrame then
        CleveRoids.equipQueueFrame:Hide()
    end
    CleveRoids.Print("Equipment queue cleared")
end

SLASH_EQUIPQUEUESTATUS1 = "/equipqueuestatus"
SlashCmdList.EQUIPQUEUESTATUS = function()
    local count = CleveRoids.equipmentQueueLen
    CleveRoids.Print("Equipment queue has " .. count .. " pending items")

    for i = 1, count do
        local entry = CleveRoids.equipmentQueue[i]
        if entry then
            local itemName = (entry.item and entry.item.name) or "Unknown"
            local slotName = entry.slotName or "Unknown"
            local retries = entry.retries or 0
            CleveRoids.Print(i .. ". " .. itemName .. " -> " .. slotName .. " (retries: " .. retries .. ")")
        end
    end
end

-- Apply temporary weapon enchants (poisons, oils, sharpening stones, etc.)
-- Usage: /applymain [conditionals] ItemName
-- Usage: /applyoff [conditionals] ItemName
-- Example: /applymain [nomhimbue] Instant Poison
-- Example: /applyoff [combat] Crippling Poison

local function FindItemInBags(itemName)
    -- Require a non-empty item name to prevent matching everything
    if not itemName or itemName == "" then
        return nil
    end

    local searchName = string.lower(itemName)
    for bag = 0, 4 do
        for slot = 1, GetContainerNumSlots(bag) do
            local link = GetContainerItemLink(bag, slot)
            if link then
                local _, _, foundName = string.find(link, "%[(.+)%]")
                if foundName and string.find(string.lower(foundName), searchName, 1, true) then
                    return bag, slot, foundName
                end
            end
        end
    end
    return nil
end

function CleveRoids.DoApply(hand, msg)
    local weaponSlots = {
        ["main"] = 16,
        ["off"] = 17,
    }

    local slot = weaponSlots[hand]
    if not slot then
        CleveRoids.Print("Invalid hand: " .. tostring(hand))
        return false
    end

    local action = function(itemName)
        local bag, bagSlot, foundName = FindItemInBags(itemName)
        if not bag then
            CleveRoids.Print("Item not found: " .. itemName)
            return false
        end

        -- Apply the item to the weapon
        UseContainerItem(bag, bagSlot)
        PickupInventoryItem(slot)
        ReplaceEnchant()
        ClearCursor()
        return true
    end

    local handled = false
    for _, v in pairs(CleveRoids.splitStringIgnoringQuotes(msg)) do
        if CleveRoids.DoWithConditionals(v, action, CleveRoids.FixEmptyTarget, false, action) then
            handled = true
            break
        end
    end
    return handled
end

SLASH_APPLYMAIN1 = "/applymain"
SlashCmdList.APPLYMAIN = function(msg)
    -- Require an item name argument
    if not msg or msg == "" or string.gsub(msg, "%s+", "") == "" then
        CleveRoids.Print("Usage: /applymain [conditionals] ItemName")
        return
    end
    CleveRoids.DoApply("main", msg)
end

SLASH_APPLYOFF1 = "/applyoff"
SlashCmdList.APPLYOFF = function(msg)
    -- Require an item name argument
    if not msg or msg == "" or string.gsub(msg, "%s+", "") == "" then
        CleveRoids.Print("Usage: /applyoff [conditionals] ItemName")
        return
    end
    CleveRoids.DoApply("off", msg)
end
--[[
	Author: Dennis Werner Garske (DWG) / brian / Mewtiny
	License: MIT License
]]
local _G = _G or getfenv(0)
local CleveRoids = _G.CleveRoids or {}

SLASH_PETATTACK1 = "/petattack"

SlashCmdList.PETATTACK = function(msg) CleveRoids.DoPetAction(PetAttack, msg); end

SLASH_PETFOLLOW1 = "/petfollow"

SlashCmdList.PETFOLLOW = function(msg) CleveRoids.DoPetAction(PetFollow, msg); end

SLASH_PETWAIT1 = "/petwait"

SlashCmdList.PETWAIT = function(msg) CleveRoids.DoPetAction(PetWait, msg); end

SLASH_PETPASSIVE1 = "/petpassive"

SlashCmdList.PETPASSIVE = function(msg) CleveRoids.DoPetAction(PetPassiveMode, msg); end

SLASH_PETAGGRESSIVE1 = "/petaggressive"

SlashCmdList.PETAGGRESSIVE = function(msg) CleveRoids.DoPetAction(PetAggressiveMode, msg); end

SLASH_PETDEFENSIVE1 = "/petdefensive"

SlashCmdList.PETDEFENSIVE = function(msg) CleveRoids.DoPetAction(PetDefensiveMode, msg); end

SLASH_RELOAD1 = "/rl"

SlashCmdList.RELOAD = function() ReloadUI(); end

SLASH_USE1 = "/use"

SlashCmdList.USE = CleveRoids.DoUse

SLASH_EQUIP1 = "/equip"

SlashCmdList.EQUIP = CleveRoids.DoUse
-- take back supermacro and pfUI /equip and /use
SlashCmdList.SMEQUIP = CleveRoids.DoUse
SlashCmdList.PFEQUIP = CleveRoids.DoUse
SlashCmdList.PFUSE = CleveRoids.DoUse

SLASH_EQUIPMH1 = "/equipmh"
SlashCmdList.EQUIPMH = CleveRoids.DoEquipMainhand

SLASH_EQUIPOH1 = "/equipoh"
SlashCmdList.EQUIPOH = CleveRoids.DoEquipOffhand

SLASH_EQSLOT111 = "/equip11"
SlashCmdList.EQSLOT11 = CleveRoids.DoEquipRing1

SLASH_EQSLOT121 = "/equip12"
SlashCmdList.EQSLOT12 = CleveRoids.DoEquipRing2

SLASH_EQSLOT131 = "/equip13"
SlashCmdList.EQSLOT13 = CleveRoids.DoEquipTrinket1

SLASH_EQSLOT141 = "/equip14"
SlashCmdList.EQSLOT14 = CleveRoids.DoEquipTrinket2

SLASH_UNSHIFT1 = "/unshift"

SlashCmdList.UNSHIFT = CleveRoids.DoUnshift

SLASH_UNQUEUE1 = "/unqueue"
SlashCmdList.UNQUEUE = SpellStopCasting

-- TODO make this conditional too
SLASH_CANCELAURA1 = "/cancelaura"
SLASH_CANCELAURA2 = "/unbuff"

SlashCmdList.CANCELAURA = CleveRoids.DoConditionalCancelAura

SLASH_CASTPET1 = "/castpet"

SlashCmdList.CASTPET = function(msg)
    CleveRoids.DoCastPet(msg)
end

-- Define original implementations before hooking them.
-- This ensures we have a fallback for non-conditional use.
local StartAttack = function(msg)
    if not UnitExists("target") or UnitIsDead("target") then TargetNearestEnemy() end
    if not CleveRoids.CurrentSpell.autoAttack and not CleveRoids.CurrentSpell.autoAttackLock and UnitExists("target") and UnitCanAttack("player","target") then
        CleveRoids.CurrentSpell.autoAttackLock = true
        CleveRoids.autoAttackLockElapsed = GetTime()
        AttackTarget()
    end
end

local StopAttack = function(msg)
    if CleveRoids.CurrentSpell.autoAttack and UnitExists("target") then
        AttackTarget()
        CleveRoids.CurrentSpell.autoAttack = false
    end
end

-- Register slash commands and assign original handlers.
-- These will be hooked immediately after.
SLASH_STARTATTACK1 = "/startattack"
SlashCmdList.STARTATTACK = StartAttack

SLASH_STOPATTACK1 = "/stopattack"
SlashCmdList.STOPATTACK = StopAttack

SLASH_STOPCASTING1 = "/stopcasting"
SlashCmdList.STOPCASTING = SpellStopCasting

SLASH_CLEARTARGET1 = "/cleartarget"
SlashCmdList.CLEARTARGET = ClearTarget

----------------------------------
-- HOOK DEFINITIONS START
----------------------------------

-- /cleartarget hook
CleveRoids.Hooks.CLEARTARGET_SlashCmd = SlashCmdList.CLEARTARGET
SlashCmdList.CLEARTARGET = function(msg)
    msg = msg or ""
    if string.find(msg, "%[") then
        -- If conditionals are present, let the function handle it.
        CleveRoids.DoConditionalClearTarget(msg)
    else
        -- If no conditionals, run the original command.
        CleveRoids.Hooks.CLEARTARGET_SlashCmd()
    end
end

-- /startattack hook
CleveRoids.Hooks.STARTATTACK_SlashCmd = SlashCmdList.STARTATTACK
SlashCmdList.STARTATTACK = function(msg)
    if CleveRoids.stopMacroFlag then return end
    msg = msg or ""
    if string.find(msg, "%[") then
        CleveRoids.DoConditionalStartAttack(msg)
    else
        CleveRoids.Hooks.STARTATTACK_SlashCmd(msg)
    end
end

-- /stopattack hook
CleveRoids.Hooks.STOPATTACK_SlashCmd = SlashCmdList.STOPATTACK
SlashCmdList.STOPATTACK = function(msg)
    if CleveRoids.stopMacroFlag then return end
    msg = msg or ""
    if string.find(msg, "%[") then
        -- If conditionals are present, let the function handle it.
        -- It will only stop the attack if the conditions are met.
        CleveRoids.DoConditionalStopAttack(msg)
    else
        -- If no conditionals, run the original command.
        CleveRoids.Hooks.STOPATTACK_SlashCmd(msg)
    end
end

-- /stopcasting hook
CleveRoids.Hooks.STOPCASTING_SlashCmd = SlashCmdList.STOPCASTING
SlashCmdList.STOPCASTING = function(msg)
    if CleveRoids.stopMacroFlag then return end
    msg = msg or ""
    if string.find(msg, "%[") then
        -- If conditionals are present, let the function handle it.
        -- It will only stop the cast if the conditions are met.
        CleveRoids.DoConditionalStopCasting(msg)
    else
        -- If no conditionals, run the original command.
        CleveRoids.Hooks.STOPCASTING_SlashCmd()
    end
end

-- /unqueue hook
CleveRoids.Hooks.UNQUEUE_SlashCmd = SlashCmdList.UNQUEUE
SlashCmdList.UNQUEUE = function(msg)
    if CleveRoids.stopMacroFlag then return end
    msg = msg or ""
    if string.find(msg, "%[") then
        -- If conditionals are present, let the function handle it.
        CleveRoids.DoConditionalStopCasting(msg)
    else
        -- If no conditionals, run the original command.
        CleveRoids.Hooks.UNQUEUE_SlashCmd()
    end
end

-- /cast hook
CleveRoids.Hooks.CAST_SlashCmd = SlashCmdList.CAST
SlashCmdList.CAST = function(msg)
    if CleveRoids.stopMacroFlag or CleveRoids.skipMacroFlag then return end
    if msg and string.find(msg, "[%[%?!~{]") then
        CleveRoids.DoCast(msg)
    else
        -- Use lastComboPoints which is updated on every OnUpdate tick
        -- This is critical for instant-cast finishers where GetComboPoints() returns 0 immediately
        local currentCP = CleveRoids.lastComboPoints or 0

        -- Also try GetComboPoints as a fallback
        if currentCP == 0 and GetComboPoints then
            currentCP = GetComboPoints()
        end

        if currentCP > 0 then
            if CleveRoids.debug then
                DEFAULT_CHAT_FRAME:AddMessage(
                    string.format("|cffaaff00[/cast Hook]|r Using %d CP for %s",
                        currentCP, msg)
                )
            end

            -- Pre-inject combo duration into pfUI for instant-cast combo finishers
            -- Get the spell data to find the proper spell name (handles case-insensitive input)
            local spellData = CleveRoids.GetSpell and CleveRoids.GetSpell(msg)
            local spellName = spellData and spellData.name or msg

            -- If GetSpell didn't find it, capitalize first letter as fallback
            if not spellData and spellName then
                spellName = string.upper(string.sub(spellName, 1, 1)) .. string.sub(spellName, 2)
            end

            if CleveRoids.debug then
                DEFAULT_CHAT_FRAME:AddMessage(
                    string.format("|cffcccccc[/cast Debug]|r input='%s', spellName='%s', GetSpell=%s, IsComboScalingSpell=%s",
                        msg, spellName or "nil", tostring(spellData ~= nil), tostring(CleveRoids.IsComboScalingSpell ~= nil))
                )
            end

            if CleveRoids.IsComboScalingSpell and CleveRoids.IsComboScalingSpell(spellName) then
                if CleveRoids.debug then
                    DEFAULT_CHAT_FRAME:AddMessage("|cff00ff00[/cast Debug]|r IS combo scaling spell")
                end
                local duration = CleveRoids.CalculateComboScaledDuration and
                                 CleveRoids.CalculateComboScaledDuration(spellName, currentCP)
                if CleveRoids.debug then
                    DEFAULT_CHAT_FRAME:AddMessage(
                        string.format("|cffcccccc[/cast Debug]|r duration=%s, pfUI=%s, pfUI.api=%s, pfUI.api.libdebuff=%s, debuffs=%s",
                            tostring(duration), tostring(pfUI ~= nil),
                            tostring(pfUI and pfUI.api ~= nil),
                            tostring(pfUI and pfUI.api and pfUI.api.libdebuff ~= nil),
                            tostring(pfUI and pfUI.api and pfUI.api.libdebuff and pfUI.api.libdebuff.debuffs ~= nil))
                    )
                end
                if duration and CleveRoids.ComboPointTracking then
                    -- Remove rank from spell name for pfUI compatibility
                    local baseName = string.gsub(spellName, "%s*%(Rank %d+%)", "")
                    -- Populate name-based tracking BEFORE the spell is cast
                    -- This allows pfUI's AddEffect hook to find it
                    CleveRoids.ComboPointTracking[baseName] = {
                        combo_points = currentCP,
                        duration = duration,
                        cast_time = GetTime(),
                        target = UnitName("target") or "Unknown",
                        confirmed = true
                    }
                    if CleveRoids.debug then
                        DEFAULT_CHAT_FRAME:AddMessage(
                            string.format("|cffff00ff[/cast Pre-Tracking]|r Set tracking['%s'] = %ds (%d CP)",
                                baseName, duration, currentCP)
                        )
                    end
                end
            elseif CleveRoids.debug and currentCP > 0 then
                DEFAULT_CHAT_FRAME:AddMessage("|cffff9900[/cast Debug]|r NOT a combo scaling spell")
            end
        end
        CleveRoids.Hooks.CAST_SlashCmd(msg)
    end
end

CleveRoids.Hooks.TARGET_SlashCmd = SlashCmdList.TARGET
CleveRoids.TARGET_SlashCmd = function(msg)
    tmsg = CleveRoids.Trim(msg)

    if tmsg ~= "" and not string.find(tmsg, "%[") and not string.find(tmsg, "@") then
        CleveRoids.Hooks.TARGET_SlashCmd(tmsg)
        return
    end

    if CleveRoids.DoTarget(tmsg) then
        if UnitExists("target") then
            return
        end
    end
    CleveRoids.Hooks.TARGET_SlashCmd(msg)
end
SlashCmdList.TARGET = CleveRoids.TARGET_SlashCmd


SLASH_CASTSEQUENCE1 = "/castsequence"
SlashCmdList.CASTSEQUENCE = function(msg)
    msg = CleveRoids.Trim(msg)
    local sequence = CleveRoids.GetSequence(msg)
    if not sequence then return end
    -- if not sequence.active then return end

    CleveRoids.DoCastSequence(sequence)
end


SLASH_RUNMACRO1 = "/runmacro"
SlashCmdList.RUNMACRO = function(msg)
    return CleveRoids.ExecuteMacroByName(CleveRoids.Trim(msg))
end

-- Global RunMacro wrapper for user convenience (delegates to namespaced internal function)
-- This pattern ensures internal logic uses CleveRoids.ExecuteMacroByName and won't break
-- if another addon overwrites the global RunMacro
-- NOTE: When SuperMacro is also loaded, Compatibility/SuperMacro.lua redirects this to
-- SuperMacro_RunMacro so macros go through RunLine (where CRM commands are intercepted)
function RunMacro(name)
    return CleveRoids.ExecuteMacroByName(name)
end

SLASH_RETARGET1 = "/retarget"
SlashCmdList.RETARGET = function(msg)
    CleveRoids.DoRetarget()
end

SLASH_STOPMACRO1 = "/stopmacro"
SlashCmdList.STOPMACRO = function(msg)
    CleveRoids.DoStopMacro(msg)
end

SLASH_SKIPMACRO1 = "/skipmacro"
SlashCmdList.SKIPMACRO = function(msg)
    CleveRoids.DoSkipMacro(msg)
end

-- Enable "first action only" mode - stop evaluation after first successful /cast or /use
-- Example:
--   /firstaction
--   /cast [myrawpower:>48] Shred
--   /cast [myrawpower:>40] Claw
-- Result: Only Shred casts if energy >= 48, Claw won't be queued
SLASH_FIRSTACTION1 = "/firstaction"
SlashCmdList.FIRSTACTION = function(msg)
    CleveRoids.DoFirstAction(msg)
end

-- Re-enable multi-queue behavior after /firstaction
-- Use this to restore normal evaluation where multiple casts can queue
-- Example:
--   /firstaction
--   /cast [myrawpower:>48] Shred      -- Priority section
--   /cast [myrawpower:>40] Claw
--   /nofirstaction
--   /cast Tiger's Fury                -- Can queue alongside above
SLASH_NOFIRSTACTION1 = "/nofirstaction"
SlashCmdList.NOFIRSTACTION = function(msg)
    CleveRoids.DoNoFirstAction(msg)
end

-- QuickHeal with conditionals support (requires QuickHeal addon)
-- Usage: /quickheal [conditionals] [target] [type]
-- Examples:
--   /quickheal                     -- Smart heal (auto-select target)
--   /quickheal target              -- Heal current target
--   /quickheal [combat] party      -- Heal party member if in combat
--   /quickheal [mypower:>50] mt    -- Heal tank if mana > 50%
--   /quickheal [threat:<80] hot    -- Apply HoT if threat is low
SLASH_QUICKHEAL1 = "/quickheal"
SLASH_QUICKHEAL2 = "/qh"
SlashCmdList.QUICKHEAL = function(msg)
    CleveRoids.DoQuickHeal(msg)
end

--- Execute QuickHeal with optional conditionals
--- @param msg string The command arguments (conditionals + QuickHeal params)
function CleveRoids.DoQuickHeal(msg)
    -- Check if QuickHeal addon is loaded
    if type(QuickHeal) ~= "function" then
        if not CleveRoids._quickHealErrorShown then
            DEFAULT_CHAT_FRAME:AddMessage("|cffff0000[SuperCleveRoidMacros]|r The /quickheal command requires the QuickHeal addon.", 1, 0.5, 0.5)
            CleveRoids._quickHealErrorShown = true
        end
        return
    end

    msg = CleveRoids.Trim(msg or "")

    -- Check if there are conditionals
    if string.find(msg, "^%[") then
        -- Parse the conditionals and remaining args
        local actions = CleveRoids.ParseMsg(msg)

        if not actions or table.getn(actions) == 0 then
            -- No valid actions parsed, just run QuickHeal
            QuickHeal()
            return
        end

        -- Find the first action whose conditionals pass
        for i = 1, table.getn(actions) do
            local action = actions[i]
            if CleveRoids.TestAction(action) then
                -- Conditionals passed - extract the target/type from action args
                local healTarget = nil
                local healType = nil

                if action.args then
                    -- Parse args - could be "target", "party", "mt", "hot", etc.
                    local args = CleveRoids.Trim(action.args)
                    if args ~= "" then
                        -- Check if it's a target or type keyword
                        local lowerArgs = string.lower(args)
                        if lowerArgs == "hot" or lowerArgs == "heal" or lowerArgs == "hs" or lowerArgs == "chainheal" then
                            healType = args
                        else
                            -- Assume it's a target specifier
                            healTarget = args
                        end
                    end
                end

                -- Execute QuickHeal with parsed parameters
                QuickHeal(healTarget, nil, nil, nil)
                return
            end
        end
        -- No conditions matched - don't heal
        return
    else
        -- No conditionals, pass through to QuickHeal directly
        -- Parse basic args: target and/or type
        local args = msg
        if args == "" then
            QuickHeal()
        else
            -- QuickHeal accepts: Target, SpellID, extParam, forceMaxHPS
            -- Common targets: player, target, targettarget, party, mt, nonmt, subgroup
            -- Common types: heal, hot, hs (paladin), chainheal (shaman)
            QuickHeal(args)
        end
    end
end
